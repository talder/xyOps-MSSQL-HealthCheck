{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"items": [
		{
			"type": "plugin",
			"data": {
				"id": "pml6dhw0bycvgul4",
				"title": "MSSQL Health Check",
				"enabled": true,
				"type": "event",
				"command": "pwsh",
				"script": "# (c)2026 Tim Alderweireldt - xyOps MSSQL Health Check Plugin - PowerShell Version\n# Comprehensive SQL Server Health Check with AG support, detailed remediation, and multi-server comparison\n\nfunction Write-Output-JSON {\n    param($Object)\n    $json = $Object | ConvertTo-Json -Compress -Depth 100\n    Write-Output $json\n    [Console]::Out.Flush()\n}\n\nfunction Send-Progress {\n    param([double]$Value, [string]$Message = \"\")\n    if ($Message) {\n        Write-Host $Message\n    }\n    Write-Output-JSON @{ xy = 1; progress = $Value }\n}\n\nfunction Send-Success {\n    param([string]$Description = \"Health check completed successfully\")\n    Write-Output-JSON @{ xy = 1; code = 0; description = $Description }\n}\n\nfunction Send-Error {\n    param([int]$Code, [string]$Description)\n    Write-Output-JSON @{ xy = 1; code = $Code; description = $Description }\n}\n\n# Function to get latest CU information for SQL Server version\nfunction Get-LatestCUInfo {\n    param([int]$VersionMajor, [string]$BuildNumber)\n    \n    # Latest CU information as of February 2026\n    # NOTE: Update this table periodically with latest CU information\n    $cuInfo = @{\n        16 = @{  # SQL Server 2022\n            VersionName = \"SQL Server 2022\"\n            LatestCU = \"CU16\"\n            LatestBuild = \"16.0.4165.4\"\n            DownloadLink = \"https://www.microsoft.com/download/details.aspx?id=106034\"\n            KBArticle = \"https://support.microsoft.com/help/5046862\"\n        }\n        15 = @{  # SQL Server 2019\n            VersionName = \"SQL Server 2019\"\n            LatestCU = \"CU30\"\n            LatestBuild = \"15.0.4405.4\"\n            DownloadLink = \"https://www.microsoft.com/download/details.aspx?id=100809\"\n            KBArticle = \"https://support.microsoft.com/help/5046877\"\n        }\n        14 = @{  # SQL Server 2017\n            VersionName = \"SQL Server 2017\"\n            LatestCU = \"CU31\"\n            LatestBuild = \"14.0.3465.1\"\n            DownloadLink = \"https://www.microsoft.com/download/details.aspx?id=56128\"\n            KBArticle = \"https://support.microsoft.com/help/5016884\"\n        }\n        13 = @{  # SQL Server 2016\n            VersionName = \"SQL Server 2016 SP3\"\n            LatestCU = \"SP3 + CU1\"\n            LatestBuild = \"13.0.7000.253\"\n            DownloadLink = \"https://www.microsoft.com/download/details.aspx?id=56840\"\n            KBArticle = \"https://support.microsoft.com/help/5033583\"\n        }\n        12 = @{  # SQL Server 2014\n            VersionName = \"SQL Server 2014 SP3\"\n            LatestCU = \"SP3 + CU4\"\n            LatestBuild = \"12.0.6449.1\"\n            DownloadLink = \"https://www.microsoft.com/download/details.aspx?id=58213\"\n            KBArticle = \"https://support.microsoft.com/help/4583462\"\n        }\n        11 = @{  # SQL Server 2012\n            VersionName = \"SQL Server 2012 SP4\"\n            LatestCU = \"SP4 (End of Support)\"\n            LatestBuild = \"11.0.7507.2\"\n            DownloadLink = \"https://www.microsoft.com/download/details.aspx?id=56040\"\n            KBArticle = \"https://support.microsoft.com/help/4018073\"\n        }\n    }\n    \n    if ($cuInfo.ContainsKey($VersionMajor)) {\n        return $cuInfo[$VersionMajor]\n    } else {\n        return @{\n            VersionName = \"SQL Server (Unknown Version)\"\n            LatestCU = \"Unknown\"\n            LatestBuild = \"N/A\"\n            DownloadLink = \"https://learn.microsoft.com/en-us/sql/database-engine/install-windows/latest-updates-for-microsoft-sql-server\"\n            KBArticle = \"https://learn.microsoft.com/en-us/sql/database-engine/install-windows/latest-updates-for-microsoft-sql-server\"\n        }\n    }\n}\n\n# Read input from STDIN\n$inputJson = [Console]::In.ReadToEnd()\n\ntry {\n    $jobData = $inputJson | ConvertFrom-Json -AsHashtable\n}\ncatch {\n    Send-Error -Code 1 -Description \"Failed to parse input JSON: $($_.Exception.Message)\"\n    exit 1\n}\n\n# Extract parameters\n$params = $jobData.params\n\n# Helper function to get parameter value case-insensitively\nfunction Get-ParamValue {\n    param($ParamsObject, [string]$ParamName)\n    if ($ParamsObject -is [hashtable]) {\n        foreach ($key in $ParamsObject.Keys) {\n            if ($key -ieq $ParamName) {\n                return $ParamsObject[$key]\n            }\n        }\n        return $null\n    } else {\n        $prop = $ParamsObject.PSObject.Properties | Where-Object { $_.Name -ieq $ParamName } | Select-Object -First 1\n        if ($prop) { return $prop.Value }\n        return $null\n    }\n}\n\n# Get parameters\n$server = Get-ParamValue -ParamsObject $params -ParamName 'server'\n$username = $env:MSSQLHC_USERNAME\n$password = $env:MSSQLHC_PASSWORD\n$serverAdminUser = $env:MSSQLHC_SERVER_ADMIN_USER\n$serverAdminPassword = $env:MSSQLHC_SERVER_ADMIN_PASSWORD\n$useencryptionRaw = Get-ParamValue -ParamsObject $params -ParamName 'useencryption'\n$trustcertRaw = Get-ParamValue -ParamsObject $params -ParamName 'trustcert'\n\n# Define check category mappings for preset groups\n$checkGroups = @{\n    'security' = @(52, 53, 54, 55, 56, 70)  # Auth mode, guest user, public role, cert expiry, audit, job owners\n    'performance' = @(17, 18, 19, 20, 21, 22, 23, 24, 25, 60, 61, 62, 65, 72)  # Waits, CPU, memory, I/O, indexes, MAXDOP, cost threshold, ad hoc, IFI, fill factor\n    'availability' = @(29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 61, 62, 63)  # AG checks\n    'backup' = @(10, 11, 12, 13)  # Backup checks\n    'database' = @(6, 7, 8, 9, 47, 48, 49, 50, 51)  # Database config checks\n}\n\n# Get exclusions and inclusions parameters\n$exclusionsRaw = Get-ParamValue -ParamsObject $params -ParamName 'exclusions'\n$inclusionsRaw = Get-ParamValue -ParamsObject $params -ParamName 'inclusions'\n$exclusionReasonRaw = Get-ParamValue -ParamsObject $params -ParamName 'exclusionreason'\n$exportToPdfRaw = Get-ParamValue -ParamsObject $params -ParamName 'exporttopdf'\n\n# Validate mutual exclusivity\nif (-not [string]::IsNullOrWhiteSpace($exclusionsRaw) -and -not [string]::IsNullOrWhiteSpace($inclusionsRaw)) {\n    Send-Error -Code 10 -Description \"Cannot use both 'exclusions' and 'inclusions' parameters together. Please use only one. Exclusions: skip specific checks. Inclusions: run ONLY specific checks.\"\n    exit 1\n}\n\n# Parse exclusions (with preset groups)\n$excludedChecks = @()\nif (-not [string]::IsNullOrWhiteSpace($exclusionsRaw)) {\n    $exclusionItems = $exclusionsRaw -split ',' | ForEach-Object { $_.Trim().ToLower() }\n    \n    foreach ($item in $exclusionItems) {\n        if ($item -match '^\\d+$') {\n            # Numeric check number\n            $checkNum = [int]$item\n            if ($checkNum -gt 0 -and $checkNum -le 72) {\n                $excludedChecks += $checkNum\n            }\n        } elseif ($checkGroups.ContainsKey($item)) {\n            # Preset group\n            $excludedChecks += $checkGroups[$item]\n            Write-Host \"ℹ️  Expanding preset group '$item': checks $($checkGroups[$item] -join ', ')\"\n        } else {\n            Write-Host \"⚠️  Warning: Unknown exclusion item '$item' - ignoring. Valid: 1-72, security, performance, availability, backup, database\"\n        }\n    }\n    \n    $excludedChecks = $excludedChecks | Select-Object -Unique | Sort-Object\n    \n    if ($excludedChecks.Count -gt 0) {\n        Write-Host \"ℹ️  Excluding checks: $($excludedChecks -join ', ')\"\n        if (-not [string]::IsNullOrWhiteSpace($exclusionReasonRaw)) {\n            Write-Host \"ℹ️  Exclusion reason: $exclusionReasonRaw\"\n        }\n    }\n}\n\n# Parse inclusions (with preset groups)\n$includedChecks = @()\n$useInclusions = $false\nif (-not [string]::IsNullOrWhiteSpace($inclusionsRaw)) {\n    $useInclusions = $true\n    $inclusionItems = $inclusionsRaw -split ',' | ForEach-Object { $_.Trim().ToLower() }\n    \n    foreach ($item in $inclusionItems) {\n        if ($item -match '^\\d+$') {\n            # Numeric check number\n            $checkNum = [int]$item\n            if ($checkNum -gt 0 -and $checkNum -le 72) {\n                $includedChecks += $checkNum\n            }\n        } elseif ($checkGroups.ContainsKey($item)) {\n            # Preset group\n            $includedChecks += $checkGroups[$item]\n            Write-Host \"ℹ️  Expanding preset group '$item': checks $($checkGroups[$item] -join ', ')\"\n        } else {\n            Write-Host \"⚠️  Warning: Unknown inclusion item '$item' - ignoring. Valid: 1-72, security, performance, availability, backup, database\"\n        }\n    }\n    \n    $includedChecks = $includedChecks | Select-Object -Unique | Sort-Object\n    \n    if ($includedChecks.Count -gt 0) {\n        Write-Host \"ℹ️  Running ONLY checks: $($includedChecks -join ', ')\"\n    } else {\n        Write-Host \"⚠️  Warning: No valid checks in inclusions list - running all checks\"\n        $useInclusions = $false\n    }\n}\n\n# Validate required parameters\n$missing = @()\nif ([string]::IsNullOrWhiteSpace($server)) { $missing += 'server' }\nif ([string]::IsNullOrWhiteSpace($username)) { $missing += 'MSSQLHC_USERNAME (environment variable)' }\nif ([string]::IsNullOrWhiteSpace($password)) { $missing += 'MSSQLHC_PASSWORD (environment variable)' }\n\nif ($missing.Count -gt 0) {\n    Send-Error -Code 2 -Description \"Missing required parameters: $($missing -join ', '). Credentials must be provided via secret vault environment variables.\"\n    exit 1\n}\n\n# Detect operating system\n$runningOnWindows = if ($PSVersionTable.PSVersion.Major -ge 6) {\n    # PowerShell Core/7+ has built-in variables\n    $IsWindows\n} else {\n    # Windows PowerShell 5.1 - always Windows\n    $true\n}\n\n$osName = if ($runningOnWindows) {\n    \"Windows\"\n} elseif ($PSVersionTable.PSVersion.Major -ge 6 -and $IsLinux) {\n    \"Linux\"\n} elseif ($PSVersionTable.PSVersion.Major -ge 6 -and $IsMacOS) {\n    \"macOS\"\n} else {\n    \"Unknown\"\n}\n\nWrite-Host \"Detected OS: $osName\"\n\nif (-not $runningOnWindows) {\n    Write-Host \"⚠️  Running on non-Windows system ($osName) - Windows-specific checks (WMI, remote PowerShell) will be disabled\"\n    Write-Host \"   The following checks will use T-SQL fallback methods or be skipped:\"\n    Write-Host \"   - Lock Pages In Memory (Check 2)\"\n    Write-Host \"   - Memory Configuration with server-level access (Check 3-4)\"\n    Write-Host \"   - Instant File Initialization (Check 65)\"\n}\n\n# Check for optional server admin credentials\n$hasServerAdminCreds = -not ([string]::IsNullOrWhiteSpace($serverAdminUser)) -and -not ([string]::IsNullOrWhiteSpace($serverAdminPassword))\n$serverAdminCredential = $null\n\nif (-not $runningOnWindows -and $hasServerAdminCreds) {\n    Write-Host \"ℹ️  Server admin credentials provided but running on $osName - credentials will not be used\"\n    Write-Host \"   Windows-specific features (WMI, remote PowerShell) are not available on this platform\"\n    $hasServerAdminCreds = $false\n    $serverAdminCredential = $null\n} elseif ($hasServerAdminCreds) {\n    Write-Host \"[OK] Server admin credentials detected - enhanced checks will be available\"\n    $secureServerAdminPassword = ConvertTo-SecureString -String $serverAdminPassword -AsPlainText -Force\n    $serverAdminCredential = New-Object System.Management.Automation.PSCredential($serverAdminUser, $secureServerAdminPassword)\n} else {\n    Write-Host \"[INFO] Server admin credentials not provided - some checks will use fallback methods\"\n}\n\ntry {\n    # Check if dbatools module is installed\n    Send-Progress -Value 0.01 -Message \"Checking for dbatools module...\"\n    \n    if (-not (Get-Module -ListAvailable -Name dbatools)) {\n        try {\n            Write-Host \"dbatools module not found, attempting to install...\"\n            Install-Module -Name dbatools -Force -AllowClobber -Scope CurrentUser -ErrorAction Stop\n            Write-Host \"dbatools module installed successfully\"\n        }\n        catch {\n            Send-Error -Code 3 -Description \"Failed to install required dbatools module: $($_.Exception.Message)\"\n            exit 1\n        }\n    }\n    \n    # Import dbatools module\n    Send-Progress -Value 0.02 -Message \"Importing dbatools module...\"\n    Import-Module dbatools -ErrorAction Stop\n    \n    # Suppress dbatools informational warnings (recovery forks, AG replica access, etc.)\n    $WarningPreference = 'SilentlyContinue'\n    \n    # Build connection parameters\n    Send-Progress -Value 0.03 -Message \"Preparing connection parameters...\"\n    $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force\n    $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)\n    \n    $connectParams = @{\n        SqlCredential = $credential\n    }\n    \n    if ($useencryptionRaw -eq $true -or $useencryptionRaw -eq \"true\" -or $useencryptionRaw -eq \"True\") {\n        $connectParams['EncryptConnection'] = $true\n    }\n    if ($trustcertRaw -eq $true -or $trustcertRaw -eq \"true\" -or $trustcertRaw -eq \"True\") {\n        $connectParams['TrustServerCertificate'] = $true\n    }\n    \n    Send-Progress -Value 0.04 -Message \"Connecting to primary server: $server...\"\n    $primaryConnection = Connect-DbaInstance -SqlInstance $server @connectParams\n    \n    # Initialize comprehensive results\n    $healthCheckResults = @{\n        CheckDate = (Get-Date).ToString(\"yyyy-MM-dd HH:mm:ss\")\n        PrimaryServer = $server\n        IsAGEnvironment = $false\n        ServerAdminCredsProvided = $hasServerAdminCreds\n        RunningOS = $osName\n        IsWindowsHost = $runningOnWindows\n        ExcludedChecks = $excludedChecks\n        ExclusionReason = if (-not [string]::IsNullOrWhiteSpace($exclusionReasonRaw)) { $exclusionReasonRaw } else { \"\" }\n        ExclusionMode = if ($useInclusions) { \"Inclusions\" } elseif ($excludedChecks.Count -gt 0) { \"Exclusions\" } else { \"None\" }\n        AvailabilityGroups = @()\n        Servers = @{}\n        ExecutiveSummary = @{\n            TotalServers = 0\n            TotalChecks = 0\n            PassedChecks = 0\n            WarningChecks = 0\n            FailedChecks = 0\n            ChecksUsingServerAdmin = 0\n            ExcludedChecks = $excludedChecks.Count\n        }\n    }\n    \n    # Discover AG partners\n    $serversToCheck = @($primaryConnection)\n    $serverNames = @($primaryConnection.Name)\n    \n    Send-Progress -Value 0.05 -Message \"Detecting Availability Groups and partner replicas...\"\n    \n    if ($primaryConnection.IsHadrEnabled) {\n        $healthCheckResults.IsAGEnvironment = $true\n        Write-Host \"[OK] HADR is enabled - discovering AG topology...\"\n        \n        try {\n            $ags = Get-DbaAvailabilityGroup -SqlInstance $primaryConnection\n            \n            foreach ($ag in $ags) {\n                Write-Host \"  → Processing AG: $($ag.Name)\"\n                \n                $agDetail = @{\n                    Name = $ag.Name\n                    PrimaryReplica = $ag.PrimaryReplica\n                    LocalReplicaRole = $ag.LocalReplicaRole.ToString()\n                    AutomatedBackupPreference = $ag.AutomatedBackupPreference.ToString()\n                    Replicas = @()\n                    Databases = @()\n                    SynchronizationHealth = @()\n                }\n                \n                # Get replica details\n                $replicas = Get-DbaAgReplica -SqlInstance $primaryConnection -AvailabilityGroup $ag.Name\n                \n                foreach ($replica in $replicas) {\n                    $replicaInfo = @{\n                        Name = $replica.Name\n                        Role = $replica.Role.ToString()\n                        AvailabilityMode = $replica.AvailabilityMode.ToString()\n                        FailoverMode = $replica.FailoverMode.ToString()\n                        ConnectionState = $replica.ConnectionState.ToString()\n                    }\n                    $agDetail.Replicas += $replicaInfo\n                    \n                    # Connect to partner replicas\n                    if ($replica.Name -ne $primaryConnection.Name -and $serverNames -notcontains $replica.Name) {\n                        try {\n                            Write-Host \"    → Connecting to partner replica: $($replica.Name)...\"\n                            $partnerConn = Connect-DbaInstance -SqlInstance $replica.Name @connectParams\n                            $serversToCheck += $partnerConn\n                            $serverNames += $replica.Name\n                            Write-Host \"    [OK] Connected successfully\"\n                        }\n                        catch {\n                            Write-Host \"    ✗ Could not connect to partner: $($_.Exception.Message)\"\n                        }\n                    }\n                }\n                \n                # Get AG database information\n                $agDatabases = Get-DbaAgDatabase -SqlInstance $primaryConnection -AvailabilityGroup $ag.Name\n                foreach ($agDb in $agDatabases) {\n                    $agDetail.Databases += @{\n                        Name = $agDb.Name\n                        SynchronizationState = $agDb.SynchronizationState.ToString()\n                        IsJoined = $agDb.IsJoined\n                    }\n                }\n                \n                $healthCheckResults.AvailabilityGroups += $agDetail\n            }\n        }\n        catch {\n            Write-Host \"⚠ Warning: Could not retrieve complete AG information: $($_.Exception.Message)\"\n        }\n    }\n    \n    $healthCheckResults.ExecutiveSummary.TotalServers = $serversToCheck.Count\n    Write-Host \"`n=== Starting health checks on $($serversToCheck.Count) server(s) ===\" \n    \n    # Calculate progress increments\n    $totalServers = $serversToCheck.Count\n    $progressPerServer = 0.85 / $totalServers\n    $currentServerIndex = 0\n    \n    # Process each server\n    foreach ($conn in $serversToCheck) {\n        $currentServerIndex++\n        $serverName = $conn.Name\n        $serverProgress = 0.05 + (($currentServerIndex - 1) * $progressPerServer)\n        \n        Send-Progress -Value $serverProgress -Message \"`n[$currentServerIndex/$totalServers] Starting comprehensive health check for: $serverName\"\n        \n        $serverResults = @{\n            ServerName = $serverName\n            ServerInfo = @{}\n            Checks = @()\n        }\n        \n        # Progress tracking for checks within this server\n        $totalChecks = 72\n        $checkProgress = $progressPerServer / $totalChecks\n        $currentCheck = 0\n        \n        # Helper function to check if a check number is excluded\n        function Should-SkipCheck {\n            param([int]$CheckNumber, [string]$CheckName)\n            \n            $shouldSkip = $false\n            \n            # Check if using inclusions mode - skip if NOT in included list\n            if ($script:useInclusions -and $script:includedChecks -notcontains $CheckNumber) {\n                $shouldSkip = $true\n            }\n            # Check if using exclusions mode - skip if in excluded list\n            elseif (-not $script:useInclusions -and $script:excludedChecks -contains $CheckNumber) {\n                $shouldSkip = $true\n            }\n            \n            if ($shouldSkip) {\n                Write-Host \"[$serverName] [Skipping check $CheckNumber/$totalChecks - Excluded by user]\"\n                $script:serverResults.Checks += @{\n                    Category = \"Excluded\"\n                    CheckName = \"Check $CheckNumber - $CheckName\"\n                    Status = \"⏭️ Excluded\"\n                    Severity = \"Excluded\"\n                    Description = \"This check was excluded by user request\"\n                    CheckNumber = $CheckNumber\n                }\n                $script:currentCheck++\n                return $true\n            }\n            return $false\n        }\n        \n        # ============================================================================\n        # COLLECT SERVER INFORMATION\n        # ============================================================================\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] Collecting server information...\"\n        \n        $serverResults.ServerInfo = @{\n            ServerName = $conn.Name\n            Version = $conn.VersionString\n            VersionMajor = $conn.VersionMajor\n            Edition = $conn.Edition\n            ProductLevel = $conn.ProductLevel\n            ProductUpdateLevel = if ([string]::IsNullOrWhiteSpace($conn.ProductUpdateLevel)) { \"RTM (Not Patched)\" } else { $conn.ProductUpdateLevel }\n            BuildNumber = $conn.BuildNumber\n            IsClustered = $conn.IsClustered\n            IsHadrEnabled = $conn.IsHadrEnabled\n            Collation = $conn.Collation\n            InstanceName = $conn.InstanceName\n            PhysicalMemoryMB = $conn.PhysicalMemory\n            Processors = $conn.Processors\n        }\n        \n        # ============================================================================\n        # CHECK 1: SQL SERVER VERSION & UPDATES\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 1 -CheckName \"SQL Server Version & Updates\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [1/$totalChecks] Checking SQL Server version and patch level...\"\n        \n        # Get latest CU information for this version\n        $latestCU = Get-LatestCUInfo -VersionMajor $conn.VersionMajor -BuildNumber $conn.BuildNumber\n        \n        # Compare current build with latest\n        $isUpToDate = $conn.BuildNumber -eq $latestCU.LatestBuild\n        $needsUpdate = -not $isUpToDate\n        \n        $versionCheck = @{\n            Category = \"Server Health\"\n            CheckName = \"SQL Server Version & Updates\"\n            Status = if ($isUpToDate) { \"✅ Up to Date\" } else { \"ℹ️ Update Available\" }\n            Severity = if ($isUpToDate) { \"Pass\" } else { \"Info\" }\n            Description = \"Verifies SQL Server version and checks if latest updates are installed\"\n            Impact = \"Outdated versions may contain security vulnerabilities, bugs, and miss performance improvements. Microsoft releases cumulative updates (CUs) regularly with fixes and enhancements. Staying current ensures optimal security, stability, and performance.\"\n            CurrentValue = @{\n                Version = $conn.VersionString\n                Edition = $conn.Edition\n                ProductLevel = $conn.ProductLevel\n                PatchLevel = $serverResults.ServerInfo.ProductUpdateLevel\n                BuildNumber = $conn.BuildNumber\n                LatestAvailableCU = $latestCU.LatestCU\n                LatestAvailableBuild = $latestCU.LatestBuild\n                UpdateNeeded = $needsUpdate\n            }\n            RecommendedAction = if ($isUpToDate) { \"Server is running the latest available update ($($latestCU.LatestCU))\" } else { \"Install the latest Cumulative Update ($($latestCU.LatestCU)) for $($latestCU.VersionName). Always test updates in non-production environments first.\" }\n            RemediationSteps = @{\n                PowerShell = @\"\n# Current Version: $($conn.VersionString) (Build $($conn.BuildNumber))\n# Latest Available: $($latestCU.LatestCU) (Build $($latestCU.LatestBuild))\n\n# Download latest CU from official Microsoft site:\n# $($latestCU.DownloadLink)\n\n# Check current version\nInvoke-DbaQuery -SqlInstance '$serverName' -Query \"SELECT @@VERSION\"\n\n# After installing CU, verify new version\nTest-DbaBuild -SqlInstance '$serverName' -Latest\n\n# Verify build number after update\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    SERVERPROPERTY('ProductVersion') AS Version,\n    SERVERPROPERTY('ProductLevel') AS ProductLevel,\n    SERVERPROPERTY('ProductUpdateLevel') AS PatchLevel\n'@\n\"@\n                TSQL = @\"\n-- Check current version and build\nSELECT \n    SERVERPROPERTY('ProductVersion') AS Version,\n    SERVERPROPERTY('ProductLevel') AS ProductLevel,\n    SERVERPROPERTY('ProductUpdateLevel') AS PatchLevel,\n    SERVERPROPERTY('Edition') AS Edition,\n    @@VERSION AS FullVersion;\n\n-- Check installed updates\nSELECT * FROM sys.dm_os_windows_info;\n\"@\n                Manual = @\"\n1. Download the latest Cumulative Update:\n   - Latest CU: $($latestCU.LatestCU)\n   - Download: $($latestCU.DownloadLink)\n   - KB Article: $($latestCU.KBArticle)\n\n2. Review the KB article for:\n   - Known issues\n   - Prerequisites\n   - Installation instructions\n\n3. Test the update in a non-production environment first\n\n4. Schedule a maintenance window\n\n5. Back up all databases before applying the update\n\n6. Run the CU installer on each SQL Server instance\n\n7. Restart SQL Server service if required\n\n8. Verify the installation:\n   SELECT @@VERSION;\n\n9. Monitor for any issues post-installation\n\"@\n            }\n            Documentation = @(\n                $latestCU.DownloadLink,\n                $latestCU.KBArticle,\n                \"https://learn.microsoft.com/en-us/troubleshoot/sql/releases/download-and-install-latest-updates\",\n                \"https://learn.microsoft.com/en-us/sql/database-engine/install-windows/latest-updates-for-microsoft-sql-server\"\n            )\n            RawData = @{\n                VersionString = $conn.VersionString\n                BuildNumber = $conn.BuildNumber\n                ProductLevel = $conn.ProductLevel\n                ProductUpdateLevel = $serverResults.ServerInfo.ProductUpdateLevel\n                Edition = $conn.Edition\n                LatestCU = $latestCU.LatestCU\n                LatestBuild = $latestCU.LatestBuild\n                DownloadLink = $latestCU.DownloadLink\n                KBArticle = $latestCU.KBArticle\n            }\n        }\n        $serverResults.Checks += $versionCheck\n        }  # End Check 1\n        \n        # ============================================================================\n        # CHECK 2: LOCK PAGES IN MEMORY\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 2 -CheckName \"Lock Pages In Memory\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [2/$totalChecks] Checking Lock Pages In Memory privilege...\"\n        \n        try {\n            $lockPages = $null\n            $checkMethod = \"T-SQL\"\n            $usedServerAdmin = $false\n            \n            # Primary method: Use T-SQL (most reliable)\n            try {\n                # Get max memory and total memory\n                $memQuery = @\"\nSELECT \n    (SELECT CAST(value_in_use AS int) FROM sys.configurations WHERE name = 'max server memory (MB)') AS MaxMemoryMB,\n    (SELECT CAST(total_physical_memory_kb/1024 AS bigint) FROM sys.dm_os_sys_memory) AS TotalMB\n\"@\n                $memResult = Invoke-DbaQuery -SqlInstance $conn -Query $memQuery -ErrorAction Stop\n                \n                if (-not $memResult.TotalMB) {\n                    # Try older SQL Server version syntax (pre-2012)\n                    $memResult.TotalMB = (Invoke-DbaQuery -SqlInstance $conn -Query \"SELECT CAST(physical_memory_kb/1024 AS bigint) AS TotalMB FROM sys.dm_os_sys_info\" -ErrorAction SilentlyContinue).TotalMB\n                }\n                \n                # If still no total memory, use from ServerInfo\n                if (-not $memResult.TotalMB) {\n                    $memResult.TotalMB = $serverResults.ServerInfo.PhysicalMemoryMB\n                }\n                \n                # Try to get locked pages info (SQL 2012+ only, may not be available in all builds)\n                $lockedPagesMB = 0\n                try {\n                    $lpQuery = \"SELECT SUM(locked_page_allocations_kb) / 1024 AS LockedPagesMB FROM sys.dm_os_memory_nodes WHERE locked_page_allocations_kb > 0\"\n                    $lpResult = Invoke-DbaQuery -SqlInstance $conn -Query $lpQuery -ErrorAction Stop\n                    $lockedPagesMB = if ($lpResult.LockedPagesMB) { $lpResult.LockedPagesMB } else { 0 }\n                    $checkMethod = \"T-SQL (sys.dm_os_memory_nodes)\"\n                } catch {\n                    # locked_page_allocations_kb not available - try alternative methods\n                    try {\n                        $aweQuery = \"SELECT CAST(value_in_use AS int) AS AWEEnabled FROM sys.configurations WHERE name = 'awe enabled'\"\n                        $aweResult = Invoke-DbaQuery -SqlInstance $conn -Query $aweQuery -ErrorAction SilentlyContinue\n                        if ($aweResult.AWEEnabled -eq 1) {\n                            $lockedPagesMB = -1  # Indicator for \"possibly enabled via AWE\"\n                        }\n                        $checkMethod = \"T-SQL (legacy AWE check)\"\n                    } catch {\n                        $checkMethod = \"T-SQL (limited detection)\"\n                    }\n                }\n                \n                $lockPages = [pscustomobject]@{\n                    SqlMaxMB = $memResult.MaxMemoryMB\n                    TotalMB = $memResult.TotalMB\n                    LockedPagesMB = $lockedPagesMB\n                }\n            } catch {\n                # T-SQL method failed - this shouldn't happen\n                $lockPages = $null\n            }\n            \n            if ($lockPages -and $lockPages.TotalMB) {\n                # Check if locked pages are actually in use\n                $hasLockPages = $false\n                \n                # Convert to number and check if > 0\n                $lockedMB = 0\n                if ($lockPages.LockedPagesMB -ne $null -and $lockPages.LockedPagesMB -ne \"\") {\n                    try {\n                        $lockedMB = [int]$lockPages.LockedPagesMB\n                    } catch {\n                        $lockedMB = 0\n                    }\n                }\n                \n                if ($lockedMB -gt 0) {\n                    $hasLockPages = $true\n                } elseif ($lockedMB -eq -1) {\n                    # AWE enabled indicator\n                    $hasLockPages = $true\n                } elseif ($lockPages.SqlMaxMB -and $lockPages.SqlMaxMB -gt 0 -and $lockPages.TotalMB -and $lockPages.SqlMaxMB -lt $lockPages.TotalMB) {\n                    # Heuristic: if max memory is set and not unlimited, LPIM might be configured\n                    # This is not 100% accurate but better than nothing\n                    $hasLockPages = $true\n                }\n                \n                $lpimCheck = @{\n                Category = \"Server Health\"\n                CheckName = \"Lock Pages In Memory\"\n                Status = if ($hasLockPages) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($hasLockPages) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies that the SQL Server service account has 'Lock Pages in Memory' privilege\"\n                Impact = \"Without this privilege, Windows can page out SQL Server's buffer pool memory to disk during memory pressure, causing severe performance degradation. This is critical for production servers.\"\n                CurrentValue = @{\n                    LockPagesEnabled = $hasLockPages\n                    MaxServerMemoryMB = $lockPages.SqlMaxMB\n                    TotalServerMemoryMB = $lockPages.TotalMB\n                    LockedPagesMB = if ($lockPages.LockedPagesMB) { $lockPages.LockedPagesMB } else { \"N/A\" }\n                    CheckMethod = $checkMethod\n                    ServerAdminUsed = $usedServerAdmin\n                }\n                RecommendedAction = if ($hasLockPages) { \"Lock Pages in Memory appears to be configured\" } else { if ($hasServerAdminCreds) { \"Grant 'Lock Pages in Memory' user right to SQL Server service account and restart SQL Server service\" } else { \"Provide MSSQLHC_SERVER_ADMIN credentials for accurate checking, or manually verify Lock Pages in Memory using the T-SQL query below\" } }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Step 1: Identify SQL Server service account\n`$serviceAccount = (Get-WmiObject Win32_Service | Where-Object {`$_.Name -like 'MSSQL*' -and `$_.Name -notlike '*Agent*'}).StartName\nWrite-Host \"SQL Server Service Account: `$serviceAccount\"\n\n# Step 2: Export current security policy\nsecedit /export /cfg C:\\secpol.cfg\n\n# Step 3: Add Lock Pages privilege\n`$content = Get-Content C:\\secpol.cfg\n`$newContent = @()\nforeach (`$line in `$content) {\n    if (`$line -match 'SeLockMemoryPrivilege') {\n        if (`$line -notmatch [regex]::Escape(`$serviceAccount)) {\n            `$line = `$line.TrimEnd() + \",`$serviceAccount\"\n        }\n    }\n    `$newContent += `$line\n}\n`$newContent | Set-Content C:\\secpol.cfg\n\n# Step 4: Apply new policy\nsecedit /configure /db C:\\windows\\security\\local.sdb /cfg C:\\secpol.cfg /areas USER_RIGHTS\n\n# Step 5: Clean up\nRemove-Item C:\\secpol.cfg\n\n# Step 6: Restart SQL Server (IMPORTANT!)\nWrite-Host \"Please restart SQL Server service for changes to take effect\"\nRestart-DbaService -SqlInstance '$serverName' -Type Engine -Force\n\"@\n                    TSQL = @\"\n-- Verify Lock Pages in Memory after restart\n-- Check if buffer pool is locked in memory\nSELECT \n    osn.node_id,\n    osn.memory_node_id,\n    osn.node_state_desc,\n    om.locked_page_allocations_kb / 1024 AS LockedPagesMemoryMB\nFROM sys.dm_os_memory_nodes om\nINNER JOIN sys.dm_os_nodes osn ON om.memory_node_id = osn.memory_node_id\nWHERE osn.node_state_desc <> 'ONLINE DAC';\n\n-- If locked_page_allocations_kb > 0, Lock Pages is working\n\"@\n                    Manual = @\"\n1. Open Local Security Policy (secpol.msc)\n2. Navigate to: Local Policies → User Rights Assignment\n3. Double-click \"Lock pages in memory\"\n4. Click \"Add User or Group\"\n5. Enter the SQL Server service account name\n6. Click OK\n7. Restart SQL Server service\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows\"\n                )\n                RawData = $lockPages\n            }\n            $serverResults.Checks += $lpimCheck\n            } else {\n                # Could not determine LPIM status\n                $serverResults.Checks += @{\n                    Category = \"Server Health\"\n                    CheckName = \"Lock Pages In Memory\"\n                    Status = \"ℹ️ Manual Check Required\"\n                    Severity = \"Info\"\n                    Description = \"Could not automatically determine Lock Pages in Memory status. Manual verification required.\"\n                    Impact = \"Without this privilege, Windows can page out SQL Server's buffer pool memory to disk during memory pressure, causing severe performance degradation. This is critical for production servers.\"\n                    CurrentValue = @{\n                        LockPagesEnabled = \"Unknown\"\n                        ServerAdminCredsProvided = $hasServerAdminCreds\n                        CheckMethod = $checkMethod\n                    }\n                    RecommendedAction = if ($hasServerAdminCreds) { \"Could not determine LPIM status even with server admin credentials. Manually verify using the T-SQL query below.\" } else { \"Provide MSSQLHC_SERVER_ADMIN credentials for automatic checking, or manually verify Lock Pages in Memory using the T-SQL query below.\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check Lock Pages in Memory via T-SQL\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    SUM(locked_page_allocations_kb) / 1024 AS LockedPagesMB\nFROM sys.dm_os_memory_nodes;\n-- If LockedPagesMB > 0, Lock Pages is working\n'@\n\n# Alternative: Check Windows security policy (requires server admin access)\nsecedit /export /cfg C:\\secpol.cfg\n`$content = Get-Content C:\\secpol.cfg\n`$content | Select-String 'SeLockMemoryPrivilege'\nRemove-Item C:\\secpol.cfg\n\"@\n                        TSQL = @\"\n-- Check if Lock Pages in Memory is in use\nSELECT \n    osn.node_id,\n    osn.memory_node_id,\n    om.locked_page_allocations_kb / 1024 AS LockedPagesMemoryMB\nFROM sys.dm_os_memory_nodes om\nINNER JOIN sys.dm_os_nodes osn ON om.memory_node_id = osn.memory_node_id\nWHERE osn.node_state_desc <> 'ONLINE DAC';\n\n-- If locked_page_allocations_kb > 0, Lock Pages is working\n-- If all values are 0, Lock Pages is NOT configured\n\"@\n                        Manual = @\"\n1. Connect to SQL Server Management Studio\n2. Run the T-SQL query above to check locked_page_allocations_kb\n3. If all values are 0, Lock Pages in Memory is NOT enabled:\n   a. Open Local Security Policy (secpol.msc) on the SQL Server host\n   b. Navigate to: Local Policies → User Rights Assignment\n   c. Double-click \"Lock pages in memory\"\n   d. Click \"Add User or Group\"\n   e. Enter the SQL Server service account name\n   f. Click OK\n   g. Restart SQL Server service\n4. Re-run the query to verify locked_page_allocations_kb > 0\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows\",\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-os-memory-nodes-transact-sql\"\n                    )\n                    RawData = @{}\n                }\n            }\n        }\n        catch {\n            Write-Host \"[Check 2 Error] $($_.Exception.Message)\"\n            Write-Host \"[Check 2 Stack] $($_.ScriptStackTrace)\"\n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Lock Pages In Memory\"\n                Status = \"❌ Error\"\n                Severity = \"Error\"\n                Description = \"Unexpected error while checking Lock Pages in Memory: $($_.Exception.Message)\"\n                Impact = \"Without this privilege, Windows can page out SQL Server's buffer pool memory to disk during memory pressure, causing severe performance degradation.\"\n                CurrentValue = @{\n                    Error = $_.Exception.Message\n                    CheckMethod = if ($checkMethod) { $checkMethod } else { \"Unknown\" }\n                    ServerAdminCredsProvided = $hasServerAdminCreds\n                }\n                RecommendedAction = \"Review the error message and manually verify Lock Pages in Memory using the T-SQL query in the Remediation Steps.\"\n                RemediationSteps = @{\n                    TSQL = @\"\n-- Check if Lock Pages in Memory is in use\nSELECT \n    CAST(value_in_use AS int) AS MaxMemoryMB\nFROM sys.configurations \nWHERE name = 'max server memory (MB)';\n\n-- Try to check locked pages (SQL 2012+ only)\n-- If this fails, locked_page_allocations_kb column doesn't exist in your version\nSELECT \n    osn.node_id,\n    osn.memory_node_id,\n    om.locked_page_allocations_kb / 1024 AS LockedPagesMemoryMB\nFROM sys.dm_os_memory_nodes om\nINNER JOIN sys.dm_os_nodes osn ON om.memory_node_id = osn.memory_node_id\nWHERE osn.node_state_desc <> 'ONLINE DAC';\n\"@\n                    Manual = @\"\n1. The automated check encountered an error\n2. Manually verify Lock Pages in Memory:\n   a. Connect to SQL Server Management Studio\n   b. Run the T-SQL query above\n   c. If locked_page_allocations_kb > 0, LPIM is enabled\n   d. If the query fails or returns 0, LPIM may not be enabled\n3. To enable LPIM:\n   a. Open Local Security Policy (secpol.msc) on SQL Server host\n   b. Navigate to: Local Policies → User Rights Assignment\n   c. Double-click \"Lock pages in memory\"\n   d. Add the SQL Server service account\n   e. Restart SQL Server service\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows\"\n                )\n                Error = $_.Exception.Message\n                RawData = @{}\n            }\n        }\n        }  # End Check 2\n        \n        # ============================================================================\n        # CHECK 3: INSTANT FILE INITIALIZATION\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 3 -CheckName \"Instant File Initialization\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [3/$totalChecks] Checking Instant File Initialization...\"\n        \n        try {\n            $ifiEnabled = $null\n            $checkMethod = \"Unknown\"\n            $errorDetails = \"\"\n            $usedServerAdmin = $false\n            \n            # Try primary method with server admin credentials if available\n            try {\n                if ($hasServerAdminCreds) {\n                    # Try with server admin credentials for better access\n                    $ifi = Test-DbaInstanceFileInitialization -SqlInstance $conn -Credential $serverAdminCredential\n                    $ifiEnabled = $ifi.IfiEnabled\n                    $checkMethod = \"dbatools with Server Admin credentials\"\n                    $usedServerAdmin = $true\n                    $healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin++\n                } else {\n                    # Try without server admin credentials\n                    $ifi = Test-DbaInstanceFileInitialization -SqlInstance $conn\n                    $ifiEnabled = $ifi.IfiEnabled\n                    $checkMethod = \"dbatools (SQL credentials only)\"\n                }\n            }\n            catch {\n                $errorDetails = $_.Exception.Message\n                \n                # Fallback: Check via T-SQL for SQL Server 2016+\n                if ($conn.VersionMajor -ge 13) {\n                    try {\n                        $ifiQuery = \"SELECT CASE WHEN EXISTS (SELECT * FROM sys.dm_server_services WHERE instant_file_initialization_enabled = 'Y') THEN 1 ELSE 0 END AS IFIEnabled\"\n                        $ifiResult = Invoke-DbaQuery -SqlInstance $conn -Query $ifiQuery\n                        $ifiEnabled = $ifiResult.IFIEnabled -eq 1\n                        $checkMethod = \"T-SQL (sys.dm_server_services)\"\n                    }\n                    catch {\n                        # Cannot determine - mark as unknown\n                        $ifiEnabled = $null\n                        $errorDetails += \"; Fallback also failed: \" + $_.Exception.Message\n                    }\n                } else {\n                    # SQL Server 2014 and older - cannot check programmatically\n                    $ifiEnabled = $null\n                    $errorDetails += \"; SQL Server version too old for programmatic check (requires 2016+)\"\n                }\n            }\n            \n            if ($null -ne $ifiEnabled) {\n                $ifiCheck = @{\n                    Category = \"Server Health\"\n                    CheckName = \"Instant File Initialization (IFI)\"\n                    Status = if ($ifiEnabled) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                    Severity = if ($ifiEnabled) { \"Pass\" } else { \"Warning\" }\n                    Description = \"Checks if Instant File Initialization is enabled for faster data file operations\"\n                    Impact = \"Without IFI, data file growth operations must zero-write all new space, which can take significant time for large files. This causes blocking, timeouts, and performance issues during autogrowth events. IFI allows near-instant file growth for data files (not log files).\"\n                    CurrentValue = @{\n                        IFIEnabled = $ifiEnabled\n                        CheckMethod = $checkMethod\n                    }\n                    RecommendedAction = if ($ifiEnabled) { \"Instant File Initialization is enabled\" } else { \"Grant 'Perform Volume Maintenance Tasks' privilege to SQL Server service account and restart SQL Server\" }\n                    RemediationSteps = @{\n                    PowerShell = @\"\n# Step 1: Identify SQL Server service account\n`$serviceAccount = (Get-WmiObject Win32_Service | Where-Object {`$_.Name -like 'MSSQL*' -and `$_.Name -notlike '*Agent*'}).StartName\nWrite-Host \"SQL Server Service Account: `$serviceAccount\"\n\n# Step 2: Export current security policy\nsecedit /export /cfg C:\\secpol.cfg\n\n# Step 3: Add Perform Volume Maintenance Tasks privilege\n`$content = Get-Content C:\\secpol.cfg\n`$newContent = @()\nforeach (`$line in `$content) {\n    if (`$line -match 'SeManageVolumePrivilege') {\n        if (`$line -notmatch [regex]::Escape(`$serviceAccount)) {\n            `$line = `$line.TrimEnd() + \",`$serviceAccount\"\n        }\n    }\n    `$newContent += `$line\n}\n`$newContent | Set-Content C:\\secpol.cfg\n\n# Step 4: Apply new policy\nsecedit /configure /db C:\\windows\\security\\local.sdb /cfg C:\\secpol.cfg /areas USER_RIGHTS\n\n# Step 5: Clean up\nRemove-Item C:\\secpol.cfg\n\n# Step 6: Restart SQL Server\nRestart-DbaService -SqlInstance '$serverName' -Type Engine -Force\n\n# Step 7: Verify IFI is enabled\nTest-DbaInstanceFileInitialization -SqlInstance '$serverName'\n\"@\n                    TSQL = @\"\n-- Enable trace flag 3004 to log file initialization info\nDBCC TRACEON(3004, -1);\n\n-- Create a test database to verify IFI\n-- Check SQL Server error log for messages\n-- With IFI: You'll see instant initialization\n-- Without IFI: You'll see \"Zeroing\" messages\n\n-- View error log\nEXEC sp_readerrorlog;\n\"@\n                    Manual = @\"\n1. Open Local Security Policy (secpol.msc)\n2. Navigate to: Local Policies → User Rights Assignment\n3. Double-click \"Perform volume maintenance tasks\"\n4. Click \"Add User or Group\"\n5. Enter the SQL Server service account\n6. Click OK\n7. Restart SQL Server service\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-instant-file-initialization\"\n                )\n                RawData = @{\n                    IFIEnabled = $ifiEnabled\n                    CheckMethod = $checkMethod\n                }\n            }\n            $serverResults.Checks += $ifiCheck\n            } else {\n                # Could not determine IFI status - provide manual check instructions\n                $serverResults.Checks += @{\n                    Category = \"Server Health\"\n                    CheckName = \"Instant File Initialization (IFI)\"\n                    Status = \"ℹ️ Manual Check Required\"\n                    Severity = \"Info\"\n                    Description = \"Could not automatically determine IFI status. Manual verification required.\"\n                    Impact = \"Without IFI, data file growth operations must zero-write all new space, which can take significant time for large files. This causes blocking, timeouts, and performance issues during autogrowth events. IFI allows near-instant file growth for data files (not log files).\"\n                    CurrentValue = @{\n                        IFIEnabled = \"Unknown\"\n                        Reason = $errorDetails\n                        SQLServerVersion = \"$($conn.VersionMajor).$($conn.VersionMinor)\"\n                        ServerAdminCredsProvided = $hasServerAdminCreds\n                    }\n                    RecommendedAction = if ($hasServerAdminCreds) { \"Could not determine IFI status even with server admin credentials. Manually verify using the methods below.\" } else { \"Provide MSSQLHC_SERVER_ADMIN_USER and MSSQLHC_SERVER_ADMIN_PASSWORD credentials for automatic checking, or manually verify IFI status using the T-SQL or PowerShell methods provided below.\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# For SQL Server 2016 and later, check via T-SQL:\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT servicename, instant_file_initialization_enabled\nFROM sys.dm_server_services \nWHERE servicename LIKE 'SQL Server%';\n'@\n\n# Alternative: Check Windows privilege directly (requires admin access to SQL Server host)\n# Step 1: Identify SQL Server service account\n`$serviceAccount = (Get-WmiObject Win32_Service | Where-Object {`$_.Name -like 'MSSQL*' -and `$_.Name -notlike '*Agent*'}).StartName\nWrite-Host \"SQL Server Service Account: `$serviceAccount\"\n\n# Step 2: To enable IFI, grant 'Perform Volume Maintenance Tasks' privilege:\nsecedit /export /cfg C:\\secpol.cfg\n`$content = Get-Content C:\\secpol.cfg\n# Look for SeManageVolumePrivilege and verify service account is listed\n`$content | Select-String 'SeManageVolumePrivilege'\n\"@\n                        TSQL = @\"\n-- For SQL Server 2016+ (Version 13.0+)\n-- Check IFI status\nSELECT \n    servicename,\n    instant_file_initialization_enabled,\n    CASE instant_file_initialization_enabled\n        WHEN 'Y' THEN 'IFI is ENABLED - Good!'\n        WHEN 'N' THEN 'IFI is DISABLED - Consider enabling'\n        ELSE 'Unknown status'\n    END AS Status\nFROM sys.dm_server_services \nWHERE servicename LIKE 'SQL Server%';\n\n-- For SQL Server 2014 and older:\n-- Enable trace flag 3004 and check error log\nDBCC TRACEON(3004, -1);\n-- Create a small test database and check the error log for initialization messages\n-- Look for 'Zeroing' (IFI disabled) vs 'Instant' (IFI enabled) messages\nEXEC sp_readerrorlog;\n\"@\n                        Manual = @\"\n1. For SQL Server 2016+:\n   - Run the T-SQL query above to check instant_file_initialization_enabled column\n   \n2. For SQL Server 2014 and older:\n   - Enable trace flag 3004: DBCC TRACEON(3004, -1)\n   - Create a test database\n   - Check SQL Server error log for file initialization messages\n   - With IFI: You'll see \"instant\" initialization\n   - Without IFI: You'll see \"Zeroing\" messages\n\n3. To enable IFI (all versions):\n   - Open Local Security Policy (secpol.msc) on SQL Server host\n   - Navigate to: Local Policies → User Rights Assignment\n   - Double-click \"Perform volume maintenance tasks\"\n   - Add the SQL Server service account\n   - Restart SQL Server service\n\n4. Verify after enabling:\n   - For 2016+: Re-run the sys.dm_server_services query\n   - For older: Check error log after creating a test database\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-instant-file-initialization\",\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-server-services-transact-sql\"\n                    )\n                    RawData = @{\n                        ErrorDetails = $errorDetails\n                        VersionMajor = $conn.VersionMajor\n                        CheckMethod = $checkMethod\n                    }\n                }\n            }\n        }\n        catch {\n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Instant File Initialization\"\n                Status = \"❌ Error\"\n                Severity = \"Error\"\n                Description = \"Could not check Instant File Initialization\"\n                Error = $_.Exception.Message\n            }\n        }\n        }  # End Check 3\n        \n        # ============================================================================\n        # CHECK 4: MEMORY CONFIGURATION\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 4 -CheckName \"Memory Configuration\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [4/$totalChecks] Checking memory configuration...\"\n        \n        try {\n            $memory = $null\n            $method = \"dbatools:Get-DbaMaxMemory\"\n            $usedServerAdmin = $false\n\n            try {\n                if ($hasServerAdminCreds) {\n                    # Try with server admin credentials for complete memory information\n                    $memory = Get-DbaMaxMemory -SqlInstance $conn -Credential $serverAdminCredential -EnableException\n                    $method = \"dbatools with Server Admin credentials\"\n                    $usedServerAdmin = $true\n                    $healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin++\n                } else {\n                    $memory = Get-DbaMaxMemory -SqlInstance $conn -EnableException\n                }\n            } catch {\n                $method = \"T-SQL Fallback\"\n                # Fallback via T-SQL; requires VIEW SERVER STATE\n                try {\n                    $tsql = @\"\nSELECT \n    (SELECT CAST(value_in_use AS int) FROM sys.configurations WHERE name = 'min server memory (MB)') AS MinMB,\n    (SELECT CAST(value_in_use AS int) FROM sys.configurations WHERE name = 'max server memory (MB)') AS MaxMB,\n    (SELECT CAST(total_physical_memory_kb/1024 AS bigint) FROM sys.dm_os_sys_memory) AS TotalMB\n\"@\n                    $row = Invoke-DbaQuery -SqlInstance $conn -Query $tsql | Select-Object -First 1\n                    if (-not $row.TotalMB) {\n                        # Older versions: sys.dm_os_sys_info\n                        $row.TotalMB = (Invoke-DbaQuery -SqlInstance $conn -Query \"SELECT CAST(physical_memory_kb/1024 AS bigint) AS TotalMB FROM sys.dm_os_sys_info\").TotalMB | Select-Object -First 1\n                    }\n                    $memory = [pscustomobject]@{\n                        SqlMinMB = [int]$row.MinMB\n                        SqlMaxMB = [int]$row.MaxMB\n                        TotalMB  = [int64]$row.TotalMB\n                    }\n                } catch {\n                    # Final fallback to ServerInfo if present\n                    $memory = [pscustomobject]@{\n                        SqlMinMB = $null\n                        SqlMaxMB = $null\n                        TotalMB  = [int64]$serverResults.ServerInfo.PhysicalMemoryMB\n                    }\n                }\n            }\n\n            $totalMB = [int64]$memory.TotalMB\n            $recommended = if ($totalMB -gt 0) { [math]::Round($totalMB * 0.75) } else { 0 }\n            $isConfigured = ($memory.SqlMaxMB -gt 0 -and $totalMB -gt 0 -and $memory.SqlMaxMB -lt $totalMB -and $memory.SqlMaxMB -ge $recommended * 0.9)\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Memory Configuration\"\n                Status = if ($recommended -gt 0) { if ($isConfigured) { \"✅ Pass\" } else { \"⚠️ Warning\" } } else { \"ℹ️ Info\" }\n                Severity = if ($recommended -gt 0) { if ($isConfigured) { \"Pass\" } else { \"Warning\" } } else { \"Info\" }\n                Description = \"Validates SQL Server min/max memory settings against best practices\"\n                Impact = \"Incorrect memory settings can cause OS instability (if max too high) or SQL Server memory starvation (if max too low). Min memory should be at least 25% of max to prevent excessive memory deallocations.\"\n                CurrentValue = @{\n                    MinMemoryMB = $memory.SqlMinMB\n                    MaxMemoryMB = $memory.SqlMaxMB\n                    TotalServerMemoryMB = if ($totalMB -gt 0) { $totalMB } else { $null }\n                    RecommendedMaxMB = $recommended\n                    RecommendedMinMB = if ($recommended -gt 0) { [math]::Round($recommended * 0.25) } else { 0 }\n                    CheckMethod = $method\n                }\n                RecommendedAction = if ($recommended -gt 0) { if ($isConfigured) { \"Memory is properly configured\" } else { \"Set max server memory to ~75% of total RAM ($recommended MB) and min to ~25% of max\" } } else { \"Grant VIEW SERVER STATE and ensure Windows remoting/WMI access so total memory can be retrieved.\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Set recommended memory settings\nSet-DbaMaxMemory -SqlInstance '$serverName' -Max $recommended\n\n# Verify settings\nGet-DbaMaxMemory -SqlInstance '$serverName'\n\"@\n                    TSQL = @\"\n-- Set max server memory (MB)\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nEXEC sp_configure 'max server memory (MB)', $recommended;\nRECONFIGURE;\n\n-- Verify\nEXEC sp_configure 'max server memory';\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/server-memory-server-configuration-options\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-os-sys-memory-transact-sql\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-configurations-transact-sql\"\n                )\n                RawData = $memory\n            }\n        } catch {\n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Memory Configuration\"\n                Status = \"❌ Error\"\n                Severity = \"Error\"\n                Description = \"Could not check memory configuration\"\n                Error = $_.Exception.Message\n            }\n        }\n        }  # End Check 4\n        \n        # ============================================================================\n        # CHECK 5: LAST BACKUP\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 5 -CheckName \"Last Backup\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [5/$totalChecks] Checking backup status...\"\n        \n        try {\n            $lastBackup = Get-DbaLastBackup -SqlInstance $serverName -SqlCredential $credential -ExcludeDatabase master,model,msdb,tempdb\n            \n            # Filter for databases with backups older than 24 hours\n            $cutoffDate = (Get-Date).AddDays(-1)\n            $oldBackups = @()\n            foreach ($db in $lastBackup) {\n                if (-not $db.LastFullBackup) {\n                    $oldBackups += $db\n                } else {\n                    $backupDate = [datetime]$db.LastFullBackup\n                    if ($backupDate -lt $cutoffDate) {\n                        $oldBackups += $db\n                    }\n                }\n            }\n            \n            # Convert to simple objects for table display\n            $backupTable = @()\n            foreach ($db in $lastBackup) {\n                $backupTable += [PSCustomObject]@{\n                    Database = $db.Database\n                    LastFullBackup = if ($db.LastFullBackup) { $db.LastFullBackup.ToString(\"yyyy-MM-dd HH:mm\") } else { \"Never\" }\n                    LastDiffBackup = if ($db.LastDiffBackup) { $db.LastDiffBackup.ToString(\"yyyy-MM-dd HH:mm\") } else { \"None\" }\n                    LastLogBackup = if ($db.LastLogBackup) { $db.LastLogBackup.ToString(\"yyyy-MM-dd HH:mm\") } else { \"None\" }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Last Backup\"\n                Status = if ($oldBackups.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($oldBackups.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies all user databases have been backed up within the last 24 hours\"\n                Impact = \"Databases without recent backups risk significant data loss in case of hardware failure, corruption, or accidental deletion. RPO will be severely impacted.\"\n                CurrentValue = @{\n                    DatabasesWithOldBackups = $oldBackups.Count\n                    TotalUserDatabases = @($lastBackup).Count\n                }\n                RecommendedAction = if ($oldBackups.Count -eq 0) { \"All databases backed up regularly\" } else { \"Schedule daily full backups for databases without recent backups\" }\n                RemediationSteps = @{\n                    PowerShell = \"Get-DbaDatabase -SqlInstance '$serverName' -SqlCredential `$credential -ExcludeSystem | Backup-DbaDatabase -Type Full -CompressBackup\"\n                    TSQL = \"BACKUP DATABASE [DatabaseName] TO DISK = N'C:\\\\Backup\\\\DatabaseName_Full.bak' WITH COMPRESSION;\"\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases\"\n                )\n                RawData = $backupTable\n            }\n        } catch {\n            $serverResults.Checks += @{ \n                Category = \"Server Health\"\n                CheckName = \"Last Backup\"\n                Status = \"❌ Error\"\n                Severity = \"Error\"\n                Description = \"Could not check backups\"\n                Error = $_.Exception.Message\n            }\n        }\n        }  # End Check 5\n        \n        # ============================================================================\n        # CHECK 6: DATABASE PERCENT GROWTH\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 6 -CheckName \"Database Percent Growth\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [6/$totalChecks] Checking database growth settings...\"\n        \n        try {\n            $dbFiles = Get-DbaDbFile -SqlInstance $conn -ExcludeDatabase master,model,msdb,tempdb\n            $percentGrowth = $dbFiles | Where-Object { $_.Growth -gt 0 -and $_.Growth -lt 100 }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Database Percent Growth\"\n                Status = if ($percentGrowth.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($percentGrowth.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies database files using percentage-based autogrowth instead of fixed size\"\n                Impact = \"Percentage growth causes exponentially larger autogrowth events as files grow, leading to performance issues and file fragmentation. Fixed growth (e.g., 512MB) is more predictable and performs better.\"\n                CurrentValue = @{\n                    FilesWithPercentGrowth = $percentGrowth.Count\n                    TotalFiles = $dbFiles.Count\n                }\n                RecommendedAction = if ($percentGrowth.Count -eq 0) { \"All files use fixed growth\" } else { \"Change to fixed growth: 512MB for data files, 256MB for log files\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Change all percent growth to fixed size (512MB for data, 256MB for logs)\nGet-DbaDbFile -SqlInstance '$serverName' | Where-Object { `$_.Growth -lt 100 } | ForEach-Object {\n    `$growthMB = if (`$_.TypeDescription -eq 'LOG') { 256 } else { 512 }\n    Set-DbaDbFileGrowth -SqlInstance '$serverName' -Database `$_.Database -FileGroup `$_.FileGroupName -GrowthType MB -Growth `$growthMB\n}\n\"@\n                    TSQL = @\"\n-- Change data files to 512MB fixed growth\nALTER DATABASE [DatabaseName] \nMODIFY FILE (NAME = N'DataFileName', FILEGROWTH = 512MB);\n\n-- Change log files to 256MB fixed growth\nALTER DATABASE [DatabaseName] \nMODIFY FILE (NAME = N'LogFileName', FILEGROWTH = 256MB);\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options\"\n                )\n                RawData = $percentGrowth | Select-Object Database, LogicalName, Growth, Type\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Database Percent Growth\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check growth settings\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 6\n        \n        # ============================================================================\n        # CHECK 7: RECOVERY MODEL\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 7 -CheckName \"Recovery Model\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [7/$totalChecks] Checking recovery models...\"\n        \n        try {\n            $recoveryModel = Get-DbaDbRecoveryModel -SqlInstance $serverName -SqlCredential $credential -ExcludeDatabase master,model,msdb,tempdb\n            \n            # Filter for production databases in SIMPLE mode\n            $simpleInProd = @()\n            foreach ($db in $recoveryModel) {\n                if ($db.RecoveryModel -eq 'Simple' -and $db.Name -notlike '*test*' -and $db.Name -notlike '*dev*') {\n                    $simpleInProd += $db\n                }\n            }\n            \n            # Convert ALL databases to simple objects for table display\n            $recoveryTable = @()\n            foreach ($db in $recoveryModel) {\n                $recoveryTable += [PSCustomObject]@{\n                    Database = $db.Name\n                    RecoveryModel = $db.RecoveryModel\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Recovery Model\"\n                Status = if ($simpleInProd.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($simpleInProd.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Validates recovery model settings are appropriate for production vs non-production databases\"\n                Impact = \"SIMPLE recovery prevents point-in-time recovery and transaction log backups. Production databases should use FULL recovery for maximum data protection. Non-production can use SIMPLE to avoid log file growth.\"\n                CurrentValue = @{\n                    SimpleModeInProduction = $simpleInProd.Count\n                    TotalUserDatabases = @($recoveryModel).Count\n                }\n                RecommendedAction = if ($simpleInProd.Count -eq 0) { \"Recovery models are appropriate\" } else { \"Change production databases to FULL recovery and take a full backup\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Change to FULL recovery for production databases\nGet-DbaDatabase -SqlInstance '$serverName' -SqlCredential `$credential -ExcludeSystem | \n    Where-Object { `$_.RecoveryModel -eq 'Simple' -and `$_.Name -notlike '*test*' } |\n    Set-DbaDbRecoveryModel -RecoveryModel Full\n\n# Take full backup after changing to FULL\nGet-DbaDatabase -SqlInstance '$serverName' -SqlCredential `$credential -ExcludeSystem | \n    Where-Object { `$_.RecoveryModel -eq 'Full' } |\n    Backup-DbaDatabase -Type Full\n\"@\n                    TSQL = @\"\n-- Change to FULL recovery\nALTER DATABASE [DatabaseName] SET RECOVERY FULL;\n\n-- IMPORTANT: Take full backup to enable log backups\nBACKUP DATABASE [DatabaseName] TO DISK = 'C:\\\\Backup\\\\DatabaseName_Full.bak' WITH COMPRESSION;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/backup-restore/recovery-models-sql-server\"\n                )\n                RawData = $recoveryTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Recovery Model\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check recovery models\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 7\n        \n        # ============================================================================\n        # CHECK 8: VIRTUAL LOG FILES (VLF)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 8 -CheckName \"Virtual Log Files\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [8/$totalChecks] Analyzing virtual log files...\"\n        \n        try {\n            $vlfs = Measure-DbaDbVirtualLogFile -SqlInstance $conn\n            $highVlf = $vlfs | Where-Object { $_.Total -gt 500 }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Virtual Log Files (VLF)\"\n                Status = if ($highVlf.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($highVlf.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Detects databases with excessive VLF counts which impact performance\"\n                Impact = \"High VLF counts (>500) slow down database recovery, log backups, transaction log operations, and can cause performance degradation. Caused by small autogrowth increments or percent-based growth.\"\n                CurrentValue = @{\n                    DatabasesWithHighVLF = $highVlf.Count\n                    HighestVLFCount = if ($highVlf) { ($highVlf | Measure-Object -Property Total -Maximum).Maximum } else { 0 }\n                }\n                RecommendedAction = if ($highVlf.Count -eq 0) { \"VLF counts are healthy\" } else { \"Shrink and regrow transaction logs during maintenance window (REQUIRES DOWNTIME)\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# WARNING: This requires a maintenance window and can take significant time\n# Backup logs first if in FULL recovery\nGet-DbaDatabase -SqlInstance '$serverName' | Where-Object { `$_.RecoveryModel -eq 'Full' } | \n    Backup-DbaDatabase -Type Log\n\n# Shrink log files (one at a time, during maintenance window)\n`$db = Get-DbaDatabase -SqlInstance '$serverName' -Database 'DatabaseName'\n`$logFile = `$db.LogFiles[0].Name\nInvoke-DbaQuery -SqlInstance '$serverName' -Database `$db.Name -Query \"DBCC SHRINKFILE(`$logFile, 1)\"\n\n# Regrow to appropriate size with proper VLFs\nInvoke-DbaQuery -SqlInstance '$serverName' -Database `$db.Name -Query \"ALTER DATABASE [`$(`$db.Name)] MODIFY FILE (NAME = N'`$logFile', SIZE = 4096MB, FILEGROWTH = 512MB)\"\n\"@\n                    TSQL = @\"\n-- Step 1: Backup log if in FULL recovery\nBACKUP LOG [DatabaseName] TO DISK = 'C:\\\\Backup\\\\DatabaseName_Log.trn';\n\n-- Step 2: Shrink log file\nUSE [DatabaseName];\nDBCC SHRINKFILE(N'DatabaseName_log', 1);\n\n-- Step 3: Regrow to proper size (creates optimal VLF structure)\nALTER DATABASE [DatabaseName] \nMODIFY FILE (NAME = N'DatabaseName_log', SIZE = 4096MB, FILEGROWTH = 512MB);\n\n-- Verify VLF count\nDBCC LOGINFO;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/manage-the-size-of-the-transaction-log-file\"\n                )\n                RawData = $highVlf | Select-Object Database, Total, Active, Status\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Virtual Log Files\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check VLF counts\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 8\n        \n        # ============================================================================\n        # CHECK 9: TEMPDB CONFIGURATION\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 9 -CheckName \"TempDB Configuration\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [9/$totalChecks] Checking TempDB configuration...\"\n        \n        try {\n            $tempdb = Test-DbaTempDbConfig -SqlInstance $conn\n            \n            # Filter for issues\n            $issues = @()\n            foreach ($check in $tempdb) {\n                if ($check.IsBestPractice -eq $false) {\n                    $issues += $check\n                }\n            }\n            \n            # Convert ALL checks to simple objects for table display\n            $tempdbTable = @()\n            foreach ($check in $tempdb) {\n                $tempdbTable += [PSCustomObject]@{\n                    Rule = $check.Rule\n                    Recommended = $check.Recommended\n                    CurrentSetting = $check.CurrentSetting\n                    IsBestPractice = $check.IsBestPractice\n                }\n            }\n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"TempDB Configuration\"\n                Status = if ($issues.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($issues.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Validates TempDB follows best practices (file count, size, growth)\"\n                Impact = \"Improper TempDB configuration causes contention, allocation issues, and poor performance. Should have one data file per CPU core (max 8), all files same size, and proper growth settings.\"\n                CurrentValue = @{\n                    ConfigurationIssues = $issues.Count\n                    TotalChecks = @($tempdb).Count\n                }\n                RecommendedAction = if ($issues.Count -eq 0) { \"TempDB is properly configured\" } else { \"Add data files (1 per CPU, max 8) and ensure all files are same size\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get CPU count\n`$cores = (Get-WmiObject Win32_Processor).NumberOfLogicalProcessors\n`$fileCount = [Math]::Min(`$cores, 8)\n\n# Add TempDB files if needed\n1..`$fileCount | ForEach-Object {\n    `$fileName = \"tempdev`$_\"\n    `$query = \"IF NOT EXISTS (SELECT 1 FROM sys.master_files WHERE database_id = 2 AND name = '`$fileName') BEGIN ALTER DATABASE tempdb ADD FILE (NAME = N'`$fileName', FILENAME = N'C:\\\\SQLData\\\\`$fileName.ndf', SIZE = 8GB, FILEGROWTH = 512MB); END\"\n    Invoke-DbaQuery -SqlInstance '$serverName' -Database master -Query `$query\n}\n\"@\n                    TSQL = @\"\n-- Add TempDB data files (one per CPU core, max 8)\n-- All files should be same size\nALTER DATABASE tempdb ADD FILE (\n    NAME = N'tempdev2',\n    FILENAME = N'C:\\\\SQLData\\\\tempdev2.ndf',\n    SIZE = 8GB,\n    FILEGROWTH = 512MB\n);\n\n-- Repeat for tempdev3, tempdev4, etc.\n-- Set all files to same size\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/tempdb-database\"\n                )\n                RawData = $tempdbTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"TempDB Configuration\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check TempDB\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 9\n        \n        # ============================================================================\n        # CHECK 10: INTEGRITY CHECK (DBCC CHECKDB)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 10 -CheckName \"Integrity Check\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [10/$totalChecks] Checking database integrity history...\"\n        \n        try {\n            $lastGoodCheckDb = Get-DbaLastGoodCheckDb -SqlInstance $conn\n            $oldChecks = $lastGoodCheckDb | Where-Object { $_.LastGoodCheckDb -lt (Get-Date).AddDays(-30) -and $_.Database -notin @('tempdb') }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Integrity Check (DBCC CHECKDB)\"\n                Status = if ($oldChecks.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($oldChecks.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies databases have had integrity checks (DBCC CHECKDB) within the last 30 days\"\n                Impact = \"Undetected corruption can lead to data loss, database unavailability, and restore failures. Regular integrity checks (weekly minimum) are critical for early corruption detection.\"\n                CurrentValue = @{\n                    DatabasesNeedingCheck = $oldChecks.Count\n                    OldestCheck = if ($oldChecks) { ($oldChecks | Sort-Object LastGoodCheckDb | Select-Object -First 1).LastGoodCheckDb } else { \"N/A\" }\n                }\n                RecommendedAction = if ($oldChecks.Count -eq 0) { \"All databases checked recently\" } else { \"Run DBCC CHECKDB on all databases during maintenance window (HIGH I/O IMPACT)\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Run integrity check on all user databases\n# WARNING: This is I/O intensive - schedule during maintenance window\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem | \n    ForEach-Object {\n        Write-Host \"Checking: `$(`$_.Name)\"\n        Invoke-DbaDbccCheckDb -SqlInstance '$serverName' -Database `$_.Name\n    }\n\"@\n                    TSQL = @\"\n-- Run DBCC CHECKDB on all user databases\n-- Schedule during maintenance window due to I/O impact\nDECLARE @db VARCHAR(100)\nDECLARE db_cursor CURSOR FOR\nSELECT name FROM sys.databases\nWHERE name NOT IN ('master','model','msdb','tempdb')\nAND state_desc = 'ONLINE'\n\nOPEN db_cursor\nFETCH NEXT FROM db_cursor INTO @db\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    PRINT 'Checking: ' + @db\n    EXEC('DBCC CHECKDB([' + @db + ']) WITH NO_INFOMSGS')\n    FETCH NEXT FROM db_cursor INTO @db\nEND\n\nCLOSE db_cursor\nDEALLOCATE db_cursor\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-checkdb-transact-sql\"\n                )\n                RawData = $oldChecks | Select-Object Database, LastGoodCheckDb, DaysSinceLastGoodCheckDb, Status\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Integrity Check\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check integrity history\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 10\n        \n        # ============================================================================\n        # CHECK 11: INDEX FRAGMENTATION\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 11 -CheckName \"Index Fragmentation\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [11/$totalChecks] Checking index fragmentation...\"\n        \n        try {\n            # Query to check index fragmentation across all user databases\n            $query = @\"\nCREATE TABLE #TempResults (\n    DatabaseName NVARCHAR(128),\n    SchemaName NVARCHAR(128),\n    TableName NVARCHAR(128),\n    IndexName NVARCHAR(128),\n    FragmentationPercent DECIMAL(5,2),\n    PageCount BIGINT\n)\n\nDECLARE @SQL NVARCHAR(MAX)\nDECLARE @DbName NVARCHAR(128)\n\nDECLARE db_cursor CURSOR FOR\nSELECT name FROM sys.databases\nWHERE name NOT IN ('master','model','msdb','tempdb')\nAND state_desc = 'ONLINE'\n\nOPEN db_cursor\nFETCH NEXT FROM db_cursor INTO @DbName\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    SET @SQL = '\n    USE [' + @DbName + ']\n    INSERT INTO #TempResults\n    SELECT \n        ''' + @DbName + ''' as DatabaseName,\n        dbschemas.[name] as SchemaName,\n        dbtables.[name] as TableName,\n        dbindexes.[name] as IndexName,\n        CAST(indexstats.avg_fragmentation_in_percent AS DECIMAL(5,2)) as FragmentationPercent,\n        indexstats.page_count as PageCount\n    FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL, NULL, NULL) AS indexstats\n    INNER JOIN sys.tables dbtables on dbtables.[object_id] = indexstats.[object_id]\n    INNER JOIN sys.schemas dbschemas on dbtables.[schema_id] = dbschemas.[schema_id]\n    INNER JOIN sys.indexes AS dbindexes ON dbindexes.[object_id] = indexstats.[object_id]\n        AND indexstats.index_id = dbindexes.index_id\n    WHERE indexstats.database_id = DB_ID()\n        AND indexstats.page_count > 1000\n        AND dbindexes.[name] IS NOT NULL'\n    \n    EXEC sp_executesql @SQL\n    FETCH NEXT FROM db_cursor INTO @DbName\nEND\n\nCLOSE db_cursor\nDEALLOCATE db_cursor\n\nSELECT * FROM #TempResults ORDER BY FragmentationPercent DESC\n\nDROP TABLE #TempResults\n\"@\n\n            # Execute the query\n            $fragmentation = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # Build full list with status, and filter problematic ones\n            $allIndexes = @()\n            $highlyFragmented = @()\n            foreach ($idx in $fragmentation) {\n                $status = if ($idx.FragmentationPercent -le 10) {\n                    \"✅ Good\"\n                } elseif ($idx.FragmentationPercent -le 30) {\n                    \"⚠️ Reorganize\"\n                } else {\n                    \"❌ Rebuild\"\n                }\n                \n                $allIndexes += [PSCustomObject]@{\n                    Database = $idx.DatabaseName\n                    Schema = $idx.SchemaName\n                    Table = $idx.TableName\n                    IndexName = $idx.IndexName\n                    FragmentationPercent = $idx.FragmentationPercent\n                    PageCount = $idx.PageCount\n                    Status = $status\n                }\n                \n                # Keep track of problematic indexes (>50%)\n                if ($idx.FragmentationPercent -gt 50) {\n                    $highlyFragmented += [PSCustomObject]@{\n                        Database = $idx.DatabaseName\n                        Schema = $idx.SchemaName\n                        Table = $idx.TableName\n                        IndexName = $idx.IndexName\n                        FragmentationPercent = $idx.FragmentationPercent\n                        PageCount = $idx.PageCount\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Index Fragmentation\"\n                Status = if ($highlyFragmented.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($highlyFragmented.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies heavily fragmented indexes (>50% with >1000 pages)\"\n                Impact = \"Fragmented indexes cause excessive I/O, slower queries, and wasted storage space. Fragmentation >30% should be rebuilt, 10-30% can be reorganized. Regular maintenance is critical for performance.\"\n                CurrentValue = @{\n                    HighlyFragmentedIndexes = $highlyFragmented.Count\n                    WorstFragmentation = if ($highlyFragmented) { [math]::Round(($highlyFragmented | Measure-Object -Property FragmentationPercent -Maximum).Maximum, 2) } else { 0 }\n                }\n                RecommendedAction = if ($highlyFragmented.Count -eq 0) { \"No heavily fragmented indexes\" } else { \"Rebuild indexes >30%, reorganize 10-30% during maintenance window\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Rebuild heavily fragmented indexes (>30%)\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem | \n    Invoke-DbaDbShrink -RebuildIndexes -FragmentationLevel 30\n\n# Or use Ola Hallengren maintenance solution\nInstall-DbaMaintenanceSolution -SqlInstance '$serverName' -Solution IndexOptimize\n\"@\n                    TSQL = @\"\n-- Rebuild indexes with >30% fragmentation\nDECLARE @TableName VARCHAR(255)\nDECLARE @IndexName VARCHAR(255)\nDECLARE @SchemaName VARCHAR(255)\n\nDECLARE index_cursor CURSOR FOR\nSELECT \n    OBJECT_SCHEMA_NAME(ips.object_id) AS SchemaName,\n    OBJECT_NAME(ips.object_id) AS TableName,\n    i.name AS IndexName\nFROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED') ips\nINNER JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id\nWHERE ips.avg_fragmentation_in_percent > 30\nAND ips.page_count > 1000\n\nOPEN index_cursor\nFETCH NEXT FROM index_cursor INTO @SchemaName, @TableName, @IndexName\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    PRINT 'Rebuilding: ' + @SchemaName + '.' + @TableName + '.' + @IndexName\n    EXEC('ALTER INDEX [' + @IndexName + '] ON [' + @SchemaName + '].[' + @TableName + '] REBUILD WITH (ONLINE = ON)')\n    FETCH NEXT FROM index_cursor INTO @SchemaName, @TableName, @IndexName\nEND\n\nCLOSE index_cursor\nDEALLOCATE index_cursor\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/indexes/reorganize-and-rebuild-indexes\"\n                )\n                RawData = $allIndexes | Sort-Object -Property FragmentationPercent -Descending\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Index Fragmentation\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check fragmentation\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 11\n        \n        # ============================================================================\n        # CHECK 12: AUTO SHRINK\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 12 -CheckName \"Auto Shrink\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [12/$totalChecks] Checking auto shrink settings...\"\n        \n        try {\n            # Query all databases for auto shrink setting\n            $query = @\"\nSELECT name AS DatabaseName, \n       DATABASEPROPERTYEX(name, 'IsAutoShrink') AS IsAutoShrink\nFROM sys.databases\nWHERE name NOT IN ('master','model','msdb','tempdb')\nORDER BY name;\n\"@\n            $autoShrinkResults = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # Filter for databases with auto shrink enabled\n            $enabled = @()\n            foreach ($db in $autoShrinkResults) {\n                if ($db.IsAutoShrink -eq 1) {\n                    $enabled += $db\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Auto Shrink\"\n                Status = if ($enabled.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($enabled.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Detects databases with auto shrink enabled (should be disabled)\"\n                Impact = \"Auto shrink causes severe performance degradation through constant shrink/grow cycles, index fragmentation, and blocked operations. It's almost never appropriate for production databases.\"\n                CurrentValue = @{\n                    DatabasesWithAutoShrink = $enabled.Count\n                }\n                RecommendedAction = if ($enabled.Count -eq 0) { \"Auto shrink disabled on all databases\" } else { \"Disable auto shrink immediately on all databases\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Disable auto shrink on all databases\nGet-DbaDatabase -SqlInstance '$serverName' | \n    Where-Object { `$_.AutoShrink -eq `$true } |\n    Set-DbaDbAutoShrink -AutoShrink Disabled\n\"@\n                    TSQL = @\"\n-- Disable auto shrink\nALTER DATABASE [DatabaseName] SET AUTO_SHRINK OFF;\n\n-- Verify\nSELECT name, is_auto_shrink_on \nFROM sys.databases \nWHERE is_auto_shrink_on = 1;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-properties-options-page\"\n                )\n                RawData = $enabled | Select-Object Database, AutoShrink\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Auto Shrink\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check auto shrink\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 12\n        \n        # ============================================================================\n        # CHECK 13: AUTO CLOSE\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 13 -CheckName \"Auto Close\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [13/$totalChecks] Checking auto close settings...\"\n        \n        try {\n            # Query all databases for auto close setting\n            $query = @\"\nSELECT name AS DatabaseName, \n       DATABASEPROPERTYEX(name, 'IsAutoClose') AS IsAutoClose\nFROM sys.databases\nWHERE name NOT IN ('master','model','msdb','tempdb')\nORDER BY name;\n\"@\n            $autoCloseResults = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # Filter for databases with auto close enabled\n            $enabled = @()\n            foreach ($db in $autoCloseResults) {\n                if ($db.IsAutoClose -eq 1) {\n                    $enabled += $db\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Auto Close\"\n                Status = if ($enabled.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($enabled.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Detects databases with auto close enabled (should be disabled)\"\n                Impact = \"Auto close causes databases to be closed and reopened repeatedly, leading to connection timeouts, slow first queries, and resource overhead. Only useful for 32-bit SQL Express with many databases.\"\n                CurrentValue = @{\n                    DatabasesWithAutoClose = $enabled.Count\n                }\n                RecommendedAction = if ($enabled.Count -eq 0) { \"Auto close disabled on all databases\" } else { \"Disable auto close on all production databases\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Disable auto close on all databases\nGet-DbaDatabase -SqlInstance '$serverName' | \n    Where-Object { `$_.AutoClose -eq `$true } |\n    Set-DbaDbAutoClose -AutoClose Disabled\n\"@\n                    TSQL = @\"\n-- Disable auto close\nALTER DATABASE [DatabaseName] SET AUTO_CLOSE OFF;\n\n-- Verify\nSELECT name, is_auto_close_on \nFROM sys.databases \nWHERE is_auto_close_on = 1;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-properties-options-page\"\n                )\n                RawData = $enabled | Select-Object Database, AutoClose\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Auto Close\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check auto close\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 13\n        \n        # ============================================================================\n        # CHECK 14: PAGE VERIFY OPTION\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 14 -CheckName \"Page Verify Option\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [14/$totalChecks] Checking page verify settings...\"\n        \n        try {\n            # Query all databases for page verify setting\n            $query = @\"\nSELECT name AS DatabaseName, \n       page_verify_option_desc AS PageVerify\nFROM sys.databases\nWHERE name NOT IN ('master','model','msdb','tempdb')\nORDER BY name;\n\"@\n            $pageVerifyResults = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # Filter for databases not using CHECKSUM\n            $notChecksum = @()\n            foreach ($db in $pageVerifyResults) {\n                if ($db.PageVerify -ne 'CHECKSUM') {\n                    $notChecksum += $db\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Server Health\"\n                CheckName = \"Page Verify Option\"\n                Status = if ($notChecksum.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($notChecksum.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies all databases use CHECKSUM for page verification\"\n                Impact = \"CHECKSUM is the best method for detecting I/O corruption. TORN_PAGE_DETECTION is less effective, and NONE provides no protection. CHECKSUM has negligible performance impact on modern hardware.\"\n                CurrentValue = @{\n                    DatabasesNotUsingChecksum = $notChecksum.Count\n                }\n                RecommendedAction = if ($notChecksum.Count -eq 0) { \"All databases using CHECKSUM\" } else { \"Set PAGE_VERIFY to CHECKSUM for all databases\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Set page verify to CHECKSUM for all databases\nGet-DbaDatabase -SqlInstance '$serverName' | \n    Where-Object { `$_.PageVerify -ne 'Checksum' } |\n    Set-DbaDbPageVerify -PageVerify Checksum\n\"@\n                    TSQL = @\"\n-- Set page verify to CHECKSUM\nALTER DATABASE [DatabaseName] SET PAGE_VERIFY CHECKSUM;\n\n-- Verify all databases\nSELECT name, page_verify_option_desc \nFROM sys.databases \nWHERE page_verify_option_desc <> 'CHECKSUM';\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-properties-options-page\"\n                )\n                RawData = $notChecksum | Select-Object Database, PageVerify\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Page Verify\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check page verify\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 14\n        \n        # ============================================================================\n        # CHECK 15: SA ACCOUNT STATUS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 15 -CheckName \"SA Account Status\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [15/$totalChecks] Checking SA account status...\"\n        \n        try {\n            $saLogin = Get-DbaLogin -SqlInstance $conn -Login 'sa'\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"SA Account Status\"\n                Status = if ($saLogin.IsDisabled) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($saLogin.IsDisabled) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies that the built-in 'sa' account is disabled\"\n                Impact = \"The 'sa' account is a well-known sysadmin account and prime target for brute-force attacks. Keeping it enabled increases security risk. Best practice: disable it and use Windows Authentication or named accounts.\"\n                CurrentValue = @{\n                    IsDisabled = $saLogin.IsDisabled\n                    LastLogin = $saLogin.LastLogin\n                }\n                RecommendedAction = if ($saLogin.IsDisabled) { \"SA account properly disabled\" } else { \"Disable sa account after ensuring alternative sysadmin access exists\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# IMPORTANT: Verify alternative sysadmin accounts first!\nGet-DbaServerRoleMember -SqlInstance '$serverName' -ServerRole sysadmin\n\n# If other sysadmins exist, disable sa\nDisable-DbaLogin -SqlInstance '$serverName' -Login 'sa' -Confirm:`$false\n\n# Verify\nGet-DbaLogin -SqlInstance '$serverName' -Login 'sa' | Select-Object Name, IsDisabled\n\"@\n                    TSQL = @\"\n-- IMPORTANT: Verify other sysadmin logins first!\nSELECT p.name, p.type_desc\nFROM sys.server_principals p\nJOIN sys.server_role_members rm ON p.principal_id = rm.member_principal_id\nJOIN sys.server_principals r ON rm.role_principal_id = r.principal_id\nWHERE r.name = 'sysadmin' AND p.name <> 'sa';\n\n-- If other sysadmins exist, disable sa\nALTER LOGIN [sa] DISABLE;\n\n-- Verify\nSELECT name, is_disabled FROM sys.server_principals WHERE name = 'sa';\n\"@\n                    Manual = @\"\n1. CRITICAL: Ensure you have alternative sysadmin access first!\n2. Open SQL Server Management Studio\n3. Connect with non-sa sysadmin account\n4. Expand Security → Logins\n5. Right-click 'sa' → Properties\n6. Check 'Login is disabled'\n7. Click OK\n8. Test: Try connecting with sa (should fail)\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/securing-sql-server\"\n                )\n                RawData = $saLogin | Select-Object Name, IsDisabled, CreateDate, LastLogin\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"SA Account\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check SA account\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 15\n        \n        # ============================================================================\n        # CHECK 16: WEAK PASSWORDS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 16 -CheckName \"Weak Passwords\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [16/$totalChecks] Testing for weak passwords...\"\n        \n        try {\n            $weakPasswords = Test-DbaLoginPassword -SqlInstance $conn\n            $weak = $weakPasswords | Where-Object { $_.PasswordIsWeak -eq $true -or $_.PasswordIsBlank -eq $true }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Weak Passwords\"\n                Status = if ($weak.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($weak.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Tests SQL logins for weak, blank, or commonly used passwords\"\n                Impact = \"Weak passwords are easily compromised through brute-force or dictionary attacks, providing unauthorized access to your SQL Server. This is a critical security vulnerability.\"\n                CurrentValue = @{\n                    LoginsWithWeakPasswords = $weak.Count\n                    WeakLogins = ($weak.Login -join ', ')\n                }\n                RecommendedAction = if ($weak.Count -eq 0) { \"No weak passwords detected\" } else { \"Change all weak passwords immediately and enable password policy enforcement\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Force password policy on SQL logins\nGet-DbaLogin -SqlInstance '$serverName' -Type SQL | \n    Set-DbaLogin -PasswordPolicyEnforced\n\n# Change specific weak password (interactive)\nSet-DbaLogin -SqlInstance '$serverName' -Login 'LoginName' -SecurePassword (Read-Host -AsSecureString -Prompt 'Enter new password')\n\"@\n                    TSQL = @\"\n-- Enable password policy enforcement\nALTER LOGIN [LoginName] WITH CHECK_POLICY = ON, CHECK_EXPIRATION = ON;\n\n-- Change weak password\nALTER LOGIN [LoginName] WITH PASSWORD = 'NewStrongP@ssw0rd!';\n\n-- Verify policy settings\nSELECT name, is_policy_checked, is_expiration_checked\nFROM sys.sql_logins\nWHERE is_policy_checked = 0;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/password-policy\"\n                )\n                RawData = $weak | Select-Object Login, PasswordIsWeak, PasswordIsBlank\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Weak Passwords\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not test passwords\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 16\n        \n        # ============================================================================\n        # CHECK 17: XP_CMDSHELL CONFIGURATION (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 17 -CheckName \"xp_cmdshell Configuration\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [17/$totalChecks] Checking xp_cmdshell configuration...\"\n        \n        try {\n            $spConfig = Get-DbaSpConfigure -SqlInstance $conn -Name 'xp_cmdshell'\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"xp_cmdshell Configuration\"\n                Status = if ($spConfig.ConfiguredValue -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($spConfig.ConfiguredValue -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies that xp_cmdshell is disabled for security\"\n                Impact = \"xp_cmdshell allows execution of operating system commands from SQL Server. If enabled, it provides a direct attack vector for SQL injection to gain OS-level access. Should only be enabled when absolutely necessary and with proper security controls.\"\n                CurrentValue = @{\n                    IsEnabled = $spConfig.ConfiguredValue -eq 1\n                    ConfigValue = $spConfig.ConfiguredValue\n                    RunValue = $spConfig.RunningValue\n                }\n                RecommendedAction = if ($spConfig.ConfiguredValue -eq 0) { \"xp_cmdshell is properly disabled\" } else { \"Disable xp_cmdshell unless specifically required\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Disable xp_cmdshell\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name 'xp_cmdshell' -Value 0\n\n# Verify\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name 'xp_cmdshell'\n\"@\n                    TSQL = @\"\n-- Disable xp_cmdshell\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nEXEC sp_configure 'xp_cmdshell', 0;\nRECONFIGURE;\n\n-- Verify\nEXEC sp_configure 'xp_cmdshell';\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql\"\n                )\n                RawData = $spConfig\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"xp_cmdshell\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check xp_cmdshell\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 17\n        \n        # ============================================================================\n        # CHECK 18: ORPHANED USERS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 18 -CheckName \"Orphaned Users\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [18/$totalChecks] Checking for orphaned users...\"\n        \n        try {\n            $orphanedUsers = Get-DbaDbOrphanUser -SqlInstance $conn\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Orphaned Users\"\n                Status = if ($orphanedUsers.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($orphanedUsers.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies database users without corresponding server logins\"\n                Impact = \"Orphaned users cannot log in and represent security clutter. They may indicate deleted logins that still have database access defined, or issues after database restores/migrations. Clean up improves security and maintainability.\"\n                CurrentValue = @{\n                    OrphanedUserCount = $orphanedUsers.Count\n                }\n                RecommendedAction = if ($orphanedUsers.Count -eq 0) { \"No orphaned users found\" } else { \"Remove orphaned users or remap to correct logins\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Option 1: Repair orphaned users (map to logins with same name)\nRepair-DbaDbOrphanUser -SqlInstance '$serverName' -RemoveNotExisting\n\n# Option 2: Remove orphaned users\nGet-DbaDbOrphanUser -SqlInstance '$serverName' | \n    Remove-DbaDbUser\n\n# Option 3: Manually map user to login\nRepair-DbaDbOrphanUser -SqlInstance '$serverName' -Database 'DatabaseName' -User 'UserName' -Login 'LoginName'\n\"@\n                    TSQL = @\"\n-- Find orphaned users\nUSE [DatabaseName];\nSELECT \n    dp.name AS UserName,\n    dp.type_desc AS UserType\nFROM sys.database_principals dp\nLEFT JOIN sys.server_principals sp ON dp.sid = sp.sid\nWHERE sp.sid IS NULL\nAND dp.type IN ('S','U')\nAND dp.name NOT IN ('guest','INFORMATION_SCHEMA','sys');\n\n-- Option 1: Remap user to login with same name\nALTER USER [UserName] WITH LOGIN = [LoginName];\n\n-- Option 2: Drop orphaned user\nDROP USER [UserName];\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/sql-server/failover-clusters/troubleshoot-orphaned-users-sql-server\"\n                )\n                RawData = $orphanedUsers | Select-Object Database, User\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Orphaned Users\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check orphaned users\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 18\n        \n        # ============================================================================\n        # CHECK 19: DATABASE OWNERSHIP (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 19 -CheckName \"Database Ownership\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [19/$totalChecks] Checking database ownership...\"\n        \n        try {\n            # Query to get database ownership information\n            $query = @\"\nSELECT \n    d.name AS DatabaseName,\n    SUSER_SNAME(d.owner_sid) AS CurrentOwner,\n    'sa' AS ExpectedOwner,\n    CASE WHEN SUSER_SNAME(d.owner_sid) = 'sa' THEN 'True' ELSE 'False' END AS OwnerMatch\nFROM sys.databases d\nWHERE d.name NOT IN ('master','model','msdb','tempdb')\nORDER BY d.name;\n\"@\n            \n            $dbOwners = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # Filter for databases not owned by sa\n            $notSa = @()\n            foreach ($db in $dbOwners) {\n                if ($db.OwnerMatch -eq 'False') {\n                    $notSa += $db\n                }\n            }\n            \n            # Convert to simple objects for table display\n            $ownerTable = @()\n            foreach ($db in $notSa) {\n                $ownerTable += [PSCustomObject]@{\n                    Database = $db.DatabaseName\n                    CurrentOwner = $db.CurrentOwner\n                    ExpectedOwner = $db.ExpectedOwner\n                    OwnerMatch = $db.OwnerMatch\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Database Ownership\"\n                Status = if ($notSa.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($notSa.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies all databases are owned by 'sa' for consistency\"\n                Impact = \"Databases owned by regular accounts can cause issues if that account is deleted or permissions change. Best practice is to have all databases owned by 'sa' (even if sa is disabled) for consistency and to avoid ownership chain issues.\"\n                CurrentValue = @{\n                    DatabasesNotOwnedBySA = $notSa.Count\n                }\n                RecommendedAction = if ($notSa.Count -eq 0) { \"All databases owned by sa\" } else { \"Change database ownership to 'sa'\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Change all database owners to sa\nSet-DbaDbOwner -SqlInstance '$serverName' -TargetLogin sa\n\n# Verify\nGet-DbaDbOwner -SqlInstance '$serverName'\n\"@\n                    TSQL = @\"\n-- Change database owner to sa\nALTER AUTHORIZATION ON DATABASE::[DatabaseName] TO sa;\n\n-- Change all databases to sa\nDECLARE @db VARCHAR(100)\nDECLARE db_cursor CURSOR FOR\nSELECT name FROM sys.databases\nWHERE name NOT IN ('master','model','msdb','tempdb')\nAND SUSER_SNAME(owner_sid) <> 'sa'\n\nOPEN db_cursor\nFETCH NEXT FROM db_cursor INTO @db\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    EXEC('ALTER AUTHORIZATION ON DATABASE::[' + @db + '] TO sa')\n    FETCH NEXT FROM db_cursor INTO @db\nEND\n\nCLOSE db_cursor\nDEALLOCATE db_cursor\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-authorization-transact-sql\"\n                )\n                RawData = $ownerTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Database Ownership\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check database ownership\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 19\n        \n        # ============================================================================\n        # CHECK 20: DUPLICATE INDEXES (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 20 -CheckName \"Duplicate Indexes\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [20/$totalChecks] Checking for duplicate indexes...\"\n        \n        try {\n            # Get all duplicate indexes\n            $allDuplicates = Find-DbaDbDuplicateIndex -SqlInstance $conn\n            \n            # Filter out system databases\n            $duplicateIndexes = @()\n            foreach ($dup in $allDuplicates) {\n                if ($dup.DatabaseName -notin @('master','model','msdb','tempdb')) {\n                    $duplicateIndexes += $dup\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Duplicate Indexes\"\n                Status = if ($duplicateIndexes.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($duplicateIndexes.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies redundant/duplicate indexes that waste space and slow down writes\"\n                Impact = \"Duplicate indexes waste disk space, increase backup/restore time, and slow down INSERT/UPDATE/DELETE operations because SQL Server must maintain multiple identical indexes. They provide no query performance benefit.\"\n                CurrentValue = @{\n                    DuplicateIndexCount = $duplicateIndexes.Count\n                }\n                RecommendedAction = if ($duplicateIndexes.Count -eq 0) { \"No duplicate indexes found\" } else { \"Drop duplicate indexes after verifying query plans don't rely on them\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find duplicate indexes\n`$dupes = Find-DbaDuplicateIndex -SqlInstance '$serverName'\n\n# Review before dropping\n`$dupes | Select-Object DatabaseName, TableName, IndexName, KeyColumns\n\n# Drop duplicate indexes (BE CAREFUL - verify first!)\n# `$dupes | Remove-DbaIndex -Confirm:`$false\n\"@\n                    TSQL = @\"\n-- Find duplicate indexes manually\nSELECT \n    t.name AS TableName,\n    i1.name AS Index1,\n    i2.name AS Index2\nFROM sys.indexes i1\nINNER JOIN sys.indexes i2 ON i1.object_id = i2.object_id\nINNER JOIN sys.tables t ON i1.object_id = t.object_id\nWHERE i1.index_id < i2.index_id\nAND i1.type = i2.type\n-- Add more logic to compare columns\n\n-- Drop duplicate index (after verification!)\nDROP INDEX [IndexName] ON [SchemaName].[TableName];\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/indexes/indexes\"\n                )\n                RawData = $duplicateIndexes | Select-Object DatabaseName, TableName, IndexName, KeyColumns\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Duplicate Indexes\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check for duplicates\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 20\n        \n        # ============================================================================\n        # CHECK 21: TABLES WITHOUT PRIMARY KEY (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 21 -CheckName \"Tables Without Primary Key\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [21/$totalChecks] Checking for tables without primary keys...\"\n        \n        try {\n            $tablesNoPK = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    SUM(p.rows) AS [RowCount]\nFROM sys.tables t\nLEFT JOIN sys.indexes i ON t.object_id = i.object_id AND i.is_primary_key = 1\nINNER JOIN sys.partitions p ON t.object_id = p.object_id AND p.index_id IN (0, 1)\nWHERE i.object_id IS NULL\nAND t.is_ms_shipped = 0\nGROUP BY SCHEMA_NAME(t.schema_id), t.name\nORDER BY [RowCount] DESC;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $tablesNoPK += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            RowCount = $_.RowCount\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Tables Without Primary Key\"\n                Status = if ($tablesNoPK.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($tablesNoPK.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies tables without primary keys\"\n                Impact = \"Tables without primary keys can cause data integrity issues, duplicate rows, poor query performance, and problems with replication/change tracking. Primary keys ensure row uniqueness and enable efficient lookups.\"\n                CurrentValue = @{\n                    TablesWithoutPK = $tablesNoPK.Count\n                }\n                RecommendedAction = if ($tablesNoPK.Count -eq 0) { \"All tables have primary keys\" } else { \"Add primary keys to tables or document why they're not needed\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Review tables without primary keys\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT SCHEMA_NAME(schema_id) + '.' + name AS TableName\nFROM sys.tables t\nWHERE NOT EXISTS (SELECT 1 FROM sys.indexes WHERE object_id = t.object_id AND is_primary_key = 1)\n'@\n\n# Add primary key requires manual analysis of appropriate column(s)\n\"@\n                    TSQL = @\"\n-- Add primary key to existing table\nALTER TABLE [SchemaName].[TableName]\nADD CONSTRAINT PK_TableName PRIMARY KEY CLUSTERED ([ColumnName]);\n\n-- Add identity column and primary key\nALTER TABLE [SchemaName].[TableName]\nADD ID INT IDENTITY(1,1);\n\nALTER TABLE [SchemaName].[TableName]\nADD CONSTRAINT PK_TableName PRIMARY KEY CLUSTERED (ID);\n\n-- Add composite primary key\nALTER TABLE [SchemaName].[TableName]\nADD CONSTRAINT PK_TableName PRIMARY KEY CLUSTERED ([Column1], [Column2]);\n\"@\n                    Manual = @\"\n1. Analyze each table to determine appropriate primary key column(s)\n2. Verify data uniqueness: SELECT Column, COUNT(*) FROM Table GROUP BY Column HAVING COUNT(*) > 1\n3. If duplicates exist, clean data first\n4. Add primary key constraint\n5. Consider adding identity column if no natural key exists\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints\"\n                )\n                RawData = $tablesNoPK | Select-Object Database, Schema, Table, RowCount\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Tables Without Primary Key\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check tables\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 21\n        \n        # ============================================================================\n        # CHECK 22: TABLES WITHOUT INDEXES (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 22 -CheckName \"Tables Without Indexes\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [22/$totalChecks] Checking for tables without indexes...\"\n        \n        try {\n            $tablesNoIndex = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    SUM(p.rows) AS [RowCount]\nFROM sys.tables t\nLEFT JOIN sys.indexes i ON t.object_id = i.object_id AND i.type > 0\nINNER JOIN sys.partitions p ON t.object_id = p.object_id AND p.index_id IN (0, 1)\nWHERE i.object_id IS NULL\nAND t.is_ms_shipped = 0\nGROUP BY SCHEMA_NAME(t.schema_id), t.name\nHAVING SUM(p.rows) > 1000\nORDER BY [RowCount] DESC;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $tablesNoIndex += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            RowCount = $_.RowCount\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Tables Without Indexes\"\n                Status = if ($tablesNoIndex.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($tablesNoIndex.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies tables with >1000 rows that have no indexes (heaps)\"\n                Impact = \"Tables without indexes (heaps) cause full table scans on every query, leading to poor performance, high I/O, and blocking. While small tables may not need indexes, tables with >1000 rows typically benefit from at least a clustered index.\"\n                CurrentValue = @{\n                    TablesWithoutIndexes = $tablesNoIndex.Count\n                }\n                RecommendedAction = if ($tablesNoIndex.Count -eq 0) { \"All large tables have indexes\" } else { \"Add clustered indexes to heap tables with significant row counts\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find heap tables with row counts\n`$heaps = Invoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    DB_NAME() AS DatabaseName,\n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    SUM(p.rows) AS [RowCount]\nFROM sys.tables t\nINNER JOIN sys.partitions p ON t.object_id = p.object_id AND p.index_id = 0\nGROUP BY t.schema_id, t.name\nHAVING SUM(p.rows) > 1000\n'@\n\n`$heaps | Format-Table\n\"@\n                    TSQL = @\"\n-- Create clustered index on heap table\nCREATE CLUSTERED INDEX IX_TableName_ColumnName \nON [SchemaName].[TableName] ([ColumnName]);\n\n-- If table has primary key, make it clustered\nALTER TABLE [SchemaName].[TableName]\nDROP CONSTRAINT PK_ConstraintName;\n\nALTER TABLE [SchemaName].[TableName]\nADD CONSTRAINT PK_ConstraintName PRIMARY KEY CLUSTERED ([ColumnName]);\n\n-- Find missing index recommendations\nSELECT \n    migs.avg_user_impact,\n    mid.statement,\n    mid.equality_columns,\n    mid.inequality_columns,\n    mid.included_columns\nFROM sys.dm_db_missing_index_details mid\nJOIN sys.dm_db_missing_index_groups mig ON mid.index_handle = mig.index_handle\nJOIN sys.dm_db_missing_index_group_stats migs ON mig.index_group_handle = migs.group_handle\nORDER BY migs.avg_user_impact DESC;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/indexes/heaps-tables-without-clustered-indexes\"\n                )\n                RawData = $tablesNoIndex | Select-Object Database, Schema, Table, RowCount\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Tables Without Indexes\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check tables\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 22\n        \n        # ============================================================================\n        # CHECK 23: FOREIGN KEYS WITHOUT INDEXES (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 23 -CheckName \"Foreign Keys Without Indexes\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [23/$totalChecks] Checking foreign keys without indexes...\"\n        \n        try {\n            $fkNoIndex = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    OBJECT_SCHEMA_NAME(fk.parent_object_id) AS SchemaName,\n    OBJECT_NAME(fk.parent_object_id) AS TableName,\n    fk.name AS ForeignKeyName,\n    COL_NAME(fkc.parent_object_id, fkc.parent_column_id) AS ColumnName\nFROM sys.foreign_keys fk\nINNER JOIN sys.foreign_key_columns fkc ON fk.object_id = fkc.constraint_object_id\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM sys.index_columns ic\n    WHERE ic.object_id = fkc.parent_object_id\n    AND ic.column_id = fkc.parent_column_id\n    AND ic.index_column_id = 1\n)\nORDER BY SchemaName, TableName;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $fkNoIndex += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            ForeignKey = $_.ForeignKeyName\n                            Column = $_.ColumnName\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Foreign Keys Without Indexes\"\n                Status = if ($fkNoIndex.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($fkNoIndex.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies foreign key columns without supporting indexes\"\n                Impact = \"Foreign key columns without indexes cause table scans during DELETE/UPDATE operations on the parent table, and slow JOIN queries. This leads to blocking, deadlocks, and poor performance in multi-table operations.\"\n                CurrentValue = @{\n                    ForeignKeysWithoutIndexes = $fkNoIndex.Count\n                }\n                RecommendedAction = if ($fkNoIndex.Count -eq 0) { \"All foreign keys have indexes\" } else { \"Create indexes on foreign key columns\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Script to create indexes on FK columns\n`$fks = Invoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT DISTINCT\n    DB_NAME() AS DatabaseName,\n    OBJECT_SCHEMA_NAME(fk.parent_object_id) AS SchemaName,\n    OBJECT_NAME(fk.parent_object_id) AS TableName,\n    COL_NAME(fkc.parent_object_id, fkc.parent_column_id) AS ColumnName\nFROM sys.foreign_keys fk\nINNER JOIN sys.foreign_key_columns fkc ON fk.object_id = fkc.constraint_object_id\nWHERE NOT EXISTS (\n    SELECT 1 FROM sys.index_columns ic\n    WHERE ic.object_id = fkc.parent_object_id AND ic.column_id = fkc.parent_column_id\n)\n'@\n\n`$fks | ForEach-Object {\n    Write-Host \"CREATE INDEX IX_`$(`$_.TableName)_`$(`$_.ColumnName) ON [`$(`$_.SchemaName)].[`$(`$_.TableName)] ([`$(`$_.ColumnName)]);\"\n}\n\"@\n                    TSQL = @\"\n-- Create index on foreign key column\nCREATE NONCLUSTERED INDEX IX_TableName_FKColumn\nON [SchemaName].[TableName] ([FKColumn]);\n\n-- Create covering index if needed for common queries\nCREATE NONCLUSTERED INDEX IX_TableName_FKColumn\nON [SchemaName].[TableName] ([FKColumn])\nINCLUDE ([OtherColumn1], [OtherColumn2]);\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints\"\n                )\n                RawData = $fkNoIndex | Select-Object Database, Schema, Table, ForeignKey, Column\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Foreign Keys Without Indexes\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check foreign keys\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 23\n        \n        # ============================================================================\n        # CHECK 24: DISABLED OR UNTRUSTED FOREIGN KEYS (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 24 -CheckName \"Disabled/Untrusted Foreign Keys\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [24/$totalChecks] Checking disabled/untrusted foreign keys...\"\n        \n        try {\n            $untrustedFK = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    OBJECT_SCHEMA_NAME(parent_object_id) AS SchemaName,\n    OBJECT_NAME(parent_object_id) AS TableName,\n    name AS ForeignKeyName,\n    is_disabled,\n    is_not_trusted\nFROM sys.foreign_keys\nWHERE is_disabled = 1 OR is_not_trusted = 1\nORDER BY SchemaName, TableName;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $untrustedFK += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            ForeignKey = $_.ForeignKeyName\n                            IsDisabled = $_.is_disabled\n                            IsNotTrusted = $_.is_not_trusted\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Disabled/Untrusted Foreign Keys\"\n                Status = if ($untrustedFK.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($untrustedFK.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies foreign keys that are disabled or not trusted\"\n                Impact = \"Disabled foreign keys don't enforce referential integrity, allowing orphaned records. Untrusted foreign keys (is_not_trusted=1) prevent the query optimizer from using them for query optimization, resulting in suboptimal execution plans and poor performance.\"\n                CurrentValue = @{\n                    DisabledOrUntrustedFKs = $untrustedFK.Count\n                    DisabledCount = ($untrustedFK | Where-Object { $_.IsDisabled }).Count\n                    UntrustedCount = ($untrustedFK | Where-Object { $_.IsNotTrusted }).Count\n                }\n                RecommendedAction = if ($untrustedFK.Count -eq 0) { \"All foreign keys are enabled and trusted\" } else { \"Re-enable and validate foreign keys to ensure data integrity\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find untrusted foreign keys\n`$untrusted = Invoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    DB_NAME() AS DatabaseName,\n    OBJECT_SCHEMA_NAME(parent_object_id) AS SchemaName,\n    OBJECT_NAME(parent_object_id) AS TableName,\n    name AS ForeignKeyName\nFROM sys.foreign_keys\nWHERE is_not_trusted = 1\n'@\n\n# Generate fix scripts\n`$untrusted | ForEach-Object {\n    Write-Host \"ALTER TABLE [`$(`$_.SchemaName)].[`$(`$_.TableName)] WITH CHECK CHECK CONSTRAINT [`$(`$_.ForeignKeyName)];\"\n}\n\"@\n                    TSQL = @\"\n-- Re-enable disabled foreign key\nALTER TABLE [SchemaName].[TableName] \nCHECK CONSTRAINT [FK_Name];\n\n-- Make untrusted foreign key trusted (validates existing data)\nALTER TABLE [SchemaName].[TableName] \nWITH CHECK CHECK CONSTRAINT [FK_Name];\n\n-- Find all untrusted FKs\nSELECT \n    OBJECT_SCHEMA_NAME(parent_object_id) AS SchemaName,\n    OBJECT_NAME(parent_object_id) AS TableName,\n    name AS ConstraintName\nFROM sys.foreign_keys\nWHERE is_not_trusted = 1;\n\n-- Fix all untrusted FKs in database (generate script)\nSELECT \n    'ALTER TABLE [' + OBJECT_SCHEMA_NAME(parent_object_id) + '].[' + \n    OBJECT_NAME(parent_object_id) + '] WITH CHECK CHECK CONSTRAINT [' + \n    name + '];' AS FixScript\nFROM sys.foreign_keys\nWHERE is_not_trusted = 1;\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/tables/primary-and-foreign-key-constraints\",\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-table-transact-sql\"\n                )\n                RawData = $untrustedFK | Select-Object Database, Schema, Table, ForeignKey, IsDisabled, IsNotTrusted\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Disabled/Untrusted Foreign Keys\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check foreign keys\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 24\n        \n        # ============================================================================\n        # CHECK 25: WAIT STATISTICS (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 25 -CheckName \"Wait Statistics\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [25/$totalChecks] Analyzing wait statistics...\"\n        \n        try {\n            $waitStats = Get-DbaWaitStatistic -SqlInstance $conn -Threshold 1 | Select-Object -First 10\n            $topWaitType = $waitStats | Select-Object -First 1\n            \n            # Convert wait stats to simple table format\n            $waitStatsTable = @()\n            foreach ($wait in $waitStats) {\n                $waitStatsTable += [PSCustomObject]@{\n                    WaitType = $wait.WaitType\n                    WaitTime = if ($wait.WaitTime) { [math]::Round($wait.WaitTime.TotalMilliseconds, 0) } else { 0 }\n                    Percentage = if ($wait.Percentage) { [math]::Round($wait.Percentage, 2) } else { 0 }\n                    WaitingTasksCount = if ($wait.WaitingTasksCount) { $wait.WaitingTasksCount } else { 0 }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Wait Statistics\"\n                Status = if ($topWaitType.WaitType -match 'SLEEP|BROKER|XE_') { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($topWaitType.WaitType -match 'SLEEP|BROKER|XE_') { \"Pass\" } else { \"Warning\" }\n                Description = \"Analyzes top wait types indicating performance bottlenecks\"\n                Impact = @\"\nWait statistics reveal where SQL Server spends time waiting. Common problematic waits:\n- PAGEIOLATCH_*: Disk I/O bottleneck (slow storage or memory pressure)\n- LCK_*: Blocking/locking issues\n- CXPACKET/CXCONSUMER: Parallelism issues\n- SOS_SCHEDULER_YIELD: CPU pressure\n- WRITELOG: Transaction log bottleneck\n- RESOURCE_SEMAPHORE: Memory grant waits (queries waiting for memory)\n\"@\n                CurrentValue = @{\n                    TopWaitType = $topWaitType.WaitType\n                    WaitTimeMs = if ($topWaitType.WaitTime) { [math]::Round($topWaitType.WaitTime.TotalMilliseconds, 0) } else { 0 }\n                    PercentageOfTotal = if ($topWaitType.Percentage) { [math]::Round($topWaitType.Percentage, 2) } else { 0 }\n                }\n                RecommendedAction = if ($topWaitType.WaitType -match 'SLEEP|BROKER|XE_') { \"Wait statistics appear normal\" } else { \"Investigate and address top wait types\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get detailed wait statistics\nGet-DbaWaitStatistic -SqlInstance '$serverName' | Select-Object -First 20\n\n# Reset wait statistics (after analysis)\n# Invoke-DbaQuery -SqlInstance '$serverName' -Query 'DBCC SQLPERF(''sys.dm_os_wait_stats'', CLEAR)'\n\n# Continuous monitoring\nwhile (`$true) {\n    Get-DbaWaitStatistic -SqlInstance '$serverName' -Threshold 5 | Format-Table\n    Start-Sleep -Seconds 30\n}\n\"@\n                    TSQL = @\"\n-- Get wait statistics\nSELECT TOP 10\n    wait_type,\n    wait_time_ms,\n    wait_time_ms * 100.0 / SUM(wait_time_ms) OVER() AS percentage,\n    waiting_tasks_count,\n    wait_time_ms / NULLIF(waiting_tasks_count, 0) AS avg_wait_time_ms\nFROM sys.dm_os_wait_stats\nWHERE wait_type NOT IN (\n    'CLR_SEMAPHORE', 'LAZYWRITER_SLEEP', 'RESOURCE_QUEUE', 'SLEEP_TASK',\n    'SLEEP_SYSTEMTASK', 'SQLTRACE_BUFFER_FLUSH', 'WAITFOR', 'LOGMGR_QUEUE',\n    'CHECKPOINT_QUEUE', 'REQUEST_FOR_DEADLOCK_SEARCH', 'XE_TIMER_EVENT',\n    'BROKER_TO_FLUSH', 'BROKER_TASK_STOP', 'CLR_MANUAL_EVENT',\n    'CLR_AUTO_EVENT', 'DISPATCHER_QUEUE_SEMAPHORE', 'FT_IFTS_SCHEDULER_IDLE_WAIT',\n    'XE_DISPATCHER_WAIT', 'XE_DISPATCHER_JOIN', 'SQLTRACE_INCREMENTAL_FLUSH_SLEEP'\n)\nAND wait_time_ms > 0\nORDER BY wait_time_ms DESC;\n\n-- Reset wait statistics (use carefully!)\n-- DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);\n\"@\n                    Manual = @\"\n1. Identify top wait types using above queries\n2. Research wait type meaning at: https://www.sqlskills.com/help/waits/\n3. Common remediation by wait type:\n   - PAGEIOLATCH: Add memory, faster storage, optimize queries\n   - LCK_M: Reduce transaction duration, add indexes, review locking hints\n   - CXPACKET: Adjust MAXDOP, update statistics, optimize queries\n   - WRITELOG: Faster log disk, reduce transaction size\n   - RESOURCE_SEMAPHORE: Add memory, optimize memory-intensive queries\n4. Monitor trends over time, not just snapshots\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-os-wait-stats-transact-sql\",\n                    \"https://www.sqlskills.com/help/waits/\"\n                )\n                RawData = $waitStatsTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Wait Statistics\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not get wait stats\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 25\n        \n        # ============================================================================\n        # CHECK 26: TOP SLOW QUERIES (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 26 -CheckName \"Top Slow Queries\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [26/$totalChecks] Analyzing slow queries...\"\n        \n        try {\n            # Use direct T-SQL query for accurate duration data\n            $slowQueryQuery = @\"\nSELECT TOP 20\n    qs.execution_count,\n    qs.total_elapsed_time / 1000 AS total_elapsed_time_ms,\n    qs.total_elapsed_time / qs.execution_count / 1000 AS avg_elapsed_time_ms,\n    qs.total_worker_time / 1000 AS total_cpu_time_ms,\n    qs.total_logical_reads,\n    DB_NAME(CAST(pa.value AS INT)) AS DatabaseName,\n    CONVERT(VARCHAR(64), qs.query_hash, 1) AS QueryHash,\n    SUBSTRING(st.text, (qs.statement_start_offset/2)+1,\n        ((CASE qs.statement_end_offset\n            WHEN -1 THEN DATALENGTH(st.text)\n            ELSE qs.statement_end_offset\n        END - qs.statement_start_offset)/2) + 1) AS query_text\nFROM sys.dm_exec_query_stats qs\nCROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st\nOUTER APPLY sys.dm_exec_plan_attributes(qs.plan_handle) pa\nWHERE pa.attribute = 'dbid'\nORDER BY qs.total_elapsed_time / qs.execution_count DESC;\n\"@\n            \n            $slowQueries = Invoke-DbaQuery -SqlInstance $conn -Query $slowQueryQuery\n            $avgDuration = if ($slowQueries) { ($slowQueries | Measure-Object -Property avg_elapsed_time_ms -Average).Average } else { 0 }\n            \n            # Convert to simple objects for table display\n            $queryTable = @()\n            foreach ($query in $slowQueries) {\n                $queryTable += [PSCustomObject]@{\n                    AvgDurationMs = [math]::Round($query.avg_elapsed_time_ms, 0)\n                    ExecutionCount = $query.execution_count\n                    DatabaseName = if ($query.DatabaseName) { $query.DatabaseName } else { \"N/A\" }\n                    QueryHash = if ($query.QueryHash) { $query.QueryHash } else { \"N/A\" }\n                    TotalCPUMs = [math]::Round($query.total_cpu_time_ms, 0)\n                    LogicalReads = $query.total_logical_reads\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Top Slow Queries\"\n                Status = if ($avgDuration -lt 5000) { \"✅ Pass\" } elseif ($avgDuration -lt 30000) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($avgDuration -lt 5000) { \"Pass\" } elseif ($avgDuration -lt 30000) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies the slowest running queries based on execution duration\"\n                Impact = \"Slow queries consume server resources, cause blocking, increase wait times for other queries, and degrade user experience. They often indicate missing indexes, poor query design, or outdated statistics.\"\n                CurrentValue = @{\n                    AverageDurationMs = [math]::Round($avgDuration, 0)\n                    SlowQueryCount = $slowQueries.Count\n                }\n                RecommendedAction = if ($avgDuration -lt 5000) { \"Query performance appears acceptable\" } else { \"Optimize slow queries using execution plans and indexing\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find top slow queries by duration\nGet-DbaTopResourceUsage -SqlInstance '$serverName' -Type Duration -Limit 20 | \n    Select-Object QueryHash, AverageDuration, ExecutionCount, Database |\n    Format-Table\n\n# Get query text and execution plan\n`$slowQuery = Get-DbaTopResourceUsage -SqlInstance '$serverName' -Type Duration -Limit 1\nInvoke-DbaQuery -SqlInstance '$serverName' -Query `$slowQuery.QueryText\n\n# Analyze execution plan\nGet-DbaExecutionPlan -SqlInstance '$serverName' -Database 'DatabaseName'\n\"@\n                    TSQL = @\"\n-- Top 20 slowest queries by average duration\nSELECT TOP 20\n    qs.execution_count,\n    qs.total_elapsed_time / 1000 AS total_elapsed_time_ms,\n    qs.total_elapsed_time / qs.execution_count / 1000 AS avg_elapsed_time_ms,\n    qs.total_worker_time / 1000 AS total_cpu_time_ms,\n    qs.total_logical_reads,\n    SUBSTRING(st.text, (qs.statement_start_offset/2)+1,\n        ((CASE qs.statement_end_offset\n            WHEN -1 THEN DATALENGTH(st.text)\n            ELSE qs.statement_end_offset\n        END - qs.statement_start_offset)/2) + 1) AS query_text,\n    qp.query_plan\nFROM sys.dm_exec_query_stats qs\nCROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st\nCROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp\nORDER BY qs.total_elapsed_time / qs.execution_count DESC;\n\n-- Find queries with high logical reads (often need indexes)\nSELECT TOP 20\n    qs.execution_count,\n    qs.total_logical_reads,\n    qs.total_logical_reads / qs.execution_count AS avg_logical_reads,\n    SUBSTRING(st.text, (qs.statement_start_offset/2)+1,\n        ((CASE qs.statement_end_offset\n            WHEN -1 THEN DATALENGTH(st.text)\n            ELSE qs.statement_end_offset\n        END - qs.statement_start_offset)/2) + 1) AS query_text\nFROM sys.dm_exec_query_stats qs\nCROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st\nORDER BY qs.total_logical_reads DESC;\n\"@\n                    Manual = @\"\n1. Identify slow queries using above scripts\n2. Capture actual execution plan (Ctrl+M in SSMS, then run query)\n3. Look for:\n   - Table scans / Index scans on large tables\n   - Missing index suggestions\n   - Implicit conversions\n   - Key lookups\n   - Sort/Hash operations\n4. Add appropriate indexes\n5. Update statistics: EXEC sp_updatestats\n6. Consider query rewrite if needed\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance/execution-plans\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-query-stats-transact-sql\"\n                )\n                RawData = $queryTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Top Slow Queries\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not analyze queries\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 26\n        \n        # ============================================================================\n        # CHECK 27: BLOCKING SESSIONS (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 27 -CheckName \"Blocking Sessions\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [27/$totalChecks] Checking for blocking sessions...\"\n        \n        try {\n            $blocking = Get-DbaProcess -SqlInstance $conn | Where-Object { $_.BlockingSpid -gt 0 }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Blocking Sessions\"\n                Status = if ($blocking.Count -eq 0) { \"✅ Pass\" } elseif ($blocking.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($blocking.Count -eq 0) { \"Pass\" } elseif ($blocking.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies sessions that are blocking other sessions\"\n                Impact = \"Blocking occurs when one session holds locks that another session needs, causing the second session to wait. Excessive blocking leads to query timeouts, poor performance, and user complaints. Can indicate long-running transactions or missing indexes.\"\n                CurrentValue = @{\n                    BlockedSessionCount = $blocking.Count\n                }\n                RecommendedAction = if ($blocking.Count -eq 0) { \"No blocking detected\" } else { \"Investigate and resolve blocking chains\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get current blocking\nGet-DbaProcess -SqlInstance '$serverName' | \n    Where-Object { `$_.BlockingSpid -gt 0 } |\n    Select-Object Spid, BlockingSpid, Login, Database, Program, Status, Command |\n    Format-Table\n\n# Get blocking tree\nGet-DbaBlockingChain -SqlInstance '$serverName'\n\n# Kill blocking session (use with caution!)\n# Stop-DbaProcess -SqlInstance '$serverName' -Spid 123 -Confirm:`$false\n\"@\n                    TSQL = @\"\n-- Find blocking sessions\nSELECT \n    blocked.session_id AS BlockedSessionID,\n    blocking.session_id AS BlockingSessionID,\n    DB_NAME(blocked.database_id) AS DatabaseName,\n    blocked.wait_type,\n    blocked.wait_time / 1000 AS wait_time_seconds,\n    blocked.wait_resource,\n    blocking_text.text AS BlockingQuery,\n    blocked_text.text AS BlockedQuery\nFROM sys.dm_exec_requests blocked\nINNER JOIN sys.dm_exec_requests blocking ON blocked.blocking_session_id = blocking.session_id\nCROSS APPLY sys.dm_exec_sql_text(blocking.sql_handle) blocking_text\nCROSS APPLY sys.dm_exec_sql_text(blocked.sql_handle) blocked_text\nWHERE blocked.blocking_session_id > 0;\n\n-- Get blocking chain\nWITH BlockingChain AS (\n    SELECT \n        session_id,\n        blocking_session_id,\n        wait_type,\n        wait_time,\n        0 AS Level\n    FROM sys.dm_exec_requests\n    WHERE blocking_session_id = 0\n    AND session_id IN (SELECT blocking_session_id FROM sys.dm_exec_requests WHERE blocking_session_id > 0)\n    \n    UNION ALL\n    \n    SELECT \n        r.session_id,\n        r.blocking_session_id,\n        r.wait_type,\n        r.wait_time,\n        bc.Level + 1\n    FROM sys.dm_exec_requests r\n    INNER JOIN BlockingChain bc ON r.blocking_session_id = bc.session_id\n)\nSELECT * FROM BlockingChain ORDER BY Level, session_id;\n\n-- Kill session (use carefully!)\n-- KILL 123;\n\"@\n                    Manual = @\"\n1. Identify head blocker (session blocking others but not blocked itself)\n2. Check what the head blocker is doing\n3. Options:\n   - Wait for transaction to complete\n   - Kill the blocking session if appropriate (KILL spid)\n   - Optimize queries to reduce transaction duration\n   - Add READ UNCOMMITTED or NOLOCK hints (if dirty reads acceptable)\n   - Review locking strategy and isolation levels\n4. Long-term: Add indexes, reduce transaction scope, use snapshot isolation\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide\",\n                    \"https://learn.microsoft.com/en-us/troubleshoot/sql/database-engine/performance/understand-resolve-blocking\"\n                )\n                RawData = $blocking | Select-Object Spid, BlockingSpid, Login, Database, Command, Status\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Blocking Sessions\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check blocking\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 27\n        \n        # ============================================================================\n        # CHECK 28: DISK I/O LATENCY (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 28 -CheckName \"Disk I/O Latency\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [28/$totalChecks] Checking disk I/O latency...\"\n        \n        try {\n            $query = @\"\nSELECT \n    DB_NAME(vfs.database_id) AS DatabaseName,\n    mf.physical_name,\n    vfs.num_of_reads,\n    vfs.num_of_writes,\n    CASE WHEN vfs.num_of_reads = 0 THEN 0 ELSE vfs.io_stall_read_ms / vfs.num_of_reads END AS avg_read_latency_ms,\n    CASE WHEN vfs.num_of_writes = 0 THEN 0 ELSE vfs.io_stall_write_ms / vfs.num_of_writes END AS avg_write_latency_ms\nFROM sys.dm_io_virtual_file_stats(NULL, NULL) vfs\nINNER JOIN sys.master_files mf ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id\nWHERE vfs.num_of_reads > 0 OR vfs.num_of_writes > 0\nORDER BY (CASE WHEN vfs.num_of_reads = 0 THEN 0 ELSE vfs.io_stall_read_ms / vfs.num_of_reads END) DESC;\n\"@\n            $ioLatency = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            $maxReadLatency = ($ioLatency | Measure-Object -Property avg_read_latency_ms -Maximum).Maximum\n            $maxWriteLatency = ($ioLatency | Measure-Object -Property avg_write_latency_ms -Maximum).Maximum\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Disk I/O Latency\"\n                Status = if ($maxReadLatency -lt 20 -and $maxWriteLatency -lt 20) { \"✅ Pass\" } elseif ($maxReadLatency -lt 50 -and $maxWriteLatency -lt 50) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($maxReadLatency -lt 20 -and $maxWriteLatency -lt 20) { \"Pass\" } elseif ($maxReadLatency -lt 50 -and $maxWriteLatency -lt 50) { \"Warning\" } else { \"Error\" }\n                Description = \"Measures disk I/O response times\"\n                Impact = @\"\nHigh disk latency directly impacts query performance. Acceptable latency:\n- Excellent: <10ms read, <5ms write\n- Good: 10-20ms read, 5-10ms write\n- Fair: 20-50ms read, 10-20ms write\n- Poor: >50ms read, >20ms write\n\nHigh latency causes PAGEIOLATCH waits, slow queries, and poor user experience. Often indicates storage issues or memory pressure.\n\"@\n                CurrentValue = @{\n                    MaxReadLatencyMs = [math]::Round($maxReadLatency, 2)\n                    MaxWriteLatencyMs = [math]::Round($maxWriteLatency, 2)\n                }\n                RecommendedAction = if ($maxReadLatency -lt 20 -and $maxWriteLatency -lt 20) { \"Disk I/O performance is good\" } else { \"Investigate and improve disk I/O performance\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get I/O latency statistics\nGet-DbaDiskSpace -ComputerName '$serverName'\n\n# Detailed I/O stats\n`$query = @'\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    file_id,\n    io_stall_read_ms,\n    num_of_reads,\n    CASE WHEN num_of_reads = 0 THEN 0 ELSE io_stall_read_ms / num_of_reads END AS avg_read_latency_ms,\n    io_stall_write_ms,\n    num_of_writes,\n    CASE WHEN num_of_writes = 0 THEN 0 ELSE io_stall_write_ms / num_of_writes END AS avg_write_latency_ms\nFROM sys.dm_io_virtual_file_stats(NULL, NULL)\nWHERE num_of_reads > 0 OR num_of_writes > 0\nORDER BY avg_read_latency_ms DESC\n'@\n\nInvoke-DbaQuery -SqlInstance '$serverName' -Query `$query | Format-Table\n\"@\n                    TSQL = @\"\n-- Detailed I/O latency by database file\nSELECT \n    DB_NAME(vfs.database_id) AS DatabaseName,\n    mf.physical_name,\n    mf.type_desc AS FileType,\n    vfs.num_of_reads,\n    vfs.num_of_writes,\n    vfs.io_stall_read_ms,\n    vfs.io_stall_write_ms,\n    CASE WHEN vfs.num_of_reads = 0 THEN 0 \n         ELSE vfs.io_stall_read_ms / vfs.num_of_reads END AS avg_read_latency_ms,\n    CASE WHEN vfs.num_of_writes = 0 THEN 0 \n         ELSE vfs.io_stall_write_ms / vfs.num_of_writes END AS avg_write_latency_ms,\n    (vfs.io_stall_read_ms + vfs.io_stall_write_ms) / \n        NULLIF(vfs.num_of_reads + vfs.num_of_writes, 0) AS avg_total_latency_ms\nFROM sys.dm_io_virtual_file_stats(NULL, NULL) vfs\nINNER JOIN sys.master_files mf ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id\nWHERE vfs.num_of_reads > 0 OR vfs.num_of_writes > 0\nORDER BY avg_total_latency_ms DESC;\n\"@\n                    Manual = @\"\n1. Check storage hardware performance\n2. Verify RAID configuration (RAID 10 recommended for logs, RAID 5/6/10 for data)\n3. Separate data and log files on different physical disks\n4. Add more RAM to reduce disk I/O via buffer cache\n5. Consider SSD/NVMe storage for better performance\n6. Check for disk queue length in OS performance monitor\n7. Optimize queries to reduce I/O (add indexes, update statistics)\n8. Review file placement - ensure files on fastest available storage\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-io-virtual-file-stats-transact-sql\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/policy-based-management/monitor-and-enforce-best-practices-by-using-policy-based-management\"\n                )\n                RawData = $ioLatency | Select-Object DatabaseName, physical_name, avg_read_latency_ms, avg_write_latency_ms\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Disk I/O Latency\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check I/O latency\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 28\n        \n        # ============================================================================\n        # CHECK 29: CPU PRESSURE (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 29 -CheckName \"CPU Pressure\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [29/$totalChecks] Checking CPU pressure...\"\n        \n        try {\n            $query = @\"\nSELECT \n    @@CPU_BUSY / (@@TIMETICKS / 1000.0) AS cpu_busy_time_ms,\n    @@IDLE / (@@TIMETICKS / 1000.0) AS idle_time_ms,\n    @@CPU_BUSY * 100.0 / (@@CPU_BUSY + @@IDLE) AS cpu_utilization_pct\n\"@\n            $cpuStats = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            $cpuPct = [math]::Round($cpuStats.cpu_utilization_pct, 2)\n            \n            # Convert to simple formatted table\n            $cpuTable = @()\n            $cpuTable += [PSCustomObject]@{\n                CPUBusyTimeMs = [math]::Round($cpuStats.cpu_busy_time_ms, 2)\n                IdleTimeMs = [math]::Round($cpuStats.idle_time_ms, 2)\n                CPUUtilization = \"$($cpuPct)%\"\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"CPU Pressure\"\n                Status = if ($cpuPct -lt 70) { \"✅ Pass\" } elseif ($cpuPct -lt 85) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($cpuPct -lt 70) { \"Pass\" } elseif ($cpuPct -lt 85) { \"Warning\" } else { \"Error\" }\n                Description = \"Monitors CPU utilization and pressure\"\n                Impact = \"High CPU utilization (>80% sustained) causes slow query response, increased wait times (SOS_SCHEDULER_YIELD), and can lead to query timeouts. Often caused by poorly optimized queries, missing indexes, excessive parallelism, or insufficient CPU resources.\"\n                CurrentValue = @{\n                    CPUUtilizationPercent = $cpuPct\n                }\n                RecommendedAction = if ($cpuPct -lt 70) { \"CPU utilization is healthy\" } else { \"Investigate and reduce CPU pressure\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get CPU-intensive queries\nGet-DbaTopResourceUsage -SqlInstance '$serverName' -Type CPU -Limit 20 |\n    Select-Object ExecutionCount, TotalCPU, AvgCPU, DatabaseName |\n    Format-Table\n\n# Monitor CPU over time\n`$counter = Get-DbaPerformanceCounter -SqlInstance '$serverName' -Counter 'Processor:% Processor Time:_Total'\n`$counter\n\n# Get current CPU usage\nGet-DbaCpuUsage -SqlInstance '$serverName'\n\"@\n                    TSQL = @\"\n-- Top CPU-consuming queries\nSELECT TOP 20\n    qs.execution_count,\n    qs.total_worker_time / 1000 AS total_cpu_time_ms,\n    qs.total_worker_time / qs.execution_count / 1000 AS avg_cpu_time_ms,\n    qs.total_elapsed_time / qs.execution_count / 1000 AS avg_elapsed_time_ms,\n    SUBSTRING(st.text, (qs.statement_start_offset/2)+1,\n        ((CASE qs.statement_end_offset\n            WHEN -1 THEN DATALENGTH(st.text)\n            ELSE qs.statement_end_offset\n        END - qs.statement_start_offset)/2) + 1) AS query_text\nFROM sys.dm_exec_query_stats qs\nCROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st\nORDER BY qs.total_worker_time DESC;\n\n-- Check for SOS_SCHEDULER_YIELD waits (CPU pressure indicator)\nSELECT \n    wait_type,\n    waiting_tasks_count,\n    wait_time_ms,\n    wait_time_ms * 100.0 / SUM(wait_time_ms) OVER() AS percentage\nFROM sys.dm_os_wait_stats\nWHERE wait_type = 'SOS_SCHEDULER_YIELD'\nAND wait_time_ms > 0;\n\n-- Check MAXDOP setting\nEXEC sp_configure 'max degree of parallelism';\n\"@\n                    Manual = @\"\n1. Identify CPU-intensive queries using above scripts\n2. Optimize queries:\n   - Add missing indexes\n   - Update statistics\n   - Rewrite inefficient queries\n   - Reduce data scans\n3. Review MAXDOP settings (consider setting to number of physical cores)\n4. Consider query hints to limit parallelism for specific queries\n5. Add more CPU cores if consistently high (>80%)\n6. Implement resource governor to limit CPU for specific workloads\n7. Schedule heavy batch jobs during off-peak hours\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance/monitor-and-tune-for-performance\",\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option\"\n                )\n                RawData = $cpuTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"CPU Pressure\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check CPU pressure\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 29\n        \n        # ============================================================================\n        # CHECK 30: MEMORY PRESSURE (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 30 -CheckName \"Memory Pressure\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [30/$totalChecks] Checking memory pressure...\"\n        \n        try {\n            $query = @\"\nSELECT \n    (SELECT TOP 1 cntr_value FROM sys.dm_os_performance_counters WHERE counter_name = 'Page life expectancy' ORDER BY cntr_value DESC) AS page_life_expectancy,\n    (SELECT TOP 1 cntr_value FROM sys.dm_os_performance_counters WHERE counter_name = 'Lazy writes/sec' AND object_name LIKE '%Buffer Manager%') AS lazy_writes_per_sec,\n    (SELECT TOP 1 cntr_value FROM sys.dm_os_performance_counters WHERE counter_name = 'Page reads/sec' AND object_name LIKE '%Buffer Manager%') AS page_reads_per_sec,\n    (SELECT SUM(pages_kb) FROM sys.dm_os_memory_clerks WHERE type = 'MEMORYCLERK_SQLBUFFERPOOL') / 1024 AS buffer_pool_mb\n\"@\n            $memStats = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            $ple = $memStats.page_life_expectancy\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Memory Pressure\"\n                Status = if ($ple -gt 300) { \"✅ Pass\" } elseif ($ple -gt 100) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($ple -gt 300) { \"Pass\" } elseif ($ple -gt 100) { \"Warning\" } else { \"Error\" }\n                Description = \"Monitors memory pressure using Page Life Expectancy and other indicators\"\n                Impact = @\"\nPage Life Expectancy (PLE) measures how long pages stay in buffer cache before being flushed:\n- Excellent: >300 seconds\n- Good: 150-300 seconds\n- Warning: 100-150 seconds\n- Critical: <100 seconds\n\nLow PLE indicates memory pressure, causing:\n- Increased disk I/O (PAGEIOLATCH waits)\n- Poor query performance\n- Buffer cache thrashing\n- High lazy writes\n\"@\n                CurrentValue = @{\n                    PageLifeExpectancy = $ple\n                    LazyWritesPerSec = $memStats.lazy_writes_per_sec\n                    PageReadsPerSec = $memStats.page_reads_per_sec\n                    BufferPoolMB = [math]::Round($memStats.buffer_pool_mb, 0)\n                }\n                RecommendedAction = if ($ple -gt 300) { \"Memory pressure is acceptable\" } else { \"Increase SQL Server max memory or add more RAM\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get memory configuration\nGet-DbaMaxMemory -SqlInstance '$serverName'\n\n# Set max memory (leave 4GB for OS on dedicated server)\n`$totalMemoryGB = (Get-DbaCmObject -ComputerName '$serverName' -Class Win32_ComputerSystem).TotalPhysicalMemory / 1GB\n`$maxMemoryMB = (`$totalMemoryGB - 4) * 1024\nSet-DbaMaxMemory -SqlInstance '$serverName' -MaxMB `$maxMemoryMB\n\n# Monitor memory usage\nGet-DbaMemoryUsage -SqlInstance '$serverName'\n\n# Check for memory clerks consuming memory\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT TOP 20\n    type,\n    SUM(pages_kb) / 1024 AS size_mb\nFROM sys.dm_os_memory_clerks\nGROUP BY type\nORDER BY SUM(pages_kb) DESC\n'@\n\"@\n                    TSQL = @\"\n-- Page Life Expectancy\nSELECT \n    object_name,\n    counter_name,\n    cntr_value AS page_life_expectancy_seconds\nFROM sys.dm_os_performance_counters\nWHERE counter_name = 'Page life expectancy';\n\n-- Memory pressure indicators\nSELECT \n    counter_name,\n    cntr_value\nFROM sys.dm_os_performance_counters\nWHERE object_name LIKE '%Buffer Manager%'\nAND counter_name IN (\n    'Page life expectancy',\n    'Lazy writes/sec',\n    'Page reads/sec',\n    'Page writes/sec',\n    'Checkpoint pages/sec'\n);\n\n-- Memory clerks\nSELECT TOP 20\n    type,\n    SUM(pages_kb) / 1024 AS size_mb\nFROM sys.dm_os_memory_clerks\nGROUP BY type\nORDER BY size_mb DESC;\n\n-- Check max server memory\nEXEC sp_configure 'max server memory';\n\"@\n                    Manual = @\"\n1. Monitor PLE over time - look for trends\n2. Add more RAM to the server\n3. Increase max server memory setting (leave 4-6GB for OS)\n4. Reduce unnecessary memory usage:\n   - Review ad-hoc query plans (enable 'optimize for ad hoc workloads')\n   - Clear procedure cache if needed (DBCC FREEPROCCACHE)\n   - Identify memory-intensive queries\n5. Optimize queries to reduce memory grants\n6. Consider adding more frequent index maintenance\n7. Review data compression options\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance-monitor/sql-server-buffer-manager-object\",\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/server-memory-server-configuration-options\"\n                )\n                RawData = $memStats\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Memory Pressure\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check memory pressure\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 30\n        \n        # ============================================================================\n        # CHECK 31: DEADLOCK HISTORY (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 31 -CheckName \"Deadlock History\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [31/$totalChecks] Checking deadlock history...\"\n        \n        try {\n            # Check for deadlock extended events session\n            $deadlockQuery = @\"\nSELECT \n    CAST(target_data AS XML) AS deadlock_xml\nFROM sys.dm_xe_session_targets st\nINNER JOIN sys.dm_xe_sessions s ON s.address = st.event_session_address\nWHERE s.name = 'system_health'\nAND st.target_name = 'ring_buffer';\n\"@\n            $deadlockData = Invoke-DbaQuery -SqlInstance $conn -Query $deadlockQuery\n            \n            # Count deadlocks from system health (simplified approach)\n            $deadlockCount = 0\n            if ($deadlockData -and $deadlockData.deadlock_xml) {\n                $xmlData = [xml]$deadlockData.deadlock_xml\n                $deadlockEvents = $xmlData.SelectNodes(\"//event[@name='xml_deadlock_report']\")\n                $deadlockCount = $deadlockEvents.Count\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Deadlock History\"\n                Status = if ($deadlockCount -eq 0) { \"✅ Pass\" } elseif ($deadlockCount -lt 10) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($deadlockCount -eq 0) { \"Pass\" } elseif ($deadlockCount -lt 10) { \"Warning\" } else { \"Error\" }\n                Description = \"Analyzes deadlock occurrences from system health session\"\n                Impact = \"Deadlocks occur when two or more transactions block each other by holding locks on resources the other transactions need. This causes SQL Server to kill one transaction (deadlock victim) to resolve the deadlock. Frequent deadlocks indicate poor application design, missing indexes, or improper locking strategies.\"\n                CurrentValue = @{\n                    DeadlockCount = $deadlockCount\n                }\n                RecommendedAction = if ($deadlockCount -eq 0) { \"No deadlocks detected\" } elseif ($deadlockCount -lt 10) { \"Review and minimize deadlocks\" } else { \"Investigate and resolve frequent deadlocks\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get deadlock information from system health\n`$query = @'\nWITH DeadlockData AS (\n    SELECT \n        CAST(target_data AS XML) AS TargetData\n    FROM sys.dm_xe_session_targets st\n    INNER JOIN sys.dm_xe_sessions s ON s.address = st.event_session_address\n    WHERE s.name = ''system_health''\n    AND st.target_name = ''ring_buffer''\n)\nSELECT \n    event_data.value(''(@timestamp)[1]'', ''datetime2'') AS DeadlockTime,\n    event_data.query(''.'') AS DeadlockGraph\nFROM DeadlockData\nCROSS APPLY TargetData.nodes(''//RingBufferTarget/event[@name=\"\"xml_deadlock_report\"\"]'') AS XEventData(event_data)\nORDER BY DeadlockTime DESC\n'@\n\nInvoke-DbaQuery -SqlInstance '$serverName' -Query `$query\n\n# Enable deadlock trace flag for detailed logging\n# Invoke-DbaQuery -SqlInstance '$serverName' -Query 'DBCC TRACEON(1222, -1)'\n\"@\n                    TSQL = @\"\n-- Get recent deadlocks from system health\nWITH DeadlockData AS (\n    SELECT \n        CAST(target_data AS XML) AS TargetData\n    FROM sys.dm_xe_session_targets st\n    INNER JOIN sys.dm_xe_sessions s ON s.address = st.event_session_address\n    WHERE s.name = 'system_health'\n    AND st.target_name = 'ring_buffer'\n)\nSELECT \n    event_data.value('(@timestamp)[1]', 'datetime2') AS DeadlockTime,\n    event_data.query('.') AS DeadlockGraph\nFROM DeadlockData\nCROSS APPLY TargetData.nodes('//RingBufferTarget/event[@name=\"xml_deadlock_report\"]') AS XEventData(event_data)\nORDER BY DeadlockTime DESC;\n\n-- Enable deadlock trace flag (persists until restart)\nDBCC TRACEON(1222, -1);\n\n-- Create extended event session for deadlock monitoring\nCREATE EVENT SESSION [DeadlockMonitoring] ON SERVER \nADD EVENT sqlserver.xml_deadlock_report\nADD TARGET package0.event_file(SET filename=N'C:\\\\DeadlockMonitoring.xel')\nWITH (MAX_MEMORY=4096 KB, EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS, \n      MAX_DISPATCH_LATENCY=30 SECONDS, MAX_EVENT_SIZE=0 KB, \n      MEMORY_PARTITION_MODE=NONE, TRACK_CAUSALITY=OFF, STARTUP_STATE=ON);\nGO\n\nALTER EVENT SESSION [DeadlockMonitoring] ON SERVER STATE = START;\nGO\n\"@\n                    Manual = @\"\n1. Review deadlock graphs in SSMS (look for deadlock icon in error log)\n2. Identify victim and survivor transactions\n3. Common solutions:\n   - Access tables in same order across all transactions\n   - Keep transactions short\n   - Add appropriate indexes to reduce lock escalation\n   - Use NOLOCK hint for read queries (if dirty reads acceptable)\n   - Implement retry logic in application\n   - Use snapshot isolation level\n4. Enable trace flag 1222 for detailed deadlock info in error log\n5. Monitor with Extended Events\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide\",\n                    \"https://learn.microsoft.com/en-us/troubleshoot/sql/database-engine/performance/understand-resolve-sql-server-blocking-problems\"\n                )\n                RawData = @{ DeadlockCount = $deadlockCount }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Deadlock History\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check deadlocks\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 31\n        \n        # ============================================================================\n        # CHECK 32: OBSOLETE DATA TYPES (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 32 -CheckName \"Obsolete Data Types\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [32/$totalChecks] Checking for obsolete data types...\"\n        \n        try {\n            $obsoleteTypes = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    c.name AS ColumnName,\n    ty.name AS DataType\nFROM sys.tables t\nINNER JOIN sys.columns c ON t.object_id = c.object_id\nINNER JOIN sys.types ty ON c.user_type_id = ty.user_type_id\nWHERE ty.name IN ('text', 'ntext', 'image', 'timestamp')\nORDER BY SchemaName, TableName, ColumnName;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $obsoleteTypes += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            Column = $_.ColumnName\n                            DataType = $_.DataType\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Obsolete Data Types\"\n                Status = if ($obsoleteTypes.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($obsoleteTypes.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies usage of deprecated data types (text, ntext, image, timestamp)\"\n                Impact = \"Obsolete data types like text, ntext, and image are deprecated and will be removed in future SQL Server versions. They have limitations (can't be used in variables, parameters, poor performance) and should be replaced with varchar(max), nvarchar(max), and varbinary(max). The timestamp data type is confusing (it's not a date/time) and should be rowversion.\"\n                CurrentValue = @{\n                    ObsoleteColumnCount = $obsoleteTypes.Count\n                }\n                RecommendedAction = if ($obsoleteTypes.Count -eq 0) { \"No obsolete data types found\" } else { \"Migrate to modern data types: varchar(max), nvarchar(max), varbinary(max), rowversion\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find obsolete data types\n`$query = @'\nSELECT \n    DB_NAME() AS DatabaseName,\n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    c.name AS ColumnName,\n    ty.name AS DataType\nFROM sys.tables t\nINNER JOIN sys.columns c ON t.object_id = c.object_id\nINNER JOIN sys.types ty ON c.user_type_id = ty.user_type_id\nWHERE ty.name IN (''text'', ''ntext'', ''image'', ''timestamp'')\n'@\n\nInvoke-DbaQuery -SqlInstance '$serverName' -Query `$query | Format-Table\n\"@\n                    TSQL = @\"\n-- Find all obsolete data types\nSELECT \n    DB_NAME() AS DatabaseName,\n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    c.name AS ColumnName,\n    ty.name AS OldDataType,\n    CASE ty.name\n        WHEN 'text' THEN 'VARCHAR(MAX)'\n        WHEN 'ntext' THEN 'NVARCHAR(MAX)'\n        WHEN 'image' THEN 'VARBINARY(MAX)'\n        WHEN 'timestamp' THEN 'ROWVERSION'\n    END AS RecommendedType\nFROM sys.tables t\nINNER JOIN sys.columns c ON t.object_id = c.object_id\nINNER JOIN sys.types ty ON c.user_type_id = ty.user_type_id\nWHERE ty.name IN ('text', 'ntext', 'image', 'timestamp');\n\n-- Example migration from text to varchar(max)\nALTER TABLE [SchemaName].[TableName]\nALTER COLUMN [ColumnName] VARCHAR(MAX);\n\n-- Example migration from ntext to nvarchar(max)\nALTER TABLE [SchemaName].[TableName]\nALTER COLUMN [ColumnName] NVARCHAR(MAX);\n\n-- Example migration from image to varbinary(max)\nALTER TABLE [SchemaName].[TableName]\nALTER COLUMN [ColumnName] VARBINARY(MAX);\n\n-- Example migration from timestamp to rowversion\nALTER TABLE [SchemaName].[TableName]\nALTER COLUMN [ColumnName] ROWVERSION;\n\"@\n                    Manual = @\"\n1. Test migration in non-production environment first\n2. Check for dependencies (views, stored procedures, triggers)\n3. Create backup before migration\n4. Migration steps:\n   - text → VARCHAR(MAX)\n   - ntext → NVARCHAR(MAX)\n   - image → VARBINARY(MAX)\n   - timestamp → ROWVERSION\n5. Update application code to handle new data types\n6. Test thoroughly before production deployment\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/data-types/ntext-text-and-image-transact-sql\",\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/deprecated-database-engine-features-in-sql-server-2016\"\n                )\n                RawData = $obsoleteTypes | Select-Object Database, Schema, Table, Column, DataType\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Obsolete Data Types\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check data types\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 32\n        \n        # ============================================================================\n        # CHECK 33: ERROR LOG ANALYSIS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 33 -CheckName \"Error Log Analysis\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [33/$totalChecks] Analyzing error log...\"\n        \n        try {\n            # Get recent error log entries using sp_readerrorlog (much faster than Get-DbaErrorLog)\n            $query = @\"\nDECLARE @StartDate DATETIME = DATEADD(DAY, -1, GETDATE());\n\nCREATE TABLE #ErrorLog (\n    LogDate DATETIME,\n    ProcessInfo NVARCHAR(50),\n    [Text] NVARCHAR(MAX)\n);\n\nINSERT INTO #ErrorLog\nEXEC sp_readerrorlog 0, 1;\n\nSELECT \n    LogDate,\n    ProcessInfo,\n    [Text],\n    CASE \n        WHEN [Text] LIKE '%severe%' OR [Text] LIKE '%critical%' OR [Text] LIKE '%fatal%' OR [Text] LIKE '%stack dump%' \n        THEN 1 \n        ELSE 0 \n    END AS IsCritical\nFROM #ErrorLog\nWHERE LogDate >= @StartDate\nAND (\n    [Text] LIKE '%error%' OR \n    [Text] LIKE '%failed%' OR \n    [Text] LIKE '%failure%' OR \n    [Text] LIKE '%warning%'\n)\nAND [Text] NOT LIKE '%without errors%'\nORDER BY LogDate DESC;\n\nDROP TABLE #ErrorLog;\n\"@\n            $errorLog = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $criticalErrors = $errorLog | Where-Object { $_.IsCritical -eq 1 }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Error Log Analysis\"\n                Status = if ($criticalErrors.Count -eq 0) { \"✅ Pass\" } elseif ($criticalErrors.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($criticalErrors.Count -eq 0) { \"Pass\" } elseif ($criticalErrors.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Reviews SQL Server error log for critical errors and warnings in last 24 hours\"\n                Impact = \"Error logs contain important information about server health, failed logins, corruption, out-of-memory conditions, and other issues. Critical errors can indicate serious problems requiring immediate attention. Regular monitoring prevents small issues from becoming major outages.\"\n                CurrentValue = @{\n                    TotalErrorsLast24h = $errorLog.Count\n                    CriticalErrorCount = $criticalErrors.Count\n                }\n                RecommendedAction = if ($criticalErrors.Count -eq 0) { \"No critical errors in last 24 hours\" } else { \"Review and address critical errors immediately\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get error log entries from last 24 hours\nGet-DbaErrorLog -SqlInstance '$serverName' -After (Get-Date).AddDays(-1) |\n    Where-Object { `$_.Text -match 'error|failed|failure' } |\n    Select-Object LogDate, Source, Text |\n    Format-Table -AutoSize\n\n# Get login failures (potential security issue)\nGet-DbaErrorLog -SqlInstance '$serverName' -After (Get-Date).AddDays(-1) |\n    Where-Object { `$_.Text -match 'Login failed' } |\n    Select-Object LogDate, Text\n\n# Search for specific error\nGet-DbaErrorLog -SqlInstance '$serverName' -Text 'corruption'\n\n# Cycle error log (creates new log file)\nInvoke-DbaQuery -SqlInstance '$serverName' -Query 'EXEC sp_cycle_errorlog'\n\"@\n                    TSQL = @\"\n-- Read current error log\nEXEC sp_readerrorlog 0, 1;\n\n-- Search for failed logins\nEXEC sp_readerrorlog 0, 1, 'Login failed';\n\n-- Search for severity 17+ errors\nEXEC sp_readerrorlog 0, 1, 'Severity: 17';\nEXEC sp_readerrorlog 0, 1, 'Severity: 18';\nEXEC sp_readerrorlog 0, 1, 'Severity: 19';\nEXEC sp_readerrorlog 0, 1, 'Severity: 20';\n\n-- Cycle error log\nEXEC sp_cycle_errorlog;\n\n-- Configure number of error log files to keep\nEXEC xp_instance_regwrite \n    N'HKEY_LOCAL_MACHINE', \n    N'Software\\\\Microsoft\\\\MSSQLServer\\\\MSSQLServer',\n    N'NumErrorLogs', REG_DWORD, 30;\n\"@\n                    Manual = @\"\n1. Review error log daily for critical issues\n2. Common items to look for:\n   - Failed login attempts (security)\n   - I/O errors (hardware issues)\n   - Out of memory errors\n   - Database corruption warnings\n   - SQL Server service restarts\n   - Backup failures\n3. Set up SQL Agent alerts for critical errors\n4. Configure error log to keep more history (default is 6)\n5. Consider third-party monitoring tools\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance/view-the-sql-server-error-log-sql-server-management-studio\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/errors-events/database-engine-events-and-errors\"\n                )\n                RawData = $criticalErrors | Select-Object LogDate, Source, Text -First 20\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Error Log Analysis\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not read error log\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 33\n        \n        # ============================================================================\n        # CHECK 34: FAILED JOBS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 34 -CheckName \"Failed Jobs\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [34/$totalChecks] Checking for failed jobs...\"\n        \n        try {\n            # Get failed jobs in last 24 hours\n            $failedJobs = Get-DbaAgentJobHistory -SqlInstance $conn -StartDate (Get-Date).AddDays(-1) |\n                Where-Object { $_.Status -eq 'Failed' }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Failed Jobs\"\n                Status = if ($failedJobs.Count -eq 0) { \"✅ Pass\" } elseif ($failedJobs.Count -lt 3) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($failedJobs.Count -eq 0) { \"Pass\" } elseif ($failedJobs.Count -lt 3) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies SQL Agent jobs that have failed in the last 24 hours\"\n                Impact = \"Failed jobs can indicate backup failures, maintenance issues, ETL problems, or other critical tasks not completing. This can lead to data loss, compliance issues, performance degradation, and business process disruptions.\"\n                CurrentValue = @{\n                    FailedJobCount = $failedJobs.Count\n                }\n                RecommendedAction = if ($failedJobs.Count -eq 0) { \"No failed jobs in last 24 hours\" } else { \"Review and fix failed job errors\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Get failed jobs in last 24 hours\nGet-DbaAgentJobHistory -SqlInstance '$serverName' -StartDate (Get-Date).AddDays(-1) |\n    Where-Object { `$_.Status -eq 'Failed' } |\n    Select-Object RunDate, JobName, StepName, Message |\n    Format-Table -AutoSize\n\n# Get job details\nGet-DbaAgentJob -SqlInstance '$serverName' | \n    Select-Object Name, Enabled, LastRunDate, LastRunOutcome |\n    Where-Object { `$_.LastRunOutcome -eq 'Failed' }\n\n# Run specific job manually\nStart-DbaAgentJob -SqlInstance '$serverName' -Job 'JobName'\n\"@\n                    TSQL = @\"\n-- Get failed jobs in last 24 hours\nSELECT \n    j.name AS JobName,\n    h.step_name AS StepName,\n    msdb.dbo.agent_datetime(h.run_date, h.run_time) AS RunDateTime,\n    h.run_duration,\n    CASE h.run_status\n        WHEN 0 THEN 'Failed'\n        WHEN 1 THEN 'Succeeded'\n        WHEN 2 THEN 'Retry'\n        WHEN 3 THEN 'Canceled'\n        WHEN 4 THEN 'In Progress'\n    END AS Status,\n    h.message\nFROM msdb.dbo.sysjobhistory h\nINNER JOIN msdb.dbo.sysjobs j ON h.job_id = j.job_id\nWHERE h.run_status = 0  -- Failed\nAND msdb.dbo.agent_datetime(h.run_date, h.run_time) >= DATEADD(HOUR, -24, GETDATE())\nORDER BY RunDateTime DESC;\n\n-- Get all jobs with last run status\nSELECT \n    j.name AS JobName,\n    j.enabled,\n    CASE ja.last_run_outcome\n        WHEN 0 THEN 'Failed'\n        WHEN 1 THEN 'Succeeded'\n        WHEN 3 THEN 'Canceled'\n        WHEN 5 THEN 'Unknown'\n    END AS LastRunOutcome,\n    msdb.dbo.agent_datetime(ja.last_run_date, ja.last_run_time) AS LastRunDateTime\nFROM msdb.dbo.sysjobs j\nLEFT JOIN msdb.dbo.sysjobactivity ja ON j.job_id = ja.job_id\nWHERE ja.last_run_outcome = 0\nOR ja.last_run_outcome IS NULL;\n\"@\n                    Manual = @\"\n1. Review failed job error messages\n2. Common failure reasons:\n   - Permission issues\n   - Disk space full\n   - Network connectivity problems\n   - Database offline/unavailable\n   - Lock timeouts\n3. Fix underlying issue\n4. Re-run job manually to verify fix\n5. Set up job failure notifications via Database Mail\n6. Review job history regularly\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/ssms/agent/view-job-activity\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-tables/dbo-sysjobhistory-transact-sql\"\n                )\n                RawData = $failedJobs | Select-Object RunDate, JobName, StepName, Message -First 10\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Failed Jobs\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check jobs\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 34\n        \n        # ============================================================================\n        # CHECK 35: AG SYNCHRONIZATION HEALTH (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 35 -CheckName \"AG Synchronization Health\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [35/$totalChecks] Checking AG synchronization health...\"\n        \n        try {\n            # Check if server has availability groups\n            $agReplicas = Get-DbaAgReplica -SqlInstance $conn\n            \n            if ($agReplicas) {\n                $syncIssues = $agReplicas | Where-Object { \n                    $_.SynchronizationHealth -ne 'Healthy' -or \n                    $_.ConnectedState -ne 'Connected' -or\n                    $_.Role -eq 'Unknown'\n                }\n                \n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Synchronization Health\"\n                    Status = if ($syncIssues.Count -eq 0) { \"✅ Pass\" } else { \"❌ Error\" }\n                    Severity = if ($syncIssues.Count -eq 0) { \"Pass\" } else { \"Error\" }\n                    Description = \"Monitors Always On Availability Group replica synchronization health\"\n                    Impact = \"Unhealthy AG synchronization means secondary replicas are not keeping up with the primary, which can lead to data loss during failover, increased RTO/RPO, and inability to use secondaries for read-only workloads. Critical for high availability and disaster recovery.\"\n                    CurrentValue = @{\n                        TotalReplicas = $agReplicas.Count\n                        UnhealthyReplicas = $syncIssues.Count\n                        ReplicaDetails = ($agReplicas | Select-Object Name, Role, SynchronizationHealth, ConnectedState)\n                    }\n                    RecommendedAction = if ($syncIssues.Count -eq 0) { \"All AG replicas are healthy\" } else { \"Investigate and resolve AG synchronization issues immediately\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Get AG replica health\nGet-DbaAgReplica -SqlInstance '$serverName' |\n    Select-Object AvailabilityGroup, Name, Role, SynchronizationHealth, ConnectedState |\n    Format-Table\n\n# Get AG database synchronization state\nGet-DbaAgDatabase -SqlInstance '$serverName' |\n    Select-Object AvailabilityGroup, DatabaseName, SynchronizationState, SynchronizationHealth |\n    Format-Table\n\n# Check data latency\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    ar.replica_server_name,\n    db_name(drs.database_id) AS DatabaseName,\n    drs.synchronization_state_desc,\n    drs.synchronization_health_desc,\n    drs.log_send_queue_size,\n    drs.redo_queue_size\nFROM sys.dm_hadr_database_replica_states drs\nINNER JOIN sys.availability_replicas ar ON drs.replica_id = ar.replica_id\nORDER BY drs.log_send_queue_size DESC\n'@\n\"@\n                        TSQL = @\"\n-- AG replica health overview\nSELECT \n    ar.replica_server_name,\n    ars.role_desc,\n    ars.connected_state_desc,\n    ars.synchronization_health_desc,\n    ars.last_connect_error_description\nFROM sys.dm_hadr_availability_replica_states ars\nINNER JOIN sys.availability_replicas ar ON ars.replica_id = ar.replica_id;\n\n-- AG database synchronization details\nSELECT \n    ar.replica_server_name,\n    DB_NAME(drs.database_id) AS DatabaseName,\n    drs.synchronization_state_desc,\n    drs.synchronization_health_desc,\n    drs.log_send_queue_size AS LogSendQueueKB,\n    drs.log_send_rate AS LogSendRateKB_Per_Sec,\n    drs.redo_queue_size AS RedoQueueKB,\n    drs.redo_rate AS RedoRateKB_Per_Sec,\n    drs.last_commit_time\nFROM sys.dm_hadr_database_replica_states drs\nINNER JOIN sys.availability_replicas ar ON drs.replica_id = ar.replica_id\nORDER BY drs.log_send_queue_size DESC;\n\n-- Check for suspended data movement\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    is_suspended,\n    suspend_reason_desc\nFROM sys.dm_hadr_database_replica_states\nWHERE is_suspended = 1;\n\"@\n                        Manual = @\"\n1. Check network connectivity between replicas\n2. Verify endpoint certificates are valid\n3. Check if data movement is suspended (resume if needed)\n4. Review log send/redo queue sizes:\n   - High log send queue: Network or secondary performance issue\n   - High redo queue: Secondary can't keep up with redo\n5. Consider:\n   - Increase network bandwidth\n   - Improve secondary server performance\n   - Change to asynchronous mode if synchronous is impacting primary\n6. Resume suspended databases: ALTER DATABASE [DB] SET HADR RESUME\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-availability-groups-transact-sql\",\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/troubleshoot-availability-group-exceeded-rpo\"\n                    )\n                    RawData = $agReplicas | Select-Object Name, Role, AvailabilityGroup, SynchronizationHealth, ConnectedState\n                }\n            } else {\n                # No AGs configured - skip check\n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Synchronization Health\"\n                    Status = \"ℹ️ Info\"\n                    Severity = \"Info\"\n                    Description = \"No Availability Groups configured on this server\"\n                    Impact = \"N/A\"\n                    CurrentValue = @{ AGCount = 0 }\n                    RecommendedAction = \"No action needed - server is not part of an Availability Group\"\n                    RemediationSteps = @{}\n                    Documentation = @()\n                    RawData = @{}\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"AG Synchronization Health\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check AG health\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 35\n        \n        # ============================================================================\n        # CHECK 36: AG DATA LATENCY (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 36 -CheckName \"AG Data Latency\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [36/$totalChecks] Checking AG data latency...\"\n        \n        try {\n            $agDatabases = Get-DbaAgDatabase -SqlInstance $conn\n            \n            if ($agDatabases) {\n                # Check for high latency (log send queue or redo queue)\n                $highLatency = $agDatabases | Where-Object {\n                    $_.LogSendQueueSize -gt 10240 -or  # > 10MB\n                    $_.RedoQueueSize -gt 10240          # > 10MB\n                }\n                \n                $maxLogSendQueue = ($agDatabases | Measure-Object -Property LogSendQueueSize -Maximum).Maximum\n                $maxRedoQueue = ($agDatabases | Measure-Object -Property RedoQueueSize -Maximum).Maximum\n                \n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Data Latency\"\n                    Status = if ($highLatency.Count -eq 0) { \"✅ Pass\" } elseif ($highLatency.Count -lt 3) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                    Severity = if ($highLatency.Count -eq 0) { \"Pass\" } elseif ($highLatency.Count -lt 3) { \"Warning\" } else { \"Error\" }\n                    Description = \"Measures data replication latency in Availability Groups\"\n                    Impact = @\"\nHigh AG data latency indicates secondaries are falling behind the primary:\n- Log Send Queue: Data waiting to be sent from primary to secondary (network or primary bottleneck)\n- Redo Queue: Data waiting to be applied on secondary (secondary performance bottleneck)\n\nHigh latency increases RPO (potential data loss on failover), prevents readable secondaries from having current data, and indicates the AG may not meet SLA requirements.\n\"@\n                    CurrentValue = @{\n                        DatabasesWithHighLatency = $highLatency.Count\n                        MaxLogSendQueueKB = [math]::Round($maxLogSendQueue, 0)\n                        MaxRedoQueueKB = [math]::Round($maxRedoQueue, 0)\n                    }\n                    RecommendedAction = if ($highLatency.Count -eq 0) { \"AG latency is acceptable\" } else { \"Investigate and reduce AG replication latency\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check AG latency details\nGet-DbaAgDatabase -SqlInstance '$serverName' |\n    Select-Object AvailabilityGroup, DatabaseName, ReplicaServerName, \n                  LogSendQueueSize, RedoQueueSize, LogSendRate, RedoRate |\n    Where-Object { `$_.LogSendQueueSize -gt 1024 -or `$_.RedoQueueSize -gt 1024 } |\n    Format-Table\n\n# Monitor latency over time\nwhile (`$true) {\n    Get-DbaAgDatabase -SqlInstance '$serverName' |\n        Select-Object DatabaseName, ReplicaServerName, LogSendQueueSize, RedoQueueSize |\n        Format-Table\n    Start-Sleep -Seconds 10\n}\n\"@\n                        TSQL = @\"\n-- Detailed AG latency monitoring\nSELECT \n    ag.name AS AvailabilityGroup,\n    ar.replica_server_name AS ReplicaServer,\n    DB_NAME(drs.database_id) AS DatabaseName,\n    drs.synchronization_state_desc AS SyncState,\n    drs.log_send_queue_size AS LogSendQueueKB,\n    drs.log_send_rate AS LogSendRateKB_Sec,\n    CASE \n        WHEN drs.log_send_rate > 0 \n        THEN drs.log_send_queue_size / drs.log_send_rate \n        ELSE NULL \n    END AS EstimatedLogSendCatchupTime_Sec,\n    drs.redo_queue_size AS RedoQueueKB,\n    drs.redo_rate AS RedoRateKB_Sec,\n    CASE \n        WHEN drs.redo_rate > 0 \n        THEN drs.redo_queue_size / drs.redo_rate \n        ELSE NULL \n    END AS EstimatedRedoCatchupTime_Sec,\n    drs.last_commit_time,\n    drs.last_hardened_time\nFROM sys.dm_hadr_database_replica_states drs\nINNER JOIN sys.availability_replicas ar ON drs.replica_id = ar.replica_id\nINNER JOIN sys.availability_groups ag ON ar.group_id = ag.group_id\nWHERE drs.is_local = 0  -- Remote replicas only\nORDER BY drs.log_send_queue_size DESC;\n\n-- Check estimated data loss (seconds)\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    DATEDIFF(SECOND, last_commit_time, GETDATE()) AS SecondsSinceLastCommit,\n    log_send_queue_size AS LogSendQueueKB\nFROM sys.dm_hadr_database_replica_states\nWHERE is_local = 0\nAND log_send_queue_size > 0;\n\"@\n                        Manual = @\"\n1. Identify bottleneck:\n   - High log send queue: Network or primary disk issue\n   - High redo queue: Secondary CPU/disk/memory issue\n2. For log send queue issues:\n   - Check network bandwidth and latency between replicas\n   - Verify primary server isn't overloaded\n   - Consider compression on AG endpoint\n3. For redo queue issues:\n   - Improve secondary server performance (faster CPU/disk)\n   - Reduce transaction log activity on primary\n   - Consider changing to async mode for distant replicas\n4. Monitor trends - spikes vs. sustained high latency\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/monitor-performance-for-always-on-availability-groups\",\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/troubleshoot-availability-group-exceeded-rpo\"\n                    )\n                    RawData = $agDatabases | Select-Object AvailabilityGroup, DatabaseName, ReplicaServerName, LogSendQueueSize, RedoQueueSize\n                }\n            } else {\n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Data Latency\"\n                    Status = \"ℹ️ Info\"\n                    Severity = \"Info\"\n                    Description = \"No Availability Groups configured\"\n                    Impact = \"N/A\"\n                    CurrentValue = @{ AGCount = 0 }\n                    RecommendedAction = \"No action needed\"\n                    RemediationSteps = @{}\n                    Documentation = @()\n                    RawData = @{}\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"AG Data Latency\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check AG latency\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 36\n        \n        # ============================================================================\n        # CHECK 37: AG FAILOVER READINESS (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 37 -CheckName \"AG Failover Readiness\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [37/$totalChecks] Checking AG failover readiness...\"\n        \n        try {\n            $agReplicas = Get-DbaAgReplica -SqlInstance $conn\n            \n            if ($agReplicas) {\n                # Check for replicas that cannot be automatic failover targets\n                $notReadyForFailover = $agReplicas | Where-Object {\n                    $_.FailoverMode -ne 'Automatic' -or\n                    $_.AvailabilityMode -ne 'SynchronousCommit' -or\n                    ($_.SynchronizationHealth -and $_.SynchronizationHealth -ne 'Healthy')\n                }\n                \n                $automaticFailoverReplicas = $agReplicas | Where-Object { $_.FailoverMode -eq 'Automatic' }\n                \n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Failover Readiness\"\n                    Status = if ($automaticFailoverReplicas.Count -ge 1 -and $notReadyForFailover.Count -eq 0) { \"✅ Pass\" } elseif ($automaticFailoverReplicas.Count -ge 1) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                    Severity = if ($automaticFailoverReplicas.Count -ge 1 -and $notReadyForFailover.Count -eq 0) { \"Pass\" } elseif ($automaticFailoverReplicas.Count -ge 1) { \"Warning\" } else { \"Error\" }\n                    Description = \"Evaluates AG replicas' readiness for automatic failover\"\n                    Impact = \"Automatic failover requires at least one secondary replica configured with synchronous-commit mode and automatic failover mode, and it must be healthy. Without proper failover configuration, the AG cannot automatically recover from primary failure, resulting in downtime until manual intervention.\"\n                    CurrentValue = @{\n                        TotalReplicas = $agReplicas.Count\n                        AutomaticFailoverReplicas = $automaticFailoverReplicas.Count\n                        ReplicasNotReady = $notReadyForFailover.Count\n                    }\n                    RecommendedAction = if ($automaticFailoverReplicas.Count -ge 1 -and $notReadyForFailover.Count -eq 0) { \"AG failover configuration is correct\" } else { \"Configure at least one secondary for automatic failover\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check failover configuration\nGet-DbaAgReplica -SqlInstance '$serverName' |\n    Select-Object AvailabilityGroup, Name, Role, AvailabilityMode, FailoverMode, SynchronizationHealth |\n    Format-Table\n\n# Set replica to automatic failover\nSet-DbaAgReplica -SqlInstance '$serverName' -Replica 'ReplicaName' `\n    -AvailabilityMode SynchronousCommit `\n    -FailoverMode Automatic\n\"@\n                        TSQL = @\"\n-- Check current AG configuration\nSELECT \n    ag.name AS AvailabilityGroup,\n    ar.replica_server_name AS ReplicaServer,\n    ar.availability_mode_desc AS AvailabilityMode,\n    ar.failover_mode_desc AS FailoverMode,\n    ars.role_desc AS CurrentRole,\n    ars.synchronization_health_desc AS SyncHealth\nFROM sys.availability_replicas ar\nINNER JOIN sys.dm_hadr_availability_replica_states ars ON ar.replica_id = ars.replica_id\nINNER JOIN sys.availability_groups ag ON ar.group_id = ag.group_id\nORDER BY ag.name, ar.replica_server_name;\n\n-- Configure replica for automatic failover\nALTER AVAILABILITY GROUP [AGName]\nMODIFY REPLICA ON N'ReplicaServerName'\nWITH (\n    AVAILABILITY_MODE = SYNCHRONOUS_COMMIT,\n    FAILOVER_MODE = AUTOMATIC\n);\n\n-- Test manual failover (does not actually fail over)\nALTER AVAILABILITY GROUP [AGName] FAILOVER;\n\"@\n                        Manual = @\"\n1. Verify at least one secondary replica is configured:\n   - Availability Mode: Synchronous Commit\n   - Failover Mode: Automatic\n   - Synchronization Health: Healthy\n2. For proper HA, configure 2 automatic failover replicas\n3. Test failover regularly during maintenance windows\n4. Document failover procedures\n5. Ensure Windows Server Failover Cluster quorum is healthy\n6. Verify network connectivity between all replicas\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/failover-and-failover-modes-always-on-availability-groups\",\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/perform-a-planned-manual-failover-of-an-availability-group-sql-server\"\n                    )\n                    RawData = $agReplicas | Select-Object Name, AvailabilityGroup, AvailabilityMode, FailoverMode, SynchronizationHealth\n                }\n            } else {\n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Failover Readiness\"\n                    Status = \"ℹ️ Info\"\n                    Severity = \"Info\"\n                    Description = \"No Availability Groups configured\"\n                    Impact = \"N/A\"\n                    CurrentValue = @{ AGCount = 0 }\n                    RecommendedAction = \"No action needed\"\n                    RemediationSteps = @{}\n                    Documentation = @()\n                    RawData = @{}\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"AG Failover Readiness\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check failover readiness\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 37\n        \n        # ============================================================================\n        # CHECK 38: AG LISTENER CONFIGURATION (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 38 -CheckName \"AG Listener Configuration\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [38/$totalChecks] Checking AG listener configuration...\"\n        \n        try {\n            $agListeners = Get-DbaAgListener -SqlInstance $conn\n            $availabilityGroups = Get-DbaAvailabilityGroup -SqlInstance $conn\n            \n            if ($availabilityGroups) {\n                # Check if each AG has a listener\n                $agsWithoutListener = $availabilityGroups | Where-Object {\n                    $agName = $_.Name\n                    -not ($agListeners | Where-Object { $_.AvailabilityGroup -eq $agName })\n                }\n                \n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Listener Configuration\"\n                    Status = if ($agsWithoutListener.Count -eq 0 -and $agListeners.Count -gt 0) { \"✅ Pass\" } elseif ($agListeners.Count -gt 0) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                    Severity = if ($agsWithoutListener.Count -eq 0 -and $agListeners.Count -gt 0) { \"Pass\" } elseif ($agListeners.Count -gt 0) { \"Warning\" } else { \"Error\" }\n                    Description = \"Verifies that Availability Group listeners are properly configured\"\n                    Impact = \"AG listeners provide a virtual network name that client applications connect to, allowing transparent failover. Without listeners, applications must manually update connection strings when a failover occurs. Listeners are essential for seamless HA.\"\n                    CurrentValue = @{\n                        TotalAvailabilityGroups = $availabilityGroups.Count\n                        ConfiguredListeners = $agListeners.Count\n                        AGsWithoutListener = $agsWithoutListener.Count\n                    }\n                    RecommendedAction = if ($agsWithoutListener.Count -eq 0 -and $agListeners.Count -gt 0) { \"All AGs have listeners configured\" } else { \"Configure listeners for all Availability Groups\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# List all AG listeners\nGet-DbaAgListener -SqlInstance '$serverName' |\n    Select-Object AvailabilityGroup, Name, PortNumber, IpAddress |\n    Format-Table\n\n# Create a new listener\nNew-DbaAgListener -SqlInstance '$serverName' `\n    -AvailabilityGroup 'AGName' `\n    -Name 'AGListenerName' `\n    -IPAddress '10.0.0.100' `\n    -SubnetMask '255.255.255.0' `\n    -Port 1433\n\n# Test listener connectivity\nTest-DbaConnection -SqlInstance 'AGListenerName'\n\"@\n                        TSQL = @\"\n-- View all AG listeners\nSELECT \n    ag.name AS AvailabilityGroup,\n    agl.dns_name AS ListenerName,\n    agl.port AS Port,\n    aglip.ip_address AS IPAddress,\n    aglip.ip_subnet_mask AS SubnetMask\nFROM sys.availability_group_listeners agl\nINNER JOIN sys.availability_groups ag ON agl.group_id = ag.group_id\nINNER JOIN sys.availability_group_listener_ip_addresses aglip ON agl.listener_id = aglip.listener_id\nORDER BY ag.name;\n\n-- Create a new listener (run on primary replica)\nALTER AVAILABILITY GROUP [AGName]\nADD LISTENER N'AGListenerName' (\n    WITH IP ((N'10.0.0.100', N'255.255.255.0')),\n    PORT = 1433\n);\n\n-- Test connection to listener\nSELECT @@SERVERNAME AS CurrentServer;\n\"@\n                        Manual = @\"\n1. Plan listener configuration:\n   - Unique DNS name\n   - Static IP address(es) on AG subnet(s)\n   - Port (typically 1433)\n2. Create listener using PowerShell or T-SQL\n3. Configure DNS to resolve listener name\n4. Update client connection strings to use listener name\n5. Test failover to ensure listener redirects properly\n6. Consider read-only routing for read-scale scenarios\n7. Document listener configuration\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/create-or-configure-an-availability-group-listener-sql-server\",\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/listeners-client-connectivity-application-failover\"\n                    )\n                    RawData = $agListeners | Select-Object AvailabilityGroup, Name, PortNumber, IpAddress\n                }\n            } else {\n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"AG Listener Configuration\"\n                    Status = \"ℹ️ Info\"\n                    Severity = \"Info\"\n                    Description = \"No Availability Groups configured\"\n                    Impact = \"N/A\"\n                    CurrentValue = @{ AGCount = 0 }\n                    RecommendedAction = \"No action needed\"\n                    RemediationSteps = @{}\n                    Documentation = @()\n                    RawData = @{}\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"AG Listener Configuration\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check listeners\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 38\n        \n        # ============================================================================\n        # CHECK 39: SMALL DATA TYPES (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 39 -CheckName \"Small Data Types\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [39/$totalChecks] Checking for inefficient small data types...\"\n        \n        try {\n            $smallTypes = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    c.name AS ColumnName,\n    ty.name AS DataType,\n    CASE ty.name\n        WHEN 'tinyint' THEN 'SMALLINT or INT'\n        WHEN 'char' THEN 'VARCHAR'\n        WHEN 'nchar' THEN 'NVARCHAR'\n    END AS SuggestedType\nFROM sys.tables t\nINNER JOIN sys.columns c ON t.object_id = c.object_id\nINNER JOIN sys.types ty ON c.user_type_id = ty.user_type_id\nWHERE ty.name IN ('tinyint', 'char', 'nchar')\nAND c.max_length <= 10\nORDER BY SchemaName, TableName, ColumnName;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $smallTypes += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            Column = $_.ColumnName\n                            DataType = $_.DataType\n                            Suggested = $_.SuggestedType\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Small Data Types\"\n                Status = if ($smallTypes.Count -eq 0) { \"✅ Pass\" } elseif ($smallTypes.Count -lt 20) { \"ℹ️ Info\" } else { \"⚠️ Warning\" }\n                Severity = if ($smallTypes.Count -eq 0) { \"Pass\" } else { \"Info\" }\n                Description = \"Identifies potentially inefficient use of small fixed-width data types\"\n                Impact = @\"\nSmall data types like TINYINT, CHAR, and NCHAR can cause issues:\n- TINYINT: Limited range (0-255), often insufficient and requires ALTER TABLE later\n- CHAR/NCHAR: Fixed width means wasted space with padding, poor for variable-length data\n- Small fixed types can cause more ALTER TABLE operations as business grows\n\nThis is informational - sometimes these types are appropriate, but review usage.\n\"@\n                CurrentValue = @{\n                    SmallTypeColumnCount = $smallTypes.Count\n                }\n                RecommendedAction = if ($smallTypes.Count -eq 0) { \"No concerning small data types found\" } else { \"Review small data types for appropriateness\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find small data types\n`$query = @'\nSELECT \n    DB_NAME() AS DatabaseName,\n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    c.name AS ColumnName,\n    ty.name AS DataType\nFROM sys.tables t\nINNER JOIN sys.columns c ON t.object_id = c.object_id\nINNER JOIN sys.types ty ON c.user_type_id = ty.user_type_id\nWHERE ty.name IN (''tinyint'', ''char'', ''nchar'')\n'@\n\nInvoke-DbaQuery -SqlInstance '$serverName' -Query `$query | Format-Table\n\"@\n                    TSQL = @\"\n-- Review usage of small data types\nSELECT \n    SCHEMA_NAME(t.schema_id) AS SchemaName,\n    t.name AS TableName,\n    c.name AS ColumnName,\n    ty.name AS CurrentDataType,\n    c.max_length,\n    CASE ty.name\n        WHEN 'tinyint' THEN 'Consider SMALLINT or INT if range may grow'\n        WHEN 'char' THEN 'Consider VARCHAR to avoid padding waste'\n        WHEN 'nchar' THEN 'Consider NVARCHAR to avoid padding waste'\n    END AS Recommendation\nFROM sys.tables t\nINNER JOIN sys.columns c ON t.object_id = c.object_id\nINNER JOIN sys.types ty ON c.user_type_id = ty.user_type_id\nWHERE ty.name IN ('tinyint', 'char', 'nchar');\n\n-- Example: Change TINYINT to SMALLINT\nALTER TABLE [SchemaName].[TableName]\nALTER COLUMN [ColumnName] SMALLINT;\n\n-- Example: Change CHAR to VARCHAR\nALTER TABLE [SchemaName].[TableName]\nALTER COLUMN [ColumnName] VARCHAR(50);\n\"@\n                    Manual = @\"\n1. Review each flagged column\n2. Consider:\n   - TINYINT: Is 0-255 range sufficient long-term?\n   - CHAR/NCHAR: Is data truly fixed-width, or is VARCHAR better?\n3. For status codes, TINYINT might be appropriate\n4. For country codes, CHAR(2) is fine (ISO standard)\n5. Change only when beneficial - don't change for the sake of it\n6. Test in dev environment before production changes\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql\",\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/data-types/int-bigint-smallint-and-tinyint-transact-sql\"\n                )\n                RawData = $smallTypes | Select-Object Database, Schema, Table, Column, DataType, Suggested\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Small Data Types\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check data types\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 39\n        \n        # ============================================================================\n        # CHECK 40: DATABASE COMPATIBILITY LEVEL (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 40 -CheckName \"Database Compatibility Level\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [40/$totalChecks] Checking database compatibility levels...\"\n        \n        try {\n            # Get server compatibility level from connection object\n            $serverCompatLevel = switch ($conn.VersionMajor) {\n                9  { 90 }   # SQL 2005\n                10 { 100 }  # SQL 2008/2008R2\n                11 { 110 }  # SQL 2012\n                12 { 120 }  # SQL 2014\n                13 { 130 }  # SQL 2016\n                14 { 140 }  # SQL 2017\n                15 { 150 }  # SQL 2019\n                16 { 160 }  # SQL 2022\n                default { 150 }\n            }\n            \n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            # Build list of all databases with compatibility info\n            $allCompatibility = @()\n            $outdatedCompatibility = @()\n            foreach ($db in $databases) {\n                $isCorrect = $db.CompatibilityLevel -eq $serverCompatLevel\n                \n                $allCompatibility += [PSCustomObject]@{\n                    Database = $db.Name\n                    CurrentCompatibility = $db.CompatibilityLevel\n                    ServerCompatibility = $serverCompatLevel\n                    IsCorrect = $isCorrect\n                    Status = if ($isCorrect) { \"✅ Correct\" } else { \"⚠️ Outdated\" }\n                }\n                \n                if ($db.CompatibilityLevel -lt $serverCompatLevel) {\n                    $outdatedCompatibility += [PSCustomObject]@{\n                        Database = $db.Name\n                        CurrentCompatibility = $db.CompatibilityLevel\n                        ServerCompatibility = $serverCompatLevel\n                        Status = $db.Status\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Database Compatibility Level\"\n                Status = if ($outdatedCompatibility.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($outdatedCompatibility.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Verifies databases are using current SQL Server compatibility level\"\n                Impact = \"Databases with outdated compatibility levels cannot use newer query optimizer improvements, features, or performance enhancements. This can result in suboptimal query plans and missed performance gains. However, upgrading compatibility level can change query behavior, so test thoroughly.\"\n                CurrentValue = @{\n                    ServerCompatibility = $serverCompatLevel\n                    DatabasesWithOldCompatibility = $outdatedCompatibility.Count\n                }\n                RecommendedAction = if ($outdatedCompatibility.Count -eq 0) { \"All databases use current compatibility level\" } else { \"Test and upgrade database compatibility levels\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check compatibility levels\nGet-DbaDatabase -SqlInstance '$serverName' |\n    Select-Object Name, Compatibility, Status |\n    Format-Table\n\n# Upgrade database compatibility (test first!)\nSet-DbaDbCompatibility -SqlInstance '$serverName' -Database 'DatabaseName' -CompatibilityLevel 150\n\n# Use Query Store to monitor after compatibility upgrade\nSet-DbaDbQueryStoreOption -SqlInstance '$serverName' -Database 'DatabaseName' -State ReadWrite\n\"@\n                    TSQL = @\"\n-- Check current compatibility levels\nSELECT \n    name AS DatabaseName,\n    compatibility_level AS CompatibilityLevel,\n    CASE compatibility_level\n        WHEN 80 THEN 'SQL Server 2000'\n        WHEN 90 THEN 'SQL Server 2005'\n        WHEN 100 THEN 'SQL Server 2008/2008R2'\n        WHEN 110 THEN 'SQL Server 2012'\n        WHEN 120 THEN 'SQL Server 2014'\n        WHEN 130 THEN 'SQL Server 2016'\n        WHEN 140 THEN 'SQL Server 2017'\n        WHEN 150 THEN 'SQL Server 2019'\n        WHEN 160 THEN 'SQL Server 2022'\n    END AS CompatibilityVersion\nFROM sys.databases\nWHERE database_id > 4\nORDER BY compatibility_level, name;\n\n-- Upgrade compatibility level (test in dev first!)\nALTER DATABASE [DatabaseName] SET COMPATIBILITY_LEVEL = 150;\n\n-- Enable Query Store before upgrade (recommended)\nALTER DATABASE [DatabaseName] SET QUERY_STORE = ON;\nALTER DATABASE [DatabaseName] SET QUERY_STORE (OPERATION_MODE = READ_WRITE);\n\n-- After upgrade, monitor for regression\n-- Use Query Store to compare pre/post performance\n\"@\n                    Manual = @\"\n1. IMPORTANT: Test compatibility upgrade in non-production first\n2. Enable Query Store before upgrading compatibility\n3. Upgrade procedure:\n   a. Enable Query Store on database\n   b. Run workload to establish baseline\n   c. Upgrade compatibility level\n   d. Monitor Query Store for regressions\n   e. Use Query Store hints to force old plans if needed\n4. Benefits of newer compatibility:\n   - Intelligent Query Processing features\n   - Better cardinality estimator\n   - Adaptive query processing\n   - Scalar UDF inlining\n5. Test for 1-2 weeks before declaring success\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-database-transact-sql-compatibility-level\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing\"\n                )\n                RawData = $allCompatibility\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Database Compatibility Level\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check compatibility levels\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 40\n        \n        # ============================================================================\n        # CHECK 41: SERVER ROLE MEMBERSHIP (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 41 -CheckName \"Server Role Membership\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [41/$totalChecks] Checking server role membership...\"\n        \n        try {\n            # Get members of privileged server roles\n            $query = @\"\nSELECT \n    r.name AS RoleName,\n    m.name AS MemberName,\n    m.type_desc AS MemberType\nFROM sys.server_role_members srm\nINNER JOIN sys.server_principals r ON srm.role_principal_id = r.principal_id\nINNER JOIN sys.server_principals m ON srm.member_principal_id = m.principal_id\nWHERE r.name IN ('sysadmin', 'securityadmin', 'serveradmin', 'setupadmin', 'processadmin')\nAND m.name NOT IN ('sa', '##MS_PolicyEventProcessingLogin##')\nORDER BY r.name, m.name;\n\"@\n            $roleMembers = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            $sysadminMembers = $roleMembers | Where-Object { $_.RoleName -eq 'sysadmin' }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Server Role Membership\"\n                Status = if ($sysadminMembers.Count -le 3) { \"✅ Pass\" } elseif ($sysadminMembers.Count -le 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($sysadminMembers.Count -le 3) { \"Pass\" } elseif ($sysadminMembers.Count -le 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Reviews membership in privileged server roles\"\n                Impact = \"Excessive membership in privileged server roles (especially sysadmin) violates principle of least privilege and creates security risk. Sysadmin role has unrestricted access to all SQL Server resources. Limit membership to only essential accounts and use more granular permissions when possible.\"\n                CurrentValue = @{\n                    TotalPrivilegedMembers = $roleMembers.Count\n                    SysadminMembers = $sysadminMembers.Count\n                }\n                RecommendedAction = if ($sysadminMembers.Count -le 3) { \"Server role membership appears reasonable\" } else { \"Review and reduce privileged role memberships\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List all server role members\nGet-DbaServerRoleMember -SqlInstance '$serverName' |\n    Where-Object { `$_.Role -in @('sysadmin','securityadmin','serveradmin') } |\n    Select-Object Role, Member |\n    Format-Table\n\n# Remove user from sysadmin role\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nALTER SERVER ROLE sysadmin DROP MEMBER [LoginName]\n'@\n\n# Grant more granular permissions instead\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nGRANT VIEW SERVER STATE TO [LoginName]\nGRANT ALTER ANY DATABASE TO [LoginName]\n'@\n\"@\n                    TSQL = @\"\n-- List all privileged role members\nSELECT \n    r.name AS RoleName,\n    m.name AS MemberName,\n    m.type_desc AS MemberType,\n    m.create_date,\n    m.modify_date\nFROM sys.server_role_members srm\nINNER JOIN sys.server_principals r ON srm.role_principal_id = r.principal_id\nINNER JOIN sys.server_principals m ON srm.member_principal_id = m.principal_id\nWHERE r.name IN ('sysadmin', 'securityadmin', 'serveradmin', 'setupadmin', 'processadmin')\nORDER BY r.name, m.name;\n\n-- Remove member from sysadmin role\nALTER SERVER ROLE sysadmin DROP MEMBER [LoginName];\n\n-- Add to less privileged role or grant specific permissions\nALTER SERVER ROLE dbcreator ADD MEMBER [LoginName];\n\n-- Or grant granular permissions\nGRANT VIEW SERVER STATE TO [LoginName];\nGRANT ALTER ANY DATABASE TO [LoginName];\n\"@\n                    Manual = @\"\n1. Review each privileged role member\n2. Verify business justification for elevated access\n3. Remove unnecessary members\n4. Replace sysadmin with more granular permissions when possible:\n   - For DBAs: Consider custom server roles with specific permissions\n   - For app accounts: Use database-level roles instead\n   - For monitoring: VIEW SERVER STATE is often sufficient\n5. Document all privileged access\n6. Implement regular access reviews\n7. Use Windows groups for easier management\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/grant-a-permission-to-a-principal\"\n                )\n                RawData = $roleMembers | Select-Object RoleName, MemberName, MemberType\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Server Role Membership\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check server roles\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 41\n        \n        # ============================================================================\n        # CHECK 42: DATABASE ROLE MEMBERSHIP (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 42 -CheckName \"Database Role Membership\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [42/$totalChecks] Checking database role membership...\"\n        \n        try {\n            $excessiveDbRoles = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    r.name AS RoleName,\n    m.name AS MemberName,\n    m.type_desc AS MemberType\nFROM sys.database_role_members drm\nINNER JOIN sys.database_principals r ON drm.role_principal_id = r.principal_id\nINNER JOIN sys.database_principals m ON drm.member_principal_id = m.principal_id\nWHERE r.name IN ('db_owner', 'db_securityadmin', 'db_accessadmin')\nAND m.name NOT IN ('dbo', 'guest')\nORDER BY r.name, m.name;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $excessiveDbRoles += [PSCustomObject]@{\n                            Database = $db.Name\n                            Role = $_.RoleName\n                            Member = $_.MemberName\n                            MemberType = $_.MemberType\n                        }\n                    }\n                }\n            }\n            \n            $dbOwnerMembers = $excessiveDbRoles | Where-Object { $_.Role -eq 'db_owner' }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Database Role Membership\"\n                Status = if ($dbOwnerMembers.Count -eq 0) { \"✅ Pass\" } elseif ($dbOwnerMembers.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($dbOwnerMembers.Count -eq 0) { \"Pass\" } elseif ($dbOwnerMembers.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Reviews membership in privileged database roles\"\n                Impact = \"Excessive membership in db_owner role violates least privilege principle. db_owner members have full control over the database including ability to drop it, modify security, and access all data. Use more granular roles (db_datareader, db_datawriter, db_ddladmin) when possible.\"\n                CurrentValue = @{\n                    TotalPrivilegedMembers = $excessiveDbRoles.Count\n                    DbOwnerMembers = $dbOwnerMembers.Count\n                }\n                RecommendedAction = if ($dbOwnerMembers.Count -eq 0) { \"Database role membership is appropriate\" } else { \"Review and reduce db_owner role membership\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List database role members\nGet-DbaDbRoleMember -SqlInstance '$serverName' |\n    Where-Object { `$_.Role -eq 'db_owner' } |\n    Select-Object Database, Role, Member |\n    Format-Table\n\n# Remove user from db_owner\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'DatabaseName' -Query @'\nALTER ROLE db_owner DROP MEMBER [UserName]\n'@\n\n# Add to appropriate role instead\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'DatabaseName' -Query @'\nALTER ROLE db_datareader ADD MEMBER [UserName]\nALTER ROLE db_datawriter ADD MEMBER [UserName]\n'@\n\"@\n                    TSQL = @\"\n-- List privileged database role members\nUSE [DatabaseName];\nSELECT \n    r.name AS RoleName,\n    m.name AS MemberName,\n    m.type_desc AS MemberType\nFROM sys.database_role_members drm\nINNER JOIN sys.database_principals r ON drm.role_principal_id = r.principal_id\nINNER JOIN sys.database_principals m ON drm.member_principal_id = m.principal_id\nWHERE r.name IN ('db_owner', 'db_securityadmin', 'db_accessadmin')\nORDER BY r.name, m.name;\n\n-- Remove member from db_owner\nALTER ROLE db_owner DROP MEMBER [UserName];\n\n-- Add to less privileged roles\nALTER ROLE db_datareader ADD MEMBER [UserName];\nALTER ROLE db_datawriter ADD MEMBER [UserName];\n\n-- Grant specific permissions if needed\nGRANT EXECUTE ON SCHEMA::dbo TO [UserName];\nGRANT CREATE TABLE TO [UserName];\n\"@\n                    Manual = @\"\n1. Review each db_owner member\n2. Determine actual permissions needed\n3. Use appropriate built-in roles:\n   - db_datareader: Read all data\n   - db_datawriter: Modify all data\n   - db_ddladmin: DDL operations\n   - db_executor: Execute stored procedures\n4. Or create custom database roles with specific permissions\n5. Remove from db_owner\n6. Test application after permission changes\n7. Document permission model\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/database-level-roles\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/permissions-database-engine\"\n                )\n                RawData = $excessiveDbRoles | Select-Object Database, Role, Member, MemberType\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Database Role Membership\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check database roles\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 42\n        \n        # ============================================================================\n        # CHECK 43: OVERSIZED INDEXES (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 43 -CheckName \"Oversized Indexes\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [43/$totalChecks] Checking for oversized indexes...\"\n        \n        try {\n            $oversizedIndexes = @()\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,\n    OBJECT_NAME(i.object_id) AS TableName,\n    i.name AS IndexName,\n    COUNT(*) AS ColumnCount,\n    SUM(c.max_length) AS TotalKeySize\nFROM sys.indexes i\nINNER JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id\nINNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id\nWHERE i.type IN (1, 2)  -- Clustered and nonclustered\nAND ic.is_included_column = 0  -- Key columns only\nGROUP BY i.object_id, i.name\nHAVING COUNT(*) > 10 OR SUM(c.max_length) > 900\nORDER BY TotalKeySize DESC;\n\"@\n                $result = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                if ($result) {\n                    $result | ForEach-Object { \n                        $oversizedIndexes += [PSCustomObject]@{\n                            Database = $db.Name\n                            Schema = $_.SchemaName\n                            Table = $_.TableName\n                            IndexName = $_.IndexName\n                            ColumnCount = $_.ColumnCount\n                            TotalKeySize = $_.TotalKeySize\n                        }\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Oversized Indexes\"\n                Status = if ($oversizedIndexes.Count -eq 0) { \"✅ Pass\" } elseif ($oversizedIndexes.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($oversizedIndexes.Count -eq 0) { \"Pass\" } elseif ($oversizedIndexes.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies indexes with excessive columns or total key size >900 bytes\"\n                Impact = \"Oversized indexes (>900 bytes key size or >10 key columns) waste space, slow DML operations, and can cause performance issues. SQL Server has a 900-byte limit on index keys (excluding included columns). Large indexes also increase buffer pool pressure and I/O overhead.\"\n                CurrentValue = @{\n                    OversizedIndexCount = $oversizedIndexes.Count\n                }\n                RecommendedAction = if ($oversizedIndexes.Count -eq 0) { \"No oversized indexes found\" } else { \"Review and optimize oversized indexes\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Find oversized indexes\n`$query = @'\nSELECT \n    DB_NAME() AS DatabaseName,\n    OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,\n    OBJECT_NAME(i.object_id) AS TableName,\n    i.name AS IndexName,\n    COUNT(*) AS KeyColumnCount,\n    SUM(c.max_length) AS TotalKeySize\nFROM sys.indexes i\nINNER JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id\nINNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id\nWHERE ic.is_included_column = 0\nGROUP BY i.object_id, i.name\nHAVING COUNT(*) > 10 OR SUM(c.max_length) > 900\n'@\n\nInvoke-DbaQuery -SqlInstance '$serverName' -Query `$query | Format-Table\n\"@\n                    TSQL = @\"\n-- Find oversized indexes with details\nSELECT \n    OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,\n    OBJECT_NAME(i.object_id) AS TableName,\n    i.name AS IndexName,\n    i.type_desc AS IndexType,\n    COUNT(*) AS KeyColumnCount,\n    SUM(c.max_length) AS TotalKeySize,\n    STRING_AGG(c.name, ', ') WITHIN GROUP (ORDER BY ic.key_ordinal) AS KeyColumns\nFROM sys.indexes i\nINNER JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id\nINNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id\nWHERE ic.is_included_column = 0\nGROUP BY i.object_id, i.name, i.type_desc\nHAVING COUNT(*) > 10 OR SUM(c.max_length) > 900\nORDER BY TotalKeySize DESC;\n\n-- Option 1: Drop and recreate with fewer key columns, move extras to INCLUDE\nDROP INDEX [IndexName] ON [SchemaName].[TableName];\n\nCREATE NONCLUSTERED INDEX [IndexName]\nON [SchemaName].[TableName] ([KeyColumn1], [KeyColumn2])\nINCLUDE ([Column3], [Column4], [Column5]);  -- Move these to INCLUDE\n\n-- Option 2: Drop unused oversized index\nDROP INDEX [IndexName] ON [SchemaName].[TableName];\n\"@\n                    Manual = @\"\n1. Review each oversized index\n2. Analyze index usage:\n   - Use sys.dm_db_index_usage_stats\n   - Check if index is actually used\n3. Options to fix:\n   - Move some columns to INCLUDE clause (doesn't count toward 900 byte limit)\n   - Split into multiple smaller indexes\n   - Remove unnecessary columns\n   - Drop if not used\n4. Test query performance after changes\n5. Remember: Wide indexes trade space/write performance for read performance\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/indexes/indexes\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-index-design-guide\"\n                )\n                RawData = $oversizedIndexes | Select-Object Database, Schema, Table, IndexName, ColumnCount, TotalKeySize\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Oversized Indexes\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check indexes\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 43\n        \n        # ============================================================================\n        # CHECK 44: CLUSTER QUORUM (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 44 -CheckName \"Cluster Quorum\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [44/$totalChecks] Checking cluster quorum...\"\n        \n        try {\n            # Check if server is in a Windows cluster\n            $query = @\"\nSELECT \n    SERVERPROPERTY('IsClustered') AS IsClustered,\n    SERVERPROPERTY('IsHadrEnabled') AS IsHadrEnabled;\n\"@\n            $clusterInfo = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            if ($clusterInfo.IsClustered -eq 1) {\n                # Server is clustered - try to get detailed quorum info\n                $quorumDetails = $null\n                $checkMethod = \"T-SQL (basic cluster detection)\"\n                $usedServerAdmin = $false\n                \n                # Try to get cluster member and quorum info via T-SQL\n                try {\n                    $clusterQuery = @\"\nSELECT \n    member_name AS NodeName,\n    member_type_desc AS MemberType,\n    member_state_desc AS State,\n    number_of_quorum_votes AS QuorumVotes\nFROM sys.dm_hadr_cluster_members;\n\"@\n                    $quorumDetails = Invoke-DbaQuery -SqlInstance $conn -Query $clusterQuery\n                    $checkMethod = \"T-SQL (sys.dm_hadr_cluster_members)\"\n                } catch {\n                    # Cannot get cluster details via T-SQL\n                }\n                \n                # Try with server admin credentials if available and T-SQL failed\n                if ($hasServerAdminCreds -and -not $quorumDetails) {\n                    try {\n                        # Extract hostname from SQL Server connection\n                        $computerName = $conn.ComputerNamePhysicalNetBIOS\n                        if ([string]::IsNullOrWhiteSpace($computerName)) {\n                            $computerName = $serverName.Split('\\\\')[0].Split(',')[0]\n                        }\n                        \n                        # Try to get cluster quorum info via CIM/WMI with server admin credentials\n                        try {\n                            # Use Invoke-Command to run Get-ClusterQuorum on the remote server\n                            $scriptBlock = {\n                                try {\n                                    # Check if cluster cmdlets are available\n                                    if (Get-Command Get-ClusterQuorum -ErrorAction SilentlyContinue) {\n                                        $quorum = Get-ClusterQuorum\n                                        $nodes = Get-ClusterNode | Select-Object Name, State, NodeWeight\n                                        \n                                        return @{\n                                            Success = $true\n                                            QuorumType = $quorum.QuorumType.ToString()\n                                            QuorumResource = $quorum.QuorumResource.Name\n                                            Nodes = $nodes\n                                        }\n                                    } else {\n                                        return @{ Success = $false; Error = \"Cluster cmdlets not available\" }\n                                    }\n                                } catch {\n                                    return @{ Success = $false; Error = $_.Exception.Message }\n                                }\n                            }\n                            \n                            $clusterResult = Invoke-Command -ComputerName $computerName -Credential $serverAdminCredential -ScriptBlock $scriptBlock -ErrorAction Stop\n                            \n                            if ($clusterResult.Success) {\n                                $quorumDetails = [pscustomobject]@{\n                                    QuorumType = $clusterResult.QuorumType\n                                    QuorumResource = $clusterResult.QuorumResource\n                                    Nodes = $clusterResult.Nodes\n                                    TotalNodes = $clusterResult.Nodes.Count\n                                    NodesWithVotes = ($clusterResult.Nodes | Where-Object { $_.NodeWeight -gt 0 }).Count\n                                }\n                                $checkMethod = \"PowerShell Remoting with Server Admin credentials\"\n                                $usedServerAdmin = $true\n                                $healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin++\n                            }\n                        } catch {\n                            # PowerShell remoting failed, try CIM\n                            try {\n                                $cimSession = New-CimSession -ComputerName $computerName -Credential $serverAdminCredential -ErrorAction Stop\n                                $clusterNodes = Get-CimInstance -CimSession $cimSession -Namespace \"root\\MSCluster\" -ClassName \"MSCluster_Node\" -ErrorAction Stop\n                                \n                                if ($clusterNodes) {\n                                    $quorumDetails = [pscustomobject]@{\n                                        QuorumType = \"Retrieved via CIM\"\n                                        Nodes = $clusterNodes | Select-Object Name, State\n                                        TotalNodes = $clusterNodes.Count\n                                    }\n                                    $checkMethod = \"CIM/WMI with Server Admin credentials\"\n                                    $usedServerAdmin = $true\n                                    $healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin++\n                                }\n                                \n                                Remove-CimSession -CimSession $cimSession -ErrorAction SilentlyContinue\n                            } catch {\n                                # CIM also failed - server admin creds didn't help\n                            }\n                        }\n                    } catch {\n                        # Server admin access didn't help\n                    }\n                }\n                \n                # Determine status based on what we found\n                if ($quorumDetails) {\n                    # Build CurrentValue based on data source\n                    $currentValue = @{\n                        IsClustered = $true\n                        IsHadrEnabled = $clusterInfo.IsHadrEnabled -eq 1\n                        CheckMethod = $checkMethod\n                        ServerAdminUsed = $usedServerAdmin\n                    }\n                    \n                    # Add appropriate fields based on data source\n                    if ($quorumDetails.QuorumType) {\n                        # Data from PowerShell/CIM (server admin)\n                        $currentValue['QuorumType'] = $quorumDetails.QuorumType\n                        if ($quorumDetails.QuorumResource) {\n                            $currentValue['QuorumResource'] = $quorumDetails.QuorumResource\n                        }\n                        $currentValue['TotalNodes'] = $quorumDetails.TotalNodes\n                        if ($quorumDetails.NodesWithVotes) {\n                            $currentValue['NodesWithVotes'] = $quorumDetails.NodesWithVotes\n                        }\n                    } else {\n                        # Data from T-SQL\n                        $currentValue['TotalNodes'] = $quorumDetails.Count\n                        $currentValue['NodesWithVotes'] = ($quorumDetails | Where-Object { $_.QuorumVotes -gt 0 }).Count\n                    }\n                    \n                    $serverResults.Checks += @{\n                        Category = \"High Availability\"\n                        CheckName = \"Cluster Quorum\"\n                        Status = \"✅ Pass\"\n                        Severity = \"Pass\"\n                        Description = if ($usedServerAdmin) { \"Server is clustered - quorum details retrieved via Windows\" } else { \"Server is clustered with visible quorum members via T-SQL\" }\n                        Impact = \"Windows Server Failover Cluster quorum determines which nodes can form a functioning cluster. Improper quorum configuration can lead to split-brain scenarios or cluster failure. Critical for AG and FCI high availability.\"\n                        CurrentValue = $currentValue\n                        RecommendedAction = if ($usedServerAdmin) { \"Cluster quorum configuration retrieved successfully. Review details and verify health regularly.\" } else { \"Cluster quorum visible via T-SQL. Consider providing MSSQLHC_SERVER_ADMIN credentials for complete quorum configuration details.\" }\n                        RemediationSteps = @{\n                            PowerShell = @\"\n# Check cluster quorum (run on Windows Server with cluster role)\nGet-ClusterQuorum\n\n# Get cluster nodes and their state\nGet-ClusterNode | Select-Object Name, State, NodeWeight\n\n# Get detailed cluster information\nGet-Cluster | Select-Object Name, QuorumType, QuorumResource\n\n# Test cluster quorum\nTest-Cluster -Cluster 'ClusterName' -Include 'Inventory','Network','System Configuration'\n\"@\n                            TSQL = @\"\n-- Check if clustered and HADR enabled\nSELECT \n    SERVERPROPERTY('IsClustered') AS IsClustered,\n    SERVERPROPERTY('IsHadrEnabled') AS IsHadrEnabled,\n    SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS NodeName,\n    SERVERPROPERTY('ServerName') AS ServerName;\n\n-- Check cluster nodes (SQL 2012+)\nSELECT \n    member_name AS NodeName,\n    member_type_desc AS MemberType,\n    member_state_desc AS State,\n    number_of_quorum_votes AS QuorumVotes\nFROM sys.dm_hadr_cluster_members;\n\n-- Check cluster network info\nSELECT \n    member_name AS NodeName,\n    network_subnet_ip,\n    network_subnet_prefix_length,\n    is_public,\n    is_ipv4\nFROM sys.dm_hadr_cluster_networks;\n\"@\n                            Manual = @\"\n1. Open Failover Cluster Manager on Windows Server\n2. Check cluster quorum configuration:\n   - Node Majority (odd number of nodes)\n   - Node and Disk Majority (even nodes + witness disk)\n   - Node and File Share Majority (even nodes + witness share)\n3. Verify quorum votes:\n   - Each node should have appropriate vote weight\n   - Witness (disk/file share) should have 1 vote\n4. Best practices:\n   - Use Node Majority for odd number of nodes (3, 5, etc.)\n   - Use Node and File Share Majority for even nodes\n   - Place witness in separate datacenter for DR\n5. Monitor cluster events in Windows Event Viewer\n6. Test cluster failover regularly\n\"@\n                        }\n                        Documentation = @(\n                            \"https://learn.microsoft.com/en-us/windows-server/failover-clustering/manage-cluster-quorum\",\n                            \"https://learn.microsoft.com/en-us/sql/sql-server/failover-clusters/windows/wsfc-quorum-modes-and-voting-configuration-sql-server\"\n                        )\n                        RawData = if ($quorumDetails.Nodes) { \n                            # Data from PowerShell/CIM (server admin)\n                            $quorumDetails.Nodes | Select-Object Name, State, NodeWeight \n                        } else { \n                            # Data from T-SQL\n                            $quorumDetails | Select-Object NodeName, MemberType, State, QuorumVotes \n                        }\n                    }\n                } else {\n                    # Cannot get detailed quorum info - provide manual check guidance\n                    $serverResults.Checks += @{\n                        Category = \"High Availability\"\n                        CheckName = \"Cluster Quorum\"\n                        Status = \"ℹ️ Manual Check Required\"\n                        Severity = \"Info\"\n                        Description = \"Server is clustered but quorum details cannot be retrieved automatically. Manual verification required.\"\n                        Impact = \"Windows Server Failover Cluster quorum determines which nodes can form a functioning cluster. Improper quorum configuration can lead to split-brain scenarios or cluster failure. Critical for AG and FCI high availability.\"\n                        CurrentValue = @{\n                            IsClustered = $true\n                            IsHadrEnabled = $clusterInfo.IsHadrEnabled -eq 1\n                            ServerAdminCredsProvided = $hasServerAdminCreds\n                            CheckMethod = $checkMethod\n                        }\n                        RecommendedAction = if ($hasServerAdminCreds) { \"Could not retrieve cluster quorum details even with server admin credentials. Manually verify using Windows Failover Cluster Manager or PowerShell on the cluster node.\" } else { \"Provide MSSQLHC_SERVER_ADMIN credentials for enhanced cluster checking, or manually verify cluster quorum using Windows Failover Cluster Manager or the PowerShell commands below.\" }\n                        RemediationSteps = @{\n                            PowerShell = @\"\n# Check cluster quorum (run on Windows Server with cluster role)\nGet-ClusterQuorum\n\n# Get cluster nodes and their state\nGet-ClusterNode | Select-Object Name, State, NodeWeight\n\n# Get detailed cluster information\nGet-Cluster | Select-Object Name, QuorumType, QuorumResource\n\n# Test cluster quorum\nTest-Cluster -Cluster 'ClusterName' -Include 'Inventory','Network','System Configuration'\n\"@\n                            TSQL = @\"\n-- Check if clustered and HADR enabled\nSELECT \n    SERVERPROPERTY('IsClustered') AS IsClustered,\n    SERVERPROPERTY('IsHadrEnabled') AS IsHadrEnabled,\n    SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS NodeName,\n    SERVERPROPERTY('ServerName') AS ServerName;\n\n-- Try to check cluster nodes (SQL 2012+)\nSELECT \n    member_name AS NodeName,\n    member_type_desc AS MemberType,\n    member_state_desc AS State,\n    number_of_quorum_votes AS QuorumVotes\nFROM sys.dm_hadr_cluster_members;\n\n-- Check cluster network info\nSELECT \n    member_name AS NodeName,\n    network_subnet_ip,\n    network_subnet_prefix_length,\n    is_public,\n    is_ipv4\nFROM sys.dm_hadr_cluster_networks;\n\"@\n                            Manual = @\"\n1. Open Failover Cluster Manager on Windows Server\n2. Check cluster quorum configuration:\n   - Node Majority (odd number of nodes)\n   - Node and Disk Majority (even nodes + witness disk)\n   - Node and File Share Majority (even nodes + witness share)\n3. Verify quorum votes:\n   - Each node should have appropriate vote weight\n   - Witness (disk/file share) should have 1 vote\n4. Best practices:\n   - Use Node Majority for odd number of nodes (3, 5, etc.)\n   - Use Node and File Share Majority for even nodes\n   - Place witness in separate datacenter for DR\n5. Monitor cluster events in Windows Event Viewer\n6. Test cluster failover regularly\n\nNote: For SQL Server 2012+, you can query sys.dm_hadr_cluster_members via T-SQL\n\"@\n                        }\n                        Documentation = @(\n                            \"https://learn.microsoft.com/en-us/windows-server/failover-clustering/manage-cluster-quorum\",\n                            \"https://learn.microsoft.com/en-us/sql/sql-server/failover-clusters/windows/wsfc-quorum-modes-and-voting-configuration-sql-server\",\n                            \"https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-hadr-cluster-members-transact-sql\"\n                        )\n                        RawData = @{\n                            IsClustered = $true\n                            IsHadrEnabled = $clusterInfo.IsHadrEnabled -eq 1\n                        }\n                    }\n                }\n            } else {\n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"Cluster Quorum\"\n                    Status = \"ℹ️ Info\"\n                    Severity = \"Info\"\n                    Description = \"Server is not part of a Windows cluster\"\n                    Impact = \"N/A\"\n                    CurrentValue = @{ IsClustered = $false }\n                    RecommendedAction = \"No action needed - server is standalone\"\n                    RemediationSteps = @{}\n                    Documentation = @()\n                    RawData = @{}\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"Cluster Quorum\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check cluster status\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 44\n        \n        # ============================================================================\n        # CHECK 45: AUTO GROWTH DISABLED (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 45 -CheckName \"Auto Growth Disabled\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [45/$totalChecks] Checking for disabled auto growth...\"\n        \n        try {\n            $query = @\"\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    name AS FileName,\n    type_desc AS FileType,\n    physical_name AS PhysicalPath,\n    size * 8 / 1024 AS SizeMB,\n    CASE \n        WHEN max_size = -1 THEN 'Unlimited'\n        WHEN max_size = 0 THEN 'Disabled'\n        ELSE CAST(max_size * 8 / 1024 AS VARCHAR(20)) + ' MB'\n    END AS MaxSize,\n    CASE \n        WHEN is_percent_growth = 1 THEN CAST(growth AS VARCHAR(10)) + '%'\n        ELSE CAST(growth * 8 / 1024 AS VARCHAR(10)) + ' MB'\n    END AS GrowthSetting,\n    CASE \n        WHEN growth = 0 THEN 'Disabled'\n        ELSE 'Enabled'\n    END AS AutoGrowth\nFROM sys.master_files\nWHERE database_id > 4  -- Exclude system databases\nAND growth = 0  -- Auto growth disabled\nORDER BY DatabaseName, type_desc;\n\"@\n            $noAutoGrowth = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Auto Growth Disabled\"\n                Status = if ($noAutoGrowth.Count -eq 0) { \"✅ Pass\" } elseif ($noAutoGrowth.Count -lt 3) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($noAutoGrowth.Count -eq 0) { \"Pass\" } elseif ($noAutoGrowth.Count -lt 3) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies database files with auto growth disabled\"\n                Impact = \"Files with auto growth disabled will eventually run out of space, causing INSERT/UPDATE failures, transaction log full errors (9002), and potential database downtime. While manual growth management is valid in some scenarios, disabled auto growth is risky without proper monitoring and proactive space management.\"\n                CurrentValue = @{\n                    FilesWithNoAutoGrowth = $noAutoGrowth.Count\n                }\n                RecommendedAction = if ($noAutoGrowth.Count -eq 0) { \"All files have auto growth enabled\" } else { \"Enable auto growth with appropriate settings\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check file growth settings\nGet-DbaDbFile -SqlInstance '$serverName' |\n    Select-Object Database, LogicalName, FileType, Growth, GrowthType, MaxSize |\n    Where-Object { `$_.Growth -eq 0 } |\n    Format-Table\n\n# Enable auto growth on data file (256MB increments)\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nALTER DATABASE [DatabaseName]\nMODIFY FILE (NAME = N''LogicalFileName'', FILEGROWTH = 256MB)\n'@\n\n# Enable auto growth on log file (512MB increments)\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nALTER DATABASE [DatabaseName]\nMODIFY FILE (NAME = N''LogicalFileName'', FILEGROWTH = 512MB)\n'@\n\"@\n                    TSQL = @\"\n-- Check current file growth settings\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    name AS LogicalName,\n    type_desc AS FileType,\n    CASE \n        WHEN is_percent_growth = 1 THEN CAST(growth AS VARCHAR) + '%'\n        ELSE CAST(growth * 8 / 1024 AS VARCHAR) + ' MB'\n    END AS GrowthSetting,\n    growth AS RawGrowth\nFROM sys.master_files\nWHERE database_id > 4\nORDER BY DatabaseName, type_desc;\n\n-- Enable auto growth on data file (fixed size recommended over percent)\nALTER DATABASE [DatabaseName]\nMODIFY FILE (\n    NAME = N'LogicalFileName',\n    FILEGROWTH = 256MB,\n    MAXSIZE = UNLIMITED\n);\n\n-- Enable auto growth on log file\nALTER DATABASE [DatabaseName]\nMODIFY FILE (\n    NAME = N'LogicalFileName_Log',\n    FILEGROWTH = 512MB,\n    MAXSIZE = UNLIMITED\n);\n\n-- Best practice: Use fixed MB/GB growth, not percent\n-- Data files: 256MB - 1GB increments\n-- Log files: 512MB - 4GB increments\n\"@\n                    Manual = @\"\n1. Review files with disabled auto growth\n2. Determine if intentional (some high-end environments pre-size files)\n3. If not intentional, enable auto growth:\n   - Use fixed size (MB/GB) not percentage\n   - Data files: 256MB-1GB increments\n   - Log files: 512MB-4GB increments\n   - Set reasonable MAXSIZE (not unlimited if disk space limited)\n4. Consider pre-growing files to avoid fragmentation\n5. Monitor disk space proactively\n6. Set up alerts for low disk space\n7. Document file growth strategy\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-files-and-filegroups\",\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-database-transact-sql-file-and-filegroup-options\"\n                )\n                RawData = $noAutoGrowth | Select-Object DatabaseName, FileName, FileType, SizeMB, MaxSize\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Auto Growth Disabled\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check auto growth\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 45\n        \n        # ============================================================================\n        # CHECK 46: DISK BLOCK SIZE (ALLOCATION UNIT SIZE)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 46 -CheckName \"Disk Block Size\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [46/$totalChecks] Checking disk block size (allocation unit size)...\"\n        \n        try {\n            $blockSizeCheck = $null\n            $checkMethod = \"Unknown\"\n            $usedServerAdmin = $false\n            \n            # Try to get disk block size via PowerShell remoting (requires server admin credentials)\n            if ($hasServerAdminCreds) {\n                try {\n                    # Extract hostname from SQL Server connection\n                    $computerName = $conn.ComputerNamePhysicalNetBIOS\n                    if ([string]::IsNullOrWhiteSpace($computerName)) {\n                        $computerName = $serverName.Split('\\\\')[0].Split(',')[0]\n                    }\n                    \n                    # Get disk block size using PowerShell remoting\n                    $scriptBlock = {\n                        try {\n                            # Get all drives\n                            $drives = Get-WmiObject -Class Win32_Volume -Filter \"DriveType=3\" | \n                                Where-Object { $_.FileSystem -eq 'NTFS' } |\n                                Select-Object Name, Label, FileSystem, BlockSize, Capacity, FreeSpace\n                            \n                            return @{\n                                Success = $true\n                                Drives = $drives\n                            }\n                        } catch {\n                            return @{ Success = $false; Error = $_.Exception.Message }\n                        }\n                    }\n                    \n                    $driveResult = Invoke-Command -ComputerName $computerName -Credential $serverAdminCredential -ScriptBlock $scriptBlock -ErrorAction Stop\n                    \n                    if ($driveResult.Success) {\n                        $blockSizeCheck = $driveResult.Drives\n                        $checkMethod = \"PowerShell Remoting with Server Admin credentials\"\n                        $usedServerAdmin = $true\n                        $healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin++\n                    }\n                } catch {\n                    # PowerShell remoting failed\n                    $checkMethod = \"PowerShell Remoting failed: $($_.Exception.Message)\"\n                }\n            } else {\n                $checkMethod = \"Server Admin credentials not provided\"\n            }\n            \n            # Analyze results\n            if ($blockSizeCheck) {\n                # Convert block sizes and check for non-64KB volumes\n                $driveTable = @()\n                $incorrectBlockSize = @()\n                \n                foreach ($drive in $blockSizeCheck) {\n                    $blockSizeKB = $drive.BlockSize / 1024\n                    $isCorrect = $blockSizeKB -eq 64\n                    \n                    $driveTable += [PSCustomObject]@{\n                        DriveName = $drive.Name\n                        Label = if ($drive.Label) { $drive.Label } else { \"N/A\" }\n                        FileSystem = $drive.FileSystem\n                        BlockSizeKB = $blockSizeKB\n                        CapacityGB = [math]::Round($drive.Capacity / 1GB, 2)\n                        FreeSpaceGB = [math]::Round($drive.FreeSpace / 1GB, 2)\n                        Status = if ($isCorrect) { \"✅ Correct (64KB)\" } else { \"❌ Incorrect ($blockSizeKB KB)\" }\n                    }\n                    \n                    if (-not $isCorrect) {\n                        $incorrectBlockSize += [PSCustomObject]@{\n                            DriveName = $drive.Name\n                            Label = if ($drive.Label) { $drive.Label } else { \"N/A\" }\n                            BlockSizeKB = $blockSizeKB\n                            ExpectedKB = 64\n                        }\n                    }\n                }\n                \n                $serverResults.Checks += @{\n                    Category = \"Server Health\"\n                    CheckName = \"Disk Block Size (Allocation Unit Size)\"\n                    Status = if ($incorrectBlockSize.Count -eq 0) { \"✅ Pass\" } else { \"❌ Error\" }\n                    Severity = if ($incorrectBlockSize.Count -eq 0) { \"Pass\" } else { \"Error\" }\n                    Description = \"Verifies that disk volumes have 64KB allocation unit size (block size)\"\n                    Impact = \"SQL Server performs best with 64KB allocation unit size. Smaller block sizes (default 4KB) cause more I/O operations, increased fragmentation, and degraded performance. This is especially critical for database data and log files. The wrong block size can reduce I/O throughput by 30-40%.\"\n                    CurrentValue = @{\n                        VolumesChecked = $driveTable.Count\n                        VolumesWithIncorrectBlockSize = $incorrectBlockSize.Count\n                        CheckMethod = $checkMethod\n                        ServerAdminUsed = $usedServerAdmin\n                    }\n                    RecommendedAction = if ($incorrectBlockSize.Count -eq 0) { \"All volumes have correct 64KB block size\" } else { \"WARNING: Volumes with incorrect block size require reformatting. This requires data migration and downtime. Plan carefully!\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check current block sizes on all NTFS volumes\nGet-WmiObject -Class Win32_Volume -Filter \"DriveType=3\" | \n    Where-Object { `$_.FileSystem -eq 'NTFS' } |\n    Select-Object Name, Label, FileSystem, \n        @{N='BlockSizeKB';E={`$_.BlockSize/1KB}}, \n        @{N='CapacityGB';E={[math]::Round(`$_.Capacity/1GB,2)}}, \n        @{N='FreeSpaceGB';E={[math]::Round(`$_.FreeSpace/1GB,2)}} |\n    Format-Table -AutoSize\n\n# WARNING: Changing block size requires reformatting the volume!\n# This will DESTROY ALL DATA on the volume.\n# You must:\n# 1. Backup all databases\n# 2. Stop SQL Server\n# 3. Move/backup all files\n# 4. Format with 64KB allocation unit size\n# 5. Restore data\n# 6. Start SQL Server\n\"@\n                        TSQL = @\"\n-- Check which SQL Server files are on which drives\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    name AS LogicalFileName,\n    type_desc AS FileType,\n    physical_name AS PhysicalPath,\n    size * 8 / 1024 AS SizeMB\nFROM sys.master_files\nORDER BY physical_name;\n\n-- Use this to plan which volumes need reformatting\n\"@\n                        Manual = @\"\n**CRITICAL: Changing allocation unit size requires reformatting and causes DATA LOSS**\n\n**Planning Steps:**\n1. Identify which SQL Server files are on volumes with incorrect block size\n2. Schedule maintenance window (requires significant downtime)\n3. Full backup of all databases\n4. Document current file locations\n\n**Migration Process:**\n1. Stop SQL Server service\n2. Backup or move all files from the volume to temporary storage\n3. Format volume with 64KB allocation unit:\n   - Right-click drive in Disk Management\n   - Format → Allocation unit size → 64 kilobytes\n   - OR command line: format E: /FS:NTFS /A:64K /Q\n4. Move SQL Server files back to formatted volume\n5. Start SQL Server service\n6. Verify databases are accessible\n\n**Prevention:**\n- Always format SQL Server volumes with 64KB allocation unit BEFORE installing SQL Server\n- Standard for: Windows 2019/2022 + SQL Server 2016+\n- Check new volumes before use\n\n**Alternative (if reformatting not possible):**\n- Migrate to new volume with correct block size\n- Use Storage Migration Service\n- Plan for new hardware with proper configuration\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-files-and-filegroups\",\n                        \"https://techcommunity.microsoft.com/blog/dataplatformblog/sql-server-best-practices-–-selecting-storage-subsystem-disk-allocation-unit-size/298261\",\n                        \"https://www.mssqltips.com/sqlservertip/7353/sql-server-disk-partition-alignment-allocation-unit-size/\"\n                    )\n                    RawData = $driveTable\n                }\n            } else {\n                # Could not check - provide manual instructions\n                $serverResults.Checks += @{\n                    Category = \"Server Health\"\n                    CheckName = \"Disk Block Size (Allocation Unit Size)\"\n                    Status = \"ℹ️ Manual Check Required\"\n                    Severity = \"Info\"\n                    Description = \"Could not automatically check disk block size. Manual verification required.\"\n                    Impact = \"SQL Server performs best with 64KB allocation unit size. Smaller block sizes (default 4KB) cause more I/O operations, increased fragmentation, and degraded performance. This is especially critical for database data and log files.\"\n                    CurrentValue = @{\n                        ServerAdminCredsProvided = $hasServerAdminCreds\n                        CheckMethod = $checkMethod\n                    }\n                    RecommendedAction = if ($hasServerAdminCreds) { \"Could not check block size even with server admin credentials. Manually verify using PowerShell commands below.\" } else { \"Provide MSSQLHC_SERVER_ADMIN credentials for automatic checking, or manually verify disk block size using the PowerShell commands below.\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check block size on all NTFS volumes (run on SQL Server host)\nGet-WmiObject -Class Win32_Volume -Filter \"DriveType=3\" | \n    Where-Object { `$_.FileSystem -eq 'NTFS' } |\n    Select-Object Name, Label, FileSystem, \n        @{N='BlockSizeKB';E={`$_.BlockSize/1KB}}, \n        @{N='CapacityGB';E={[math]::Round(`$_.Capacity/1GB,2)}} |\n    Format-Table -AutoSize\n\n# Expected: BlockSizeKB should be 64 for SQL Server volumes\n# Default Windows format is 4KB - this is NOT optimal for SQL Server\n\"@\n                        TSQL = @\"\n-- Check which volumes host SQL Server files\nSELECT DISTINCT\n    LEFT(physical_name, 3) AS Drive,\n    COUNT(*) AS FileCount\nFROM sys.master_files\nGROUP BY LEFT(physical_name, 3)\nORDER BY Drive;\n\"@\n                        Manual = @\"\n1. Log into SQL Server host with administrator credentials\n2. Open PowerShell as Administrator\n3. Run: Get-WmiObject -Class Win32_Volume -Filter \"DriveType=3\" | Where-Object { `$_.FileSystem -eq 'NTFS' } | Select-Object Name, @{N='BlockSizeKB';E={`$_.BlockSize/1KB}}\n4. Verify all volumes used by SQL Server show 64KB\n5. If any show 4KB (default), they should be reformatted with 64KB allocation unit size\n6. Note: Reformatting requires moving data off the volume first (destructive operation)\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-files-and-filegroups\",\n                        \"https://techcommunity.microsoft.com/blog/dataplatformblog/sql-server-best-practices-–-selecting-storage-subsystem-disk-allocation-unit-size/298261\"\n                    )\n                    RawData = @{ CheckMethod = $checkMethod }\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Server Health\"; CheckName = \"Disk Block Size\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check disk block size\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 46\n        \n        # ============================================================================\n        # CHECK 47: QUERY STORE STATUS (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 47 -CheckName \"Query Store Status\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [47/$totalChecks] Checking Query Store status...\"\n        \n        try {\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            $qsDisabled = @()\n            $qsTable = @()\n            \n            foreach ($db in $databases) {\n                # Query Store is only available in SQL 2016+ (version 13+)\n                if ($conn.VersionMajor -ge 13) {\n                    $query = @\"\nSELECT \n    actual_state_desc AS ActualState,\n    readonly_reason,\n    desired_state_desc AS DesiredState,\n    current_storage_size_mb,\n    max_storage_size_mb,\n    query_capture_mode_desc AS CaptureMode\nFROM sys.database_query_store_options;\n\"@\n                    $qsInfo = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $query\n                    \n                    $isEnabled = $qsInfo.ActualState -ne 'OFF'\n                    \n                    $qsTable += [PSCustomObject]@{\n                        Database = $db.Name\n                        Status = if ($isEnabled) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                        ActualState = if ($qsInfo.ActualState) { $qsInfo.ActualState } else { \"OFF\" }\n                        DesiredState = if ($qsInfo.DesiredState) { $qsInfo.DesiredState } else { \"OFF\" }\n                        StorageMB = if ($qsInfo.current_storage_size_mb) { $qsInfo.current_storage_size_mb } else { 0 }\n                        MaxStorageMB = if ($qsInfo.max_storage_size_mb) { $qsInfo.max_storage_size_mb } else { 0 }\n                        CaptureMode = if ($qsInfo.CaptureMode) { $qsInfo.CaptureMode } else { \"NONE\" }\n                    }\n                    \n                    if (-not $isEnabled) {\n                        $qsDisabled += $db.Name\n                    }\n                } else {\n                    $qsTable += [PSCustomObject]@{\n                        Database = $db.Name\n                        Status = \"ℹ️ Not Supported (SQL 2016+ required)\"\n                        ActualState = \"N/A\"\n                        DesiredState = \"N/A\"\n                        StorageMB = 0\n                        MaxStorageMB = 0\n                        CaptureMode = \"N/A\"\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Query Store Status\"\n                Status = if ($conn.VersionMajor -lt 13) { \"ℹ️ Info\" } elseif ($qsDisabled.Count -eq 0) { \"✅ Pass\" } elseif ($qsDisabled.Count -lt $databases.Count * 0.5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($conn.VersionMajor -lt 13) { \"Info\" } elseif ($qsDisabled.Count -eq 0) { \"Pass\" } elseif ($qsDisabled.Count -lt $databases.Count * 0.5) { \"Warning\" } else { \"Error\" }\n                Description = \"Verifies Query Store is enabled on user databases for performance monitoring\"\n                Impact = \"Query Store is essential for modern SQL Server performance management. It captures query execution history, plans, and statistics, enabling identification of performance regressions, plan changes, and query tuning. Without Query Store, troubleshooting performance issues is significantly harder. Available in SQL Server 2016+.\"\n                CurrentValue = @{\n                    SQLServerVersion = $conn.VersionString\n                    VersionSupportsQueryStore = $conn.VersionMajor -ge 13\n                    DatabasesWithQSDisabled = $qsDisabled.Count\n                    TotalDatabases = $databases.Count\n                }\n                RecommendedAction = if ($conn.VersionMajor -lt 13) { \"Query Store requires SQL Server 2016 or later\" } elseif ($qsDisabled.Count -eq 0) { \"Query Store is enabled on all databases\" } else { \"Enable Query Store on production databases\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Enable Query Store on specific database\nSet-DbaDbQueryStoreOption -SqlInstance '$serverName' -Database 'DatabaseName' -State ReadWrite\n\n# Enable on all user databases\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem | \n    Set-DbaDbQueryStoreOption -State ReadWrite\n\n# Configure Query Store with recommended settings\nSet-DbaDbQueryStoreOption -SqlInstance '$serverName' -Database 'DatabaseName' `\n    -State ReadWrite `\n    -MaxStorageSize 1024 `\n    -DataFlushInterval 900 `\n    -CaptureMode Auto\n\"@\n                    TSQL = @\"\n-- Enable Query Store (SQL 2016+)\nALTER DATABASE [DatabaseName] \nSET QUERY_STORE = ON;\n\n-- Configure Query Store with recommended settings\nALTER DATABASE [DatabaseName]\nSET QUERY_STORE (\n    OPERATION_MODE = READ_WRITE,\n    DATA_FLUSH_INTERVAL_SECONDS = 900,\n    MAX_STORAGE_SIZE_MB = 1024,\n    QUERY_CAPTURE_MODE = AUTO,\n    SIZE_BASED_CLEANUP_MODE = AUTO,\n    MAX_PLANS_PER_QUERY = 200\n);\n\n-- Check Query Store status\nSELECT \n    name AS DatabaseName,\n    is_query_store_on\nFROM sys.databases\nWHERE database_id > 4;\n\"@\n                    Manual = @\"\n1. Query Store requires SQL Server 2016 (13.x) or later\n2. Enable on production databases for performance monitoring\n3. Recommended settings:\n   - Operation Mode: READ_WRITE\n   - Max Storage: 1GB (1024MB) or larger for busy databases\n   - Data Flush Interval: 15 minutes (900 seconds)\n   - Capture Mode: AUTO (captures relevant queries)\n   - Cleanup Mode: AUTO (size-based)\n4. Monitor Query Store storage usage regularly\n5. Use Query Store reports in SSMS for performance analysis\n6. Not recommended for: TempDB, very high transaction databases where overhead is critical\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/performance/best-practice-with-the-query-store\"\n                )\n                RawData = $qsTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Query Store Status\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check Query Store\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 47\n        \n        # ============================================================================\n        # CHECK 48: TRANSPARENT DATA ENCRYPTION (TDE) (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 48 -CheckName \"Transparent Data Encryption\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [48/$totalChecks] Checking Transparent Data Encryption status...\"\n        \n        try {\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            $tdeTable = @()\n            $unencryptedDbs = @()\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    d.name AS DatabaseName,\n    ISNULL(e.encryption_state, 0) AS EncryptionState,\n    CASE ISNULL(e.encryption_state, 0)\n        WHEN 0 THEN 'No encryption'\n        WHEN 1 THEN 'Unencrypted'\n        WHEN 2 THEN 'Encryption in progress'\n        WHEN 3 THEN 'Encrypted'\n        WHEN 4 THEN 'Key change in progress'\n        WHEN 5 THEN 'Decryption in progress'\n        WHEN 6 THEN 'Protection change in progress'\n    END AS EncryptionStateDesc,\n    e.encryptor_type,\n    e.percent_complete\nFROM sys.databases d\nLEFT JOIN sys.dm_database_encryption_keys e ON d.database_id = e.database_id\nWHERE d.name = '$($db.Name)';\n\"@\n                $tdeInfo = Invoke-DbaQuery -SqlInstance $conn -Query $query\n                \n                $isEncrypted = $tdeInfo.EncryptionState -eq 3\n                \n                $tdeTable += [PSCustomObject]@{\n                    Database = $db.Name\n                    Status = if ($isEncrypted) { \"✅ Encrypted\" } else { \"❌ Not Encrypted\" }\n                    EncryptionState = $tdeInfo.EncryptionStateDesc\n                    PercentComplete = if ($tdeInfo.percent_complete) { $tdeInfo.percent_complete } else { 0 }\n                }\n                \n                if (-not $isEncrypted -and $tdeInfo.EncryptionState -ne 2) {\n                    $unencryptedDbs += $db.Name\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Transparent Data Encryption (TDE)\"\n                Status = if ($unencryptedDbs.Count -eq 0) { \"✅ Pass\" } elseif ($unencryptedDbs.Count -lt $databases.Count * 0.3) { \"⚠️ Warning\" } else { \"ℹ️ Info\" }\n                Severity = if ($unencryptedDbs.Count -eq 0) { \"Pass\" } else { \"Info\" }\n                Description = \"Checks if databases are encrypted using Transparent Data Encryption (TDE)\"\n                Impact = \"TDE provides encryption at rest for data and log files, protecting against unauthorized access to database files. Required for many compliance standards (PCI-DSS, HIPAA, GDPR). Without TDE, database files and backups are stored in plain text. Note: TDE is available in Enterprise Edition or can be licensed separately.\"\n                CurrentValue = @{\n                    TotalDatabases = $databases.Count\n                    EncryptedDatabases = $databases.Count - $unencryptedDbs.Count\n                    UnencryptedDatabases = $unencryptedDbs.Count\n                }\n                RecommendedAction = if ($unencryptedDbs.Count -eq 0) { \"All databases are encrypted with TDE\" } else { \"Consider enabling TDE on databases containing sensitive data (requires Enterprise Edition or separate licensing)\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check TDE status\nGet-DbaDbEncryption -SqlInstance '$serverName' | \n    Select-Object Database, EncryptionEnabled, EncryptionState |\n    Format-Table\n\n# Enable TDE (requires Enterprise Edition or Standard with TDE license)\n# Step 1: Create master key in master database\nInvoke-DbaQuery -SqlInstance '$serverName' -Database master -Query @'\nCREATE MASTER KEY ENCRYPTION BY PASSWORD = 'StrongPassword123!'\n'@\n\n# Step 2: Create certificate in master database  \nInvoke-DbaQuery -SqlInstance '$serverName' -Database master -Query @'\nCREATE CERTIFICATE TDE_Cert WITH SUBJECT = 'TDE Certificate'\n'@\n\n# Step 3: Create database encryption key\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'YourDatabase' -Query @'\nCREATE DATABASE ENCRYPTION KEY\nWITH ALGORITHM = AES_256\nENCRYPTION BY SERVER CERTIFICATE TDE_Cert\n'@\n\n# Step 4: Enable encryption\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'YourDatabase' -Query @'\nALTER DATABASE [YourDatabase] SET ENCRYPTION ON\n'@\n\n# IMPORTANT: Backup the certificate and private key!\nBackup-DbaDbCertificate -SqlInstance '$serverName' -Certificate TDE_Cert -Path 'C:\\\\Backup\\\\Certificates'\n\"@\n                    TSQL = @\"\n-- Step 1: Create master key in master (if not exists)\nUSE master;\nGO\nCREATE MASTER KEY ENCRYPTION BY PASSWORD = 'UseStrongPasswordHere!';\nGO\n\n-- Step 2: Create certificate for TDE\nCREATE CERTIFICATE TDE_Cert \nWITH SUBJECT = 'Database Encryption Certificate';\nGO\n\n-- Step 3: Create database encryption key in user database\nUSE [YourDatabase];\nGO\nCREATE DATABASE ENCRYPTION KEY\nWITH ALGORITHM = AES_256\nENCRYPTION BY SERVER CERTIFICATE TDE_Cert;\nGO\n\n-- Step 4: Enable encryption\nALTER DATABASE [YourDatabase] \nSET ENCRYPTION ON;\nGO\n\n-- Check encryption progress\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    encryption_state,\n    percent_complete,\n    CASE encryption_state\n        WHEN 0 THEN 'No encryption'\n        WHEN 1 THEN 'Unencrypted'\n        WHEN 2 THEN 'Encryption in progress'\n        WHEN 3 THEN 'Encrypted'\n        WHEN 4 THEN 'Key change in progress'\n        WHEN 5 THEN 'Decryption in progress'\n    END AS State\nFROM sys.dm_database_encryption_keys;\nGO\n\n-- CRITICAL: Backup certificate and private key\nBACKUP CERTIFICATE TDE_Cert\nTO FILE = 'C:\\\\Backup\\\\TDE_Cert.cer'\nWITH PRIVATE KEY (\n    FILE = 'C:\\\\Backup\\\\TDE_Cert_PrivateKey.pvk',\n    ENCRYPTION BY PASSWORD = 'AnotherStrongPassword!'\n);\nGO\n\"@\n                    Manual = @\"\n**CRITICAL PREREQUISITES:**\n1. TDE requires SQL Server Enterprise Edition (or Standard Edition with TDE add-on license)\n2. Performance impact: ~3-5% CPU overhead for encryption/decryption\n3. ALWAYS backup the TDE certificate and private key - without them, encrypted databases cannot be restored!\n\n**Implementation Steps:**\n1. Verify licensing (Enterprise Edition or TDE license)\n2. Create master key in master database\n3. Create TDE certificate in master database\n4. Backup certificate and private key to secure location (CRITICAL!)\n5. Create database encryption key in target database\n6. Enable encryption (ALTER DATABASE SET ENCRYPTION ON)\n7. Monitor encryption progress (can take hours for large databases)\n8. Store certificate backup in multiple secure locations\n9. Document certificate password in secure password vault\n\n**Important Notes:**\n- Backups of encrypted databases are also encrypted\n- Cannot restore encrypted backup without certificate\n- TempDB is automatically encrypted when any database uses TDE\n- Consider impact on Always On AG (certificate must exist on all replicas)\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/move-a-tde-protected-database-to-another-sql-server\"\n                )\n                RawData = $tdeTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"TDE Status\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check TDE\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 48\n        \n        # ============================================================================\n        # CHECK 49: DATABASE SNAPSHOTS (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 49 -CheckName \"Database Snapshots\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [49/$totalChecks] Checking for database snapshots...\"\n        \n        try {\n            $query = @\"\nSELECT \n    d.name AS SnapshotName,\n    s.name AS SourceDatabase,\n    d.create_date AS CreatedDate,\n    DATEDIFF(DAY, d.create_date, GETDATE()) AS AgeInDays,\n    SUM(f.size) * 8 / 1024 AS SizeMB\nFROM sys.databases d\nINNER JOIN sys.databases s ON d.source_database_id = s.database_id\nINNER JOIN sys.master_files f ON d.database_id = f.database_id\nWHERE d.source_database_id IS NOT NULL\nGROUP BY d.name, s.name, d.create_date\nORDER BY d.create_date DESC;\n\"@\n            $snapshots = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $snapshotTable = @()\n            $oldSnapshots = @()\n            \n            foreach ($snap in $snapshots) {\n                $snapshotTable += [PSCustomObject]@{\n                    SnapshotName = $snap.SnapshotName\n                    SourceDatabase = $snap.SourceDatabase\n                    CreatedDate = $snap.CreatedDate\n                    AgeInDays = $snap.AgeInDays\n                    SizeMB = $snap.SizeMB\n                    Status = if ($snap.AgeInDays -gt 7) { \"⚠️ Old (>7 days)\" } else { \"✅ Recent\" }\n                }\n                \n                if ($snap.AgeInDays -gt 7) {\n                    $oldSnapshots += $snap.SnapshotName\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Database Snapshots\"\n                Status = if ($snapshots.Count -eq 0) { \"✅ Pass\" } elseif ($oldSnapshots.Count -gt 0) { \"⚠️ Warning\" } else { \"ℹ️ Info\" }\n                Severity = if ($snapshots.Count -eq 0) { \"Pass\" } elseif ($oldSnapshots.Count -gt 0) { \"Warning\" } else { \"Info\" }\n                Description = \"Identifies database snapshots that may be consuming disk space\"\n                Impact = \"Database snapshots are read-only point-in-time copies used for reporting or testing. They consume disk space as the source database changes. Old snapshots (>7 days) may indicate forgotten test snapshots that should be cleaned up. Snapshots can grow to significant sizes and impact performance if not managed.\"\n                CurrentValue = @{\n                    TotalSnapshots = $snapshots.Count\n                    OldSnapshots = $oldSnapshots.Count\n                }\n                RecommendedAction = if ($snapshots.Count -eq 0) { \"No database snapshots found\" } elseif ($oldSnapshots.Count -gt 0) { \"Review and remove old database snapshots\" } else { \"Recent snapshots found - verify they are still needed\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List all database snapshots\nGet-DbaDbSnapshot -SqlInstance '$serverName' | \n    Select-Object Name, SnapshotOf, CreateDate, SizeMB |\n    Format-Table\n\n# Remove specific snapshot\nRemove-DbaDbSnapshot -SqlInstance '$serverName' -Snapshot 'SnapshotName' -Confirm:`$false\n\n# Remove all snapshots for a database\nGet-DbaDbSnapshot -SqlInstance '$serverName' -Database 'SourceDatabase' |\n    Remove-DbaDbSnapshot -Confirm:`$false\n\"@\n                    TSQL = @\"\n-- List all database snapshots\nSELECT \n    d.name AS SnapshotName,\n    s.name AS SourceDatabase,\n    d.create_date AS CreatedDate,\n    DATEDIFF(DAY, d.create_date, GETDATE()) AS AgeInDays\nFROM sys.databases d\nINNER JOIN sys.databases s ON d.source_database_id = s.database_id\nWHERE d.source_database_id IS NOT NULL\nORDER BY d.create_date DESC;\n\n-- Drop a database snapshot\nDROP DATABASE [SnapshotName];\n\"@\n                    Manual = @\"\n1. Review all existing snapshots\n2. Verify each snapshot's purpose and owner\n3. Remove snapshots that are:\n   - Older than 7 days (unless documented reason to keep)\n   - Created for testing and no longer needed\n   - From databases that no longer exist\n4. Document snapshot usage policy\n5. Consider automating snapshot cleanup\n6. Remember: Snapshots cannot be backed up and grow with source database changes\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-snapshots-sql-server\"\n                )\n                RawData = $snapshotTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Database Snapshots\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check snapshots\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 49\n        \n        # ============================================================================\n        # CHECK 50: DATABASE COLLATION MISMATCH (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 50 -CheckName \"Database Collation Mismatch\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [50/$totalChecks] Checking database collation mismatches...\"\n        \n        try {\n            $serverCollation = $conn.Collation\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            $collationTable = @()\n            $mismatchedDbs = @()\n            \n            foreach ($db in $databases) {\n                $dbCollation = $db.Collation\n                $isMatch = $dbCollation -eq $serverCollation\n                \n                $collationTable += [PSCustomObject]@{\n                    Database = $db.Name\n                    Collation = $dbCollation\n                    ServerCollation = $serverCollation\n                    Status = if ($isMatch) { \"✅ Match\" } else { \"⚠️ Mismatch\" }\n                }\n                \n                if (-not $isMatch) {\n                    $mismatchedDbs += $db.Name\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Database Collation Mismatch\"\n                Status = if ($mismatchedDbs.Count -eq 0) { \"✅ Pass\" } elseif ($mismatchedDbs.Count -lt 3) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($mismatchedDbs.Count -eq 0) { \"Pass\" } elseif ($mismatchedDbs.Count -lt 3) { \"Warning\" } else { \"Error\" }\n                Description = \"Checks if database collations differ from server collation\"\n                Impact = \"Collation mismatches can cause comparison errors in queries joining temp tables or variables with database tables. TempDB uses server collation, so mismatches require COLLATE clauses in queries. Can also indicate restored databases from different servers. Not always a problem but should be documented and understood.\"\n                CurrentValue = @{\n                    ServerCollation = $serverCollation\n                    DatabasesWithMismatch = $mismatchedDbs.Count\n                    TotalDatabases = $databases.Count\n                }\n                RecommendedAction = if ($mismatchedDbs.Count -eq 0) { \"All databases match server collation\" } else { \"Review collation mismatches - may require explicit COLLATE clauses in queries\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check collations\nGet-DbaDbCollation -SqlInstance '$serverName' | \n    Select-Object Database, Collation, ServerCollation |\n    Format-Table\n\n# Check server collation\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT SERVERPROPERTY('Collation') AS ServerCollation\n'@\n\"@\n                    TSQL = @\"\n-- Check server and database collations\nSELECT \n    name AS DatabaseName,\n    collation_name AS DatabaseCollation,\n    SERVERPROPERTY('Collation') AS ServerCollation,\n    CASE \n        WHEN collation_name = CAST(SERVERPROPERTY('Collation') AS VARCHAR(100)) THEN 'Match'\n        ELSE 'Mismatch'\n    END AS Status\nFROM sys.databases\nWHERE database_id > 4\nORDER BY name;\n\n-- Example query with explicit COLLATE (workaround for mismatches)\nSELECT *\nFROM MyTable t\nINNER JOIN #TempTable tmp \n    ON t.StringColumn COLLATE DATABASE_DEFAULT = tmp.StringColumn;\n\n-- WARNING: Changing database collation is complex and risky\n-- It does NOT change existing column collations\n-- Only changes default for new objects\nALTER DATABASE [DatabaseName] \nCOLLATE SQL_Latin1_General_CP1_CI_AS;\n\"@\n                    Manual = @\"\n**Understanding Collation Mismatches:**\n1. Not always a problem - depends on query patterns\n2. Common causes:\n   - Restored from different server\n   - Intentional (e.g., case-sensitive database)\n   - Legacy databases migrated from older SQL versions\n\n**When to Fix:**\n- If queries fail with collation conflict errors\n- If using temp tables/variables that join with database tables\n- For consistency in new environments\n\n**Important Notes:**\n- Changing database collation does NOT change existing column collations\n- Must rebuild all indexes and constraints after change\n- Extensive testing required\n- Often easier to use COLLATE clauses in problem queries\n\n**Workaround:**\nUse COLLATE DATABASE_DEFAULT in queries:\nWHERE t.Column COLLATE DATABASE_DEFAULT = @Variable\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/collations/set-or-change-the-database-collation\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support\"\n                )\n                RawData = $collationTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Collation Mismatch\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check collations\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 50\n        \n        # ============================================================================\n        # CHECK 51: AUTO CREATE/UPDATE STATISTICS (Database Health)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 51 -CheckName \"Auto Create/Update Statistics\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [51/$totalChecks] Checking auto statistics settings...\"\n        \n        try {\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            $statsTable = @()\n            $disabledDbs = @()\n            \n            foreach ($db in $databases) {\n                $autoCreate = $db.AutoCreateStatisticsEnabled\n                $autoUpdate = $db.AutoUpdateStatisticsEnabled\n                $autoUpdateAsync = $db.AutoUpdateStatisticsAsync\n                \n                $bothEnabled = $autoCreate -and $autoUpdate\n                \n                $statsTable += [PSCustomObject]@{\n                    Database = $db.Name\n                    AutoCreate = if ($autoCreate) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                    AutoUpdate = if ($autoUpdate) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                    AutoUpdateAsync = if ($autoUpdateAsync) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                    Status = if ($bothEnabled) { \"✅ Correct\" } else { \"❌ Issue\" }\n                }\n                \n                if (-not $bothEnabled) {\n                    $disabledDbs += $db.Name\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Database Health\"\n                CheckName = \"Auto Create/Update Statistics\"\n                Status = if ($disabledDbs.Count -eq 0) { \"✅ Pass\" } else { \"❌ Error\" }\n                Severity = if ($disabledDbs.Count -eq 0) { \"Pass\" } else { \"Error\" }\n                Description = \"Verifies automatic statistics creation and updating is enabled\"\n                Impact = \"Auto Create/Update Statistics are critical for query performance. Without them, the query optimizer lacks accurate data distribution information, leading to poor execution plans, full table scans, and performance degradation. These should almost always be enabled. Disabling them is rarely appropriate and causes significant performance issues.\"\n                CurrentValue = @{\n                    DatabasesWithDisabledStats = $disabledDbs.Count\n                    TotalDatabases = $databases.Count\n                }\n                RecommendedAction = if ($disabledDbs.Count -eq 0) { \"Statistics settings are correct on all databases\" } else { \"Enable auto create/update statistics immediately on affected databases\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check statistics settings\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem |\n    Select-Object Name, AutoCreateStatisticsEnabled, AutoUpdateStatisticsEnabled, AutoUpdateStatisticsAsync |\n    Format-Table\n\n# Enable auto create statistics\nSet-DbaDbAutoStatistics -SqlInstance '$serverName' -Database 'DatabaseName' -AutoCreateStatistics\n\n# Enable auto update statistics  \nSet-DbaDbAutoStatistics -SqlInstance '$serverName' -Database 'DatabaseName' -AutoUpdateStatistics\n\n# Enable on all user databases\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem |\n    Set-DbaDbAutoStatistics -AutoCreateStatistics -AutoUpdateStatistics\n\"@\n                    TSQL = @\"\n-- Check current settings\nSELECT \n    name AS DatabaseName,\n    is_auto_create_stats_on AS AutoCreate,\n    is_auto_update_stats_on AS AutoUpdate,\n    is_auto_update_stats_async_on AS AutoUpdateAsync\nFROM sys.databases\nWHERE database_id > 4;\n\n-- Enable auto create statistics\nALTER DATABASE [DatabaseName] \nSET AUTO_CREATE_STATISTICS ON;\n\n-- Enable auto update statistics\nALTER DATABASE [DatabaseName] \nSET AUTO_UPDATE_STATISTICS ON;\n\n-- Optional: Enable async stats update (for large databases)\nALTER DATABASE [DatabaseName] \nSET AUTO_UPDATE_STATISTICS_ASYNC ON;\n\n-- Verify settings\nSELECT DATABASEPROPERTYEX('DatabaseName', 'IsAutoCreateStatistics') AS AutoCreate,\n       DATABASEPROPERTYEX('DatabaseName', 'IsAutoUpdateStatistics') AS AutoUpdate;\n\"@\n                    Manual = @\"\n**CRITICAL: Auto statistics should almost always be enabled**\n\n1. Enable AUTO_CREATE_STATISTICS\n   - Creates statistics automatically on columns used in predicates\n   - Essential for good query plans\n\n2. Enable AUTO_UPDATE_STATISTICS\n   - Updates statistics as data changes\n   - Keeps optimizer information current\n\n3. Consider AUTO_UPDATE_STATISTICS_ASYNC\n   - For large, busy databases\n   - Prevents queries from waiting for stats updates\n   - Stats update happens in background\n\n**When to Disable (RARE):**\n- Never on OLTP databases\n- Possibly on read-only data warehouses with manual maintenance\n- Only if you have automated statistics maintenance\n\n**Impact of Disabled Stats:**\n- Poor execution plans\n- Full table scans instead of index seeks\n- Excessive memory grants\n- Severe performance degradation\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/statistics/statistics\",\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/alter-database-transact-sql-set-options\"\n                )\n                RawData = $statsTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Database Health\"; CheckName = \"Auto Statistics\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check statistics settings\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 51\n        \n        # ============================================================================\n        # CHECK 52: CERTIFICATE EXPIRATION (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 52 -CheckName \"Certificate Expiration\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [52/$totalChecks] Checking certificate expiration dates...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name AS CertificateName,\n    pvt_key_encryption_type_desc AS EncryptionType,\n    start_date AS StartDate,\n    expiry_date AS ExpiryDate,\n    DATEDIFF(DAY, GETDATE(), expiry_date) AS DaysUntilExpiry,\n    subject AS Subject\nFROM sys.certificates\nWHERE pvt_key_encryption_type_desc <> 'NA'\nORDER BY expiry_date;\n\"@\n            $certificates = Invoke-DbaQuery -SqlInstance $conn -Database master -Query $query\n            \n            $certTable = @()\n            $expiringCerts = @()\n            $expiredCerts = @()\n            \n            foreach ($cert in $certificates) {\n                $daysUntilExpiry = $cert.DaysUntilExpiry\n                \n                $certTable += [PSCustomObject]@{\n                    Certificate = $cert.CertificateName\n                    Subject = $cert.Subject\n                    StartDate = $cert.StartDate\n                    ExpiryDate = $cert.ExpiryDate\n                    DaysUntilExpiry = $daysUntilExpiry\n                    Status = if ($daysUntilExpiry -lt 0) { \"❌ Expired\" } elseif ($daysUntilExpiry -lt 30) { \"❌ Critical (<30 days)\" } elseif ($daysUntilExpiry -lt 90) { \"⚠️ Warning (<90 days)\" } else { \"✅ Valid\" }\n                }\n                \n                if ($daysUntilExpiry -lt 0) {\n                    $expiredCerts += $cert.CertificateName\n                } elseif ($daysUntilExpiry -lt 90) {\n                    $expiringCerts += $cert.CertificateName\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Certificate Expiration\"\n                Status = if ($expiredCerts.Count -gt 0) { \"❌ Error\" } elseif ($expiringCerts.Count -gt 0) { \"⚠️ Warning\" } elseif ($certificates.Count -eq 0) { \"ℹ️ Info\" } else { \"✅ Pass\" }\n                Severity = if ($expiredCerts.Count -gt 0) { \"Error\" } elseif ($expiringCerts.Count -gt 0) { \"Warning\" } else { \"Pass\" }\n                Description = \"Checks for expired or soon-to-expire certificates used for encryption\"\n                Impact = \"Expired certificates can cause TDE-encrypted databases to become inaccessible, break Always On AG endpoint encryption, prevent database mirroring, and disrupt service broker communication. Certificate expiration is one of the most critical security incidents requiring immediate attention. Always On AG replicas may fail to synchronize if endpoint certificates expire.\"\n                CurrentValue = @{\n                    TotalCertificates = $certificates.Count\n                    ExpiredCertificates = $expiredCerts.Count\n                    ExpiringCertificates = $expiringCerts.Count\n                }\n                RecommendedAction = if ($expiredCerts.Count -gt 0) { \"URGENT: Renew expired certificates immediately\" } elseif ($expiringCerts.Count -gt 0) { \"Renew certificates expiring within 90 days\" } elseif ($certificates.Count -eq 0) { \"No certificates with private keys found\" } else { \"All certificates are valid\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check certificate expiration\nInvoke-DbaQuery -SqlInstance '$serverName' -Database master -Query @'\nSELECT name, start_date, expiry_date, \n       DATEDIFF(DAY, GETDATE(), expiry_date) AS DaysUntilExpiry\nFROM sys.certificates\nWHERE pvt_key_encryption_type_desc <> 'NA'\nORDER BY expiry_date\n'@ | Format-Table\n\n# For TDE certificates - create new certificate and re-encrypt\n# Step 1: Create new certificate with extended expiration\nInvoke-DbaQuery -SqlInstance '$serverName' -Database master -Query @'\nCREATE CERTIFICATE TDE_Cert_New\nWITH SUBJECT = 'TDE Certificate 2026',\n     EXPIRY_DATE = '2027-12-31'\n'@\n\n# Step 2: Backup the new certificate (CRITICAL!)\nBackup-DbaDbCertificate -SqlInstance '$serverName' -Certificate TDE_Cert_New -Path 'C:\\\\Backup\\\\Certificates'\n\n# Step 3: Re-encrypt database with new certificate\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'YourDatabase' -Query @'\nALTER DATABASE ENCRYPTION KEY\nENCRYPTION BY SERVER CERTIFICATE TDE_Cert_New\n'@\n\n# For Always On AG endpoint certificates - requires downtime coordination\n\"@\n                    TSQL = @\"\n-- Check all certificates and expiration\nSELECT \n    name AS CertificateName,\n    subject,\n    start_date,\n    expiry_date,\n    DATEDIFF(DAY, GETDATE(), expiry_date) AS DaysUntilExpiry,\n    pvt_key_encryption_type_desc\nFROM sys.certificates\nORDER BY expiry_date;\n\n-- Create new certificate with explicit expiration date\nUSE master;\nGO\nCREATE CERTIFICATE TDE_Cert_New\nWITH SUBJECT = 'TDE Certificate Renewal',\n     EXPIRY_DATE = '2027-12-31';  -- Set appropriate date\nGO\n\n-- Backup new certificate (CRITICAL - do this before anything else!)\nBACKUP CERTIFICATE TDE_Cert_New\nTO FILE = 'C:\\\\Backup\\\\TDE_Cert_New.cer'\nWITH PRIVATE KEY (\n    FILE = 'C:\\\\Backup\\\\TDE_Cert_New_PrivateKey.pvk',\n    ENCRYPTION BY PASSWORD = 'StrongPassword123!'\n);\nGO\n\n-- Re-encrypt database with new certificate\nUSE [YourDatabase];\nGO\nALTER DATABASE ENCRYPTION KEY\nENCRYPTION BY SERVER CERTIFICATE TDE_Cert_New;\nGO\n\n-- Drop old certificate (only after verifying new one works!)\n-- USE master;\n-- DROP CERTIFICATE TDE_Cert_Old;\n\"@\n                    Manual = @\"\n**CRITICAL - Certificate Renewal Process:**\n\n**For TDE Certificates:**\n1. Create new certificate with extended expiration (3-5 years)\n2. IMMEDIATELY backup new certificate and private key\n3. Store backup in multiple secure locations\n4. Re-encrypt database encryption key with new certificate\n5. Test database restore on another server\n6. Keep old certificate until all backups are using new certificate\n7. Monitor backup retention period before removing old certificate\n\n**For Always On AG Endpoint Certificates:**\n1. Coordinate with all AG replicas\n2. Create new certificate on all replicas\n3. Requires brief AG synchronization pause\n4. Update endpoint to use new certificate\n5. Test AG synchronization after change\n\n**Important:**\n- ALWAYS backup new certificates before use\n- Never drop old certificates until confirmed unnecessary\n- Document certificate passwords in secure vault\n- Set calendar reminders for renewal (90 days before expiry)\n- Test certificate renewal process in non-prod first\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/statements/create-certificate-transact-sql\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/sql-server-certificates-and-asymmetric-keys\"\n                )\n                RawData = $certTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Certificate Expiration\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check certificates\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 52\n        \n        # ============================================================================\n        # CHECK 53: AUTHENTICATION MODE (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 53 -CheckName \"Authentication Mode\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [53/$totalChecks] Checking authentication mode...\"\n        \n        try {\n            $query = @\"\nSELECT \n    CASE SERVERPROPERTY('IsIntegratedSecurityOnly')\n        WHEN 1 THEN 'Windows Authentication'\n        WHEN 0 THEN 'Mixed Mode (Windows and SQL)'\n    END AS AuthenticationMode,\n    SERVERPROPERTY('IsIntegratedSecurityOnly') AS IsWindowsAuthOnly\n\"@\n            $authMode = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $isWindowsOnly = $authMode.IsWindowsAuthOnly -eq 1\n            $authModeDesc = $authMode.AuthenticationMode\n            \n            # Check for SQL logins if in Mixed Mode\n            $sqlLogins = @()\n            if (-not $isWindowsOnly) {\n                $loginQuery = @\"\nSELECT \n    name AS LoginName,\n    create_date AS Created,\n    CASE \n        WHEN is_disabled = 1 THEN 'Disabled'\n        ELSE 'Enabled'\n    END AS Status\nFROM sys.sql_logins\nWHERE name NOT IN ('sa')\nORDER BY name;\n\"@\n                $sqlLoginsResult = Invoke-DbaQuery -SqlInstance $conn -Query $loginQuery\n                foreach ($login in $sqlLoginsResult) {\n                    $sqlLogins += [PSCustomObject]@{\n                        Login = $login.LoginName\n                        Created = $login.Created\n                        Status = $login.Status\n                    }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Authentication Mode\"\n                Status = if ($isWindowsOnly) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($isWindowsOnly) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if server is using Windows Authentication only (recommended) or Mixed Mode\"\n                Impact = \"Windows Authentication is more secure (Kerberos, centralized password policies, account lockout, auditing). Mixed Mode allows SQL logins which are less secure (no domain policies, passwords stored in SQL, more vulnerable to brute force attacks). Many security standards and compliance frameworks require Windows Authentication. However, Mixed Mode may be necessary for legacy applications or cross-domain scenarios.\"\n                CurrentValue = @{\n                    AuthenticationMode = $authModeDesc\n                    SQLLoginCount = $sqlLogins.Count\n                }\n                RecommendedAction = if ($isWindowsOnly) { \"Using recommended Windows Authentication\" } else { \"Consider Windows Authentication if possible; if SQL logins are required, enforce strong password policies\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current authentication mode\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT SERVERPROPERTY('IsIntegratedSecurityOnly') AS IsWindowsAuthOnly\n'@\n\n# List SQL logins\nGet-DbaLogin -SqlInstance '$serverName' -Type SQL | \n    Select-Object Name, CreateDate, IsDisabled |\n    Format-Table\n\n# Change to Windows Authentication only (requires restart)\n# WARNING: Ensure you have Windows admin access before changing!\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name LoginMode -Value 1\nRestart-DbaService -SqlInstance '$serverName'\n\"@\n                    TSQL = @\"\n-- Check authentication mode\nSELECT \n    CASE SERVERPROPERTY('IsIntegratedSecurityOnly')\n        WHEN 1 THEN 'Windows Authentication'\n        WHEN 0 THEN 'Mixed Mode'\n    END AS AuthenticationMode;\n\n-- List all SQL logins\nSELECT \n    name,\n    create_date,\n    is_disabled,\n    is_policy_checked,\n    is_expiration_checked\nFROM sys.sql_logins\nORDER BY name;\n\n-- To change authentication mode, modify registry and restart SQL Server\n-- HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\MSSQL{XX}.MSSQLSERVER\\\\MSSQLServer\\\\LoginMode\n-- 1 = Windows Authentication\n-- 2 = Mixed Mode\n-- RESTART REQUIRED\n\"@\n                    Manual = @\"\n**Changing Authentication Mode:**\n1. SSMS → Right-click server → Properties → Security\n2. Select \"Windows Authentication mode\"\n3. Click OK\n4. Restart SQL Server service (REQUIRED)\n\n**Before Changing to Windows Auth:**\n1. Identify all SQL logins in use\n2. Create equivalent Windows/AD accounts\n3. Grant same permissions to Windows accounts\n4. Test application connectivity with Windows accounts\n5. Document change window (requires restart)\n6. Ensure you have Windows admin access!\n\n**If Mixed Mode is Required:**\n1. Enforce CHECK_POLICY on all SQL logins\n2. Enforce CHECK_EXPIRATION where possible\n3. Disable 'sa' account or rename it\n4. Use strong, complex passwords (16+ characters)\n5. Regular password rotation\n6. Monitor failed login attempts\n7. Limit SQL login usage to specific applications only\n\n**Note:** Some scenarios legitimately require Mixed Mode:\n- Cross-domain environments without trust\n- Legacy applications that cannot use Windows Auth\n- Certain third-party applications\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/choose-an-authentication-mode\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/choose-an-authentication-mode\"\n                )\n                RawData = if ($sqlLogins.Count -gt 0) { $sqlLogins } else { @([PSCustomObject]@{ AuthenticationMode = $authModeDesc; SQLLogins = \"None\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Authentication Mode\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check authentication mode\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 53\n        \n        # ============================================================================\n        # CHECK 54: GUEST USER ACCESS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 54 -CheckName \"Guest User Access\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [54/$totalChecks] Checking guest user access...\"\n        \n        try {\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            $guestTable = @()\n            $guestEnabledDbs = @()\n            \n            foreach ($db in $databases) {\n                $query = @\"\nSELECT \n    '$($db.Name)' AS DatabaseName,\n    HAS_PERMS_BY_NAME('$($db.Name)', 'DATABASE', 'CONNECT', 'guest', 'DATABASE') AS GuestHasConnect\n\"@\n                $guestCheck = Invoke-DbaQuery -SqlInstance $conn -Database master -Query $query\n                \n                $guestEnabled = $guestCheck.GuestHasConnect -eq 1\n                \n                $guestTable += [PSCustomObject]@{\n                    Database = $db.Name\n                    GuestUserEnabled = if ($guestEnabled) { \"❌ Enabled\" } else { \"✅ Disabled\" }\n                    Status = if ($guestEnabled) { \"⚠️ Risk\" } else { \"✅ Secure\" }\n                }\n                \n                if ($guestEnabled) {\n                    $guestEnabledDbs += $db.Name\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Guest User Access\"\n                Status = if ($guestEnabledDbs.Count -eq 0) { \"✅ Pass\" } elseif ($guestEnabledDbs.Count -lt 3) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($guestEnabledDbs.Count -eq 0) { \"Pass\" } elseif ($guestEnabledDbs.Count -lt 3) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies databases where the guest user has CONNECT permission\"\n                Impact = \"Guest user allows any authenticated login to access a database without explicit permissions. This is a security risk as it grants unintended access. The guest user should be disabled in all databases except master, tempdb, and msdb where it's required by design. Enabled guest accounts can lead to data exposure and compliance violations.\"\n                CurrentValue = @{\n                    DatabasesWithGuestEnabled = $guestEnabledDbs.Count\n                    TotalUserDatabases = $databases.Count\n                }\n                RecommendedAction = if ($guestEnabledDbs.Count -eq 0) { \"Guest user is properly disabled\" } else { \"Revoke CONNECT permission from guest user on affected databases\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check guest user access across databases\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem | ForEach-Object {\n    `$db = `$_.Name\n    Invoke-DbaQuery -SqlInstance '$serverName' -Database `$db -Query @'\nSELECT \n    '`$db' AS DatabaseName,\n    HAS_PERMS_BY_NAME(DB_NAME(), 'DATABASE', 'CONNECT', 'guest', 'DATABASE') AS GuestHasConnect\n'@ } | Format-Table\n|\n# Revoke guest access from specific database\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'DatabaseName' -Query @'\nREVOKE CONNECT FROM GUEST\n'@\n\n# Revoke guest from all user databases (except system DBs)\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem | ForEach-Object {\n    Invoke-DbaQuery -SqlInstance '$serverName' -Database `$_.Name -Query 'REVOKE CONNECT FROM GUEST'\n}\n\"@\n                    TSQL = @\"\n-- Check if guest user has CONNECT in current database\nSELECT \n    DB_NAME() AS DatabaseName,\n    HAS_PERMS_BY_NAME(DB_NAME(), 'DATABASE', 'CONNECT', 'guest', 'DATABASE') AS GuestHasConnect;\n\n-- Revoke CONNECT from guest user\nUSE [DatabaseName];\nGO\nREVOKE CONNECT FROM GUEST;\nGO\n\n-- Check guest permissions\nUSE [DatabaseName];\nGO\nSELECT \n    dp.name AS UserName,\n    dp.type_desc AS UserType,\n    permission_name,\n    state_desc\nFROM sys.database_permissions p\nINNER JOIN sys.database_principals dp ON p.grantee_principal_id = dp.principal_id\nWHERE dp.name = 'guest'\nAND permission_name = 'CONNECT';\nGO\n\"@\n                    Manual = @\"\n**Disabling Guest User:**\n1. Connect to each database\n2. Execute: REVOKE CONNECT FROM GUEST\n3. Verify with: HAS_PERMS_BY_NAME()\n\n**Important Notes:**\n- Guest user CANNOT be dropped (it's built-in)\n- Can only revoke its CONNECT permission\n- Must remain enabled in: master, tempdb, msdb\n- Should be disabled in all user databases\n\n**Testing After Revocation:**\n1. Attempt to connect with login that has no explicit database access\n2. Should receive error: \"The server principal X is not able to access the database Y under the current security context\"\n3. This is expected behavior after disabling guest\n\n**Security Best Practice:**\n- Always explicitly grant database access\n- Never rely on guest user for legitimate access\n- Regularly audit guest user status\n- Include in security compliance checks\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/principals-database-engine\",\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/functions/has-perms-by-name-transact-sql\"\n                )\n                RawData = $guestTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Guest User Access\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check guest user\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 54\n        \n        # ============================================================================\n        # CHECK 55: PUBLIC ROLE PERMISSIONS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 55 -CheckName \"Public Role Permissions\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [55/$totalChecks] Checking public role permissions...\"\n        \n        try {\n            # Check server-level public role permissions\n            $serverPublicQuery = @\"\nSELECT \n    'SERVER' AS Scope,\n    permission_name AS Permission,\n    state_desc AS State,\n    class_desc AS ObjectType\nFROM sys.server_permissions\nWHERE grantee_principal_id = SUSER_SID('public')\nAND permission_name NOT IN ('CONNECT SQL', 'VIEW ANY DATABASE')  -- These are default/acceptable\nORDER BY permission_name;\n\"@\n            $serverPublicPerms = Invoke-DbaQuery -SqlInstance $conn -Query $serverPublicQuery\n            \n            $publicPermsTable = @()\n            $issuesFound = @()\n            \n            foreach ($perm in $serverPublicPerms) {\n                $publicPermsTable += [PSCustomObject]@{\n                    Scope = \"Server\"\n                    Permission = $perm.Permission\n                    State = $perm.State\n                    ObjectType = $perm.ObjectType\n                    Status = \"⚠️ Review\"\n                }\n                $issuesFound += \"Server: $($perm.Permission)\"\n            }\n            \n            # Check database-level public role permissions\n            $databases = Get-DbaDatabase -SqlInstance $conn -ExcludeSystem\n            \n            foreach ($db in $databases) {\n                $dbPublicQuery = @\"\nSELECT \n    '$($db.Name)' AS DatabaseName,\n    permission_name AS Permission,\n    state_desc AS State,\n    OBJECT_NAME(major_id) AS ObjectName,\n    class_desc AS ObjectType\nFROM sys.database_permissions\nWHERE grantee_principal_id = DATABASE_PRINCIPAL_ID('public')\nAND class_desc <> 'DATABASE'  -- Ignore database-level default permissions\nAND permission_name NOT IN ('SELECT', 'EXECUTE')  -- Focus on dangerous permissions\nORDER BY permission_name;\n\"@\n                $dbPublicPerms = Invoke-DbaQuery -SqlInstance $conn -Database $db.Name -Query $dbPublicQuery\n                \n                foreach ($perm in $dbPublicPerms) {\n                    $publicPermsTable += [PSCustomObject]@{\n                        Scope = $db.Name\n                        Permission = $perm.Permission\n                        State = $perm.State\n                        ObjectName = $perm.ObjectName\n                        ObjectType = $perm.ObjectType\n                        Status = \"⚠️ Review\"\n                    }\n                    $issuesFound += \"$($db.Name): $($perm.Permission) on $($perm.ObjectName)\"\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"Public Role Permissions\"\n                Status = if ($issuesFound.Count -eq 0) { \"✅ Pass\" } elseif ($issuesFound.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($issuesFound.Count -eq 0) { \"Pass\" } elseif ($issuesFound.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Checks for excessive permissions granted to the public role\"\n                Impact = \"The public role includes ALL logins - any permission granted to public is granted to everyone. Excessive public permissions can allow unauthorized access to sensitive data or operations. Common issues include public having access to sensitive stored procedures, views, or extended stored procedures (like xp_cmdshell). This is a major security vulnerability.\"\n                CurrentValue = @{\n                    ExcessivePermissions = $issuesFound.Count\n                }\n                RecommendedAction = if ($issuesFound.Count -eq 0) { \"Public role has appropriate minimal permissions\" } else { \"Review and revoke excessive permissions from public role\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check server-level public permissions\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT permission_name, state_desc, class_desc\nFROM sys.server_permissions\nWHERE grantee_principal_id = SUSER_SID('public')\n'@ | Format-Table\n\n# Check database-level public permissions\nGet-DbaDatabase -SqlInstance '$serverName' -ExcludeSystem | ForEach-Object {\n    Write-Host \"Checking `$(`$_.Name)...\"\n    Invoke-DbaQuery -SqlInstance '$serverName' -Database `$_.Name -Query @'\nSELECT permission_name, state_desc, OBJECT_NAME(major_id) AS ObjectName\nFROM sys.database_permissions\nWHERE grantee_principal_id = DATABASE_PRINCIPAL_ID('public')\n'@ | Format-Table\n}\n\n# Revoke specific permission from public\nInvoke-DbaQuery -SqlInstance '$serverName' -Database 'DatabaseName' -Query @'\nREVOKE EXECUTE ON [ObjectName] FROM public\n'@\n\"@\n                    TSQL = @\"\n-- Check server-level public role permissions\nSELECT \n    permission_name,\n    state_desc,\n    class_desc\nFROM sys.server_permissions\nWHERE grantee_principal_id = SUSER_SID('public')\nORDER BY permission_name;\n\n-- Check database-level public role permissions\nUSE [DatabaseName];\nGO\nSELECT \n    permission_name,\n    state_desc,\n    OBJECT_NAME(major_id) AS ObjectName,\n    class_desc\nFROM sys.database_permissions\nWHERE grantee_principal_id = DATABASE_PRINCIPAL_ID('public')\nORDER BY permission_name;\n\n-- Revoke permission from public\nUSE [DatabaseName];\nGO\nREVOKE EXECUTE ON [StoredProcedureName] FROM public;\nGO\n\n-- Common dangerous permissions to look for:\n-- CONTROL, ALTER, TAKE OWNERSHIP, IMPERSONATE\n-- EXECUTE on sensitive procedures\n-- SELECT/UPDATE/DELETE on sensitive tables\n\"@\n                    Manual = @\"\n**Reviewing Public Role Permissions:**\n\n**Server Level:**\n1. Review sys.server_permissions for public\n2. Acceptable: CONNECT SQL, VIEW ANY DATABASE\n3. Dangerous: CONTROL SERVER, ALTER ANY LOGIN, etc.\n\n**Database Level:**\n1. Check each user database\n2. Acceptable: Minimal SELECT on system views\n3. Dangerous: EXECUTE on stored procedures\n4. Dangerous: Permissions on user tables/views\n\n**Remediation Steps:**\n1. Identify why permission was granted to public\n2. Create specific role for intended users\n3. Grant permission to specific role instead\n4. Revoke from public\n5. Test application functionality\n\n**Common Issues:**\n- Third-party apps that incorrectly use public\n- Legacy scripts that grant to public\n- Developers using public for convenience\n\n**Best Practice:**\n- Never grant permissions to public\n- Use custom roles with specific membership\n- Principle of least privilege\n- Regular audits of public permissions\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/database-level-roles\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/security/permissions-database-engine\"\n                )\n                RawData = if ($publicPermsTable.Count -gt 0) { $publicPermsTable } else { @([PSCustomObject]@{ Status = \"✅ Pass\"; Message = \"No excessive public permissions found\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Public Role Permissions\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check public role\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 55\n        \n        # ============================================================================\n        # CHECK 56: SQL SERVER AUDIT STATUS (Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 56 -CheckName \"SQL Server Audit Status\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [56/$totalChecks] Checking SQL Server Audit configuration...\"\n        \n        try {\n            # Check if SQL Server Audit is available (Enterprise/Standard Edition)\n            $editionQuery = \"SELECT SERVERPROPERTY('EngineEdition') AS Edition\"\n            $edition = Invoke-DbaQuery -SqlInstance $conn -Query $editionQuery\n            $isAuditAvailable = $edition.Edition -in @(2, 3)  # 2=Standard, 3=Enterprise\n            \n            if ($isAuditAvailable) {\n                # Check for server audits\n                $auditQuery = @\"\nSELECT \n    name AS AuditName,\n    type_desc AS AuditType,\n    on_failure_desc AS OnFailure,\n    is_state_enabled AS IsEnabled,\n    queue_delay AS QueueDelayMs,\n    audit_guid\nFROM sys.server_audits\nORDER BY name;\n\"@\n                $audits = Invoke-DbaQuery -SqlInstance $conn -Query $auditQuery\n                \n                # Check for audit specifications\n                $auditSpecQuery = @\"\nSELECT \n    sa.name AS AuditName,\n    sas.name AS SpecificationName,\n    sas.is_state_enabled AS IsEnabled,\n    sad.audit_action_name AS ActionName\nFROM sys.server_audit_specifications sas\nINNER JOIN sys.server_audit_specification_details sad ON sas.server_specification_id = sad.server_specification_id\nINNER JOIN sys.server_audits sa ON sas.audit_guid = sa.audit_guid\nORDER BY sa.name, sas.name;\n\"@\n                $auditSpecs = Invoke-DbaQuery -SqlInstance $conn -Query $auditSpecQuery\n                \n                $auditTable = @()\n                foreach ($audit in $audits) {\n                    $auditTable += [PSCustomObject]@{\n                        AuditName = $audit.AuditName\n                        Type = $audit.AuditType\n                        Status = if ($audit.IsEnabled) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                        OnFailure = $audit.OnFailure\n                    }\n                }\n                \n                $enabledAudits = @($audits | Where-Object { $_.IsEnabled -eq $true })\n                \n                $serverResults.Checks += @{\n                    Category = \"Security\"\n                    CheckName = \"SQL Server Audit Status\"\n                    Status = if ($enabledAudits.Count -gt 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                    Severity = if ($enabledAudits.Count -gt 0) { \"Pass\" } else { \"Warning\" }\n                    Description = \"Checks if SQL Server Audit is configured and enabled for compliance and security monitoring\"\n                    Impact = \"SQL Server Audit provides comprehensive security auditing required for many compliance standards (PCI-DSS, HIPAA, SOX, GDPR). Without auditing, you cannot track failed login attempts, privilege escalation, data access, or security changes. Auditing is essential for forensics, compliance, and detecting security breaches. Many regulations require audit trails.\"\n                    CurrentValue = @{\n                        TotalAudits = $audits.Count\n                        EnabledAudits = $enabledAudits.Count\n                        AuditSpecifications = $auditSpecs.Count\n                    }\n                    RecommendedAction = if ($enabledAudits.Count -gt 0) { \"SQL Server Audit is configured\" } else { \"Configure SQL Server Audit for security and compliance monitoring\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check existing audits\nGet-DbaServerAudit -SqlInstance '$serverName' | \n    Select-Object Name, Enabled, FilePath |\n    Format-Table\n\n# Create new audit\nNew-DbaServerAudit -SqlInstance '$serverName' `\n    -Name 'MainAudit' `\n    -FilePath 'C:\\\\SQLAudit' `\n    -MaximumFileSize 100 `\n    -MaximumFileSizeUnit MB `\n    -Enable\n\n# Create audit specification for failed logins\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nCREATE SERVER AUDIT SPECIFICATION [FailedLogins]\nFOR SERVER AUDIT [MainAudit]\nADD (FAILED_LOGIN_GROUP)\nWITH (STATE = ON)\n'@\n\n# View audit logs\nGet-DbaServerAuditLog -SqlInstance '$serverName' -AuditName 'MainAudit' | \n    Select-Object EventTime, ActionId, Succeeded, ServerPrincipalName |\n    Format-Table\n\"@\n                        TSQL = @\"\n-- Create server audit\nUSE master;\nGO\nCREATE SERVER AUDIT [MainAudit]\nTO FILE \n(\n    FILEPATH = 'C:\\\\SQLAudit\\\\',\n    MAXSIZE = 100 MB,\n    MAX_ROLLOVER_FILES = 10,\n    RESERVE_DISK_SPACE = OFF\n)\nWITH\n(\n    QUEUE_DELAY = 1000,\n    ON_FAILURE = CONTINUE\n);\nGO\n\n-- Enable the audit\nALTER SERVER AUDIT [MainAudit] WITH (STATE = ON);\nGO\n\n-- Create audit specification for common security events\nCREATE SERVER AUDIT SPECIFICATION [SecurityEvents]\nFOR SERVER AUDIT [MainAudit]\nADD (FAILED_LOGIN_GROUP),\nADD (SUCCESSFUL_LOGIN_GROUP),\nADD (SERVER_ROLE_MEMBER_CHANGE_GROUP),\nADD (DATABASE_PERMISSION_CHANGE_GROUP),\nADD (SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP)\nWITH (STATE = ON);\nGO\n\n-- View audit configuration\nSELECT name, type_desc, is_state_enabled\nFROM sys.server_audits;\n\n-- Read audit logs\nSELECT \n    event_time,\n    action_id,\n    succeeded,\n    server_principal_name,\n    database_name,\n    statement\nFROM sys.fn_get_audit_file('C:\\\\SQLAudit\\\\*.sqlaudit', DEFAULT, DEFAULT)\nORDER BY event_time DESC;\n\"@\n                        Manual = @\"\n**Configuring SQL Server Audit:**\n\n1. **Create Server Audit:**\n   - SSMS → Security → Audits → New Audit\n   - Choose destination (File, Application Log, Security Log)\n   - Set file size limits and rollover policy\n   - Enable the audit\n\n2. **Create Audit Specifications:**\n   - Server Audit Specification for server-level events\n   - Database Audit Specification for database-level events\n\n3. **Recommended Events to Audit:**\n   - FAILED_LOGIN_GROUP (critical)\n   - SUCCESSFUL_LOGIN_GROUP\n   - SERVER_ROLE_MEMBER_CHANGE_GROUP\n   - DATABASE_PERMISSION_CHANGE_GROUP\n   - SCHEMA_OBJECT_ACCESS_GROUP (for sensitive tables)\n   - BACKUP_RESTORE_GROUP\n\n4. **Important Considerations:**\n   - File location with adequate space\n   - Regular review of audit logs\n   - Automated alerts for critical events\n   - Archive audit files for compliance retention\n   - Protect audit files from tampering\n\n5. **Monitoring:**\n   - Set up SQL Agent job to monitor audit file size\n   - Alert on FAILED_LOGIN spikes\n   - Regular review of permission changes\n   - Integration with SIEM if available\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-database-engine\",\n                        \"https://learn.microsoft.com/en-us/sql/relational-databases/security/auditing/create-a-server-audit-and-server-audit-specification\"\n                    )\n                    RawData = if ($auditTable.Count -gt 0) { $auditTable } else { @([PSCustomObject]@{ Status = \"⚠️ Warning\"; Message = \"No SQL Server Audits configured\" }) }\n                }\n            } else {\n                $serverResults.Checks += @{\n                    Category = \"Security\"\n                    CheckName = \"SQL Server Audit Status\"\n                    Status = \"ℹ️ Info\"\n                    Severity = \"Info\"\n                    Description = \"SQL Server Audit is not available in this edition\"\n                    Impact = \"SQL Server Audit requires Standard or Enterprise Edition. Consider upgrading or using alternative auditing methods like Extended Events, SQL Trace, or C2 Audit Mode.\"\n                    CurrentValue = @{ Edition = \"Express/Web/Developer\" }\n                    RecommendedAction = \"Use Extended Events or SQL Trace for auditing, or upgrade to Standard/Enterprise Edition\"\n                    RemediationSteps = @{ PowerShell = \"# SQL Server Audit requires Standard or Enterprise Edition\"; TSQL = \"-- Use Extended Events as alternative\"; Manual = \"Consider upgrading SQL Server edition for full audit capabilities\" }\n                    Documentation = @(\"https://learn.microsoft.com/en-us/sql/sql-server/editions-and-components-of-sql-server-2019\")\n                    RawData = @([PSCustomObject]@{ Status = \"Not Available\"; Reason = \"Edition does not support SQL Server Audit\" })\n                }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"SQL Audit Status\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check SQL Server Audit\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 56\n        \n        # ============================================================================\n        # CHECK 57: ALWAYS ON AG ENDPOINT ENCRYPTION (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 57 -CheckName \"Always On AG Endpoint Encryption\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [57/$totalChecks] Checking Always On AG endpoint encryption...\"\n        \n        try {\n            # Check if Always On is enabled\n            $query = \"SELECT SERVERPROPERTY('IsHadrEnabled') AS IsHadrEnabled\"\n            $hadrEnabled = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            if ($hadrEnabled.IsHadrEnabled -eq 1) {\n                # Check endpoint encryption\n                $endpointQuery = @\"\nSELECT \n    e.name AS EndpointName,\n    e.type_desc AS EndpointType,\n    e.state_desc AS State,\n    CASE e.protocol\n        WHEN 1 THEN 'HTTP'\n        WHEN 2 THEN 'TCP'\n        WHEN 3 THEN 'Name Pipe'\n        WHEN 4 THEN 'Shared Memory'\n        WHEN 5 THEN 'VIA'\n        ELSE 'Unknown'\n    END AS Protocol,\n    CASE e.encryption_algorithm\n        WHEN 0 THEN 'None'\n        WHEN 1 THEN 'RC4'\n        WHEN 2 THEN 'AES'\n        WHEN 3 THEN 'None'\n        WHEN 4 THEN 'RC4'\n        WHEN 5 THEN 'AES RC4'\n        WHEN 6 THEN 'AES'\n        ELSE 'Unknown'\n    END AS EncryptionAlgorithm,\n    CASE e.connection_auth\n        WHEN 1 THEN 'NTLM'\n        WHEN 2 THEN 'Kerberos'\n        WHEN 3 THEN 'Negotiate'\n        WHEN 4 THEN 'Certificate'\n        WHEN 5 THEN 'NTLM Certificate'\n        WHEN 6 THEN 'Kerberos Certificate'\n        ELSE 'Unknown'\n    END AS AuthenticationMode\nFROM sys.database_mirroring_endpoints e\nWHERE e.type = 4  -- DATABASE_MIRRORING type\nORDER BY e.name;\n\"@\n                $endpoints = Invoke-DbaQuery -SqlInstance $conn -Query $endpointQuery\n                \n                $endpointTable = @()\n                $unencryptedEndpoints = @()\n                \n                foreach ($ep in $endpoints) {\n                    $isEncrypted = $ep.EncryptionAlgorithm -ne 'None'\n                    \n                    $endpointTable += [PSCustomObject]@{\n                        Endpoint = $ep.EndpointName\n                        State = $ep.State\n                        Protocol = $ep.Protocol\n                        Encryption = $ep.EncryptionAlgorithm\n                        Authentication = $ep.AuthenticationMode\n                        Status = if ($isEncrypted) { \"✅ Encrypted\" } else { \"❌ Not Encrypted\" }\n                    }\n                    \n                    if (-not $isEncrypted) {\n                        $unencryptedEndpoints += $ep.EndpointName\n                    }\n                }\n                \n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"Always On AG Endpoint Encryption\"\n                    Status = if ($unencryptedEndpoints.Count -eq 0) { \"✅ Pass\" } else { \"❌ Error\" }\n                    Severity = if ($unencryptedEndpoints.Count -eq 0) { \"Pass\" } else { \"Error\" }\n                    Description = \"Verifies that Always On Availability Group endpoints use encryption\"\n                    Impact = \"Unencrypted AG endpoints transmit data replication traffic in plain text over the network. This exposes sensitive data, including committed transactions, to network sniffing and man-in-the-middle attacks. AG endpoints should always use AES encryption for data protection. This is critical for compliance (PCI-DSS, HIPAA) and security best practices.\"\n                    CurrentValue = @{\n                        TotalEndpoints = $endpoints.Count\n                        UnencryptedEndpoints = $unencryptedEndpoints.Count\n                    }\n                    RecommendedAction = if ($unencryptedEndpoints.Count -eq 0) { \"All AG endpoints are encrypted\" } else { \"Enable encryption on AG endpoints immediately\" }\n                    RemediationSteps = @{\n                        PowerShell = @\"\n# Check endpoint encryption\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT name, encryption_algorithm_desc \nFROM sys.database_mirroring_endpoints e\nINNER JOIN sys.tcp_endpoints te ON e.endpoint_id = te.endpoint_id\n'@ | Format-Table\n\n# Modify endpoint to use encryption (requires AG downtime - coordinate with all replicas!)\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nALTER ENDPOINT [Hadr_endpoint]\nFOR DATABASE_MIRRORING (\n    ENCRYPTION = REQUIRED ALGORITHM AES\n)\n'@\n\"@\n                        TSQL = @\"\n-- Check current endpoint configuration\nSELECT \n    e.name AS EndpointName,\n    te.encryption_algorithm_desc AS Encryption,\n    te.connection_auth_desc AS Authentication,\n    e.state_desc AS State,\n    e.port\nFROM sys.database_mirroring_endpoints e\nINNER JOIN sys.tcp_endpoints te ON e.endpoint_id = te.endpoint_id;\n\n-- Enable encryption on endpoint\n-- WARNING: This requires coordination with all AG replicas\n-- All replicas must support the same encryption algorithm\nALTER ENDPOINT [Hadr_endpoint]\nFOR DATABASE_MIRRORING (\n    ENCRYPTION = REQUIRED ALGORITHM AES\n);\n\n-- Options:\n-- ENCRYPTION = DISABLED (not recommended)\n-- ENCRYPTION = SUPPORTED (allows but doesn't require)\n-- ENCRYPTION = REQUIRED (recommended - forces encryption)\n\n-- Available algorithms:\n-- RC4 (deprecated, not recommended)\n-- AES (recommended)\n-- AES RC4 (supports both, negotiates to AES)\n\"@\n                        Manual = @\"\n**Enabling AG Endpoint Encryption:**\n\n**IMPORTANT - Requires coordination across all AG replicas:**\n1. Plan maintenance window (brief AG sync interruption)\n2. Verify all replicas support AES encryption\n3. Apply change to all replicas simultaneously\n4. Monitor AG synchronization after change\n\n**Steps:**\n1. Stop applications or set AG to synchronous mode\n2. On each replica:\n   ALTER ENDPOINT [Hadr_endpoint]\n   FOR DATABASE_MIRRORING (\n       ENCRYPTION = REQUIRED ALGORITHM AES\n   )\n3. Restart endpoints if needed\n4. Verify AG synchronization resumes\n5. Monitor for errors\n\n**Best Practices:**\n- Always use ENCRYPTION = REQUIRED\n- Use AES algorithm (not RC4)\n- Test in non-prod first\n- Document endpoint certificates\n- All replicas must have matching encryption settings\n\n**Note:**\n- Changing encryption requires brief connection interruption\n- AG will automatically reconnect\n- Monitor dm_hadr_availability_replica_states after change\n\"@\n                    }\n                    Documentation = @(\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/database-mirroring-always-on-availability-groups-powershell\",\n                        \"https://learn.microsoft.com/en-us/sql/database-engine/database-mirroring/transport-security-database-mirroring-always-on-availability\"\n                    )\n                    RawData = $endpointTable\n                }\n            } else {\n                # AG not configured - mark as skipped/N/A\n                Write-Host \"[$serverName] [Check 57 - Skipped: Always On AG not configured]\"\n                $serverResults.Checks += @{\n                    Category = \"High Availability\"\n                    CheckName = \"Check 57 - Always On AG Endpoint Encryption\"\n                    Status = \"⏭️ N/A\"\n                    Severity = \"Excluded\"\n                    Description = \"Always On Availability Groups is not enabled on this server\"\n                    Impact = \"This check only applies to servers with Always On AG configured\"\n                    CurrentValue = @{ HadrEnabled = \"No\" }\n                    RecommendedAction = \"N/A - Always On AG not configured\"\n                    RemediationSteps = @{ PowerShell = \"# Always On AG not enabled\"; TSQL = \"-- N/A\"; Manual = \"N/A\" }\n                    Documentation = @(\"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/overview-of-always-on-availability-groups-sql-server\")\n                    RawData = @([PSCustomObject]@{ Status = \"N/A\"; Reason = \"Always On AG not enabled\" })\n                }\n                $currentCheck++  # Increment counter since we're skipping\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"AG Endpoint Encryption\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check endpoint encryption\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 57\n        \n        # ============================================================================\n        # CHECK 58: BACKUP COMPRESSION DEFAULT (Performance/Configuration)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 58 -CheckName \"Backup Compression Default\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [58/$totalChecks] Checking backup compression default setting...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue,\n    description\nFROM sys.configurations\nWHERE name = 'backup compression default';\n\"@\n            $backupCompression = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $isEnabled = $backupCompression.CurrentValue -eq 1\n            \n            $serverResults.Checks += @{\n                Category = \"Configuration\"\n                CheckName = \"Backup Compression Default\"\n                Status = if ($isEnabled) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($isEnabled) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if backup compression is enabled by default\"\n                Impact = \"Backup compression reduces backup file size by 50-70% and often increases backup speed due to reduced I/O. This saves disk space, reduces backup time, and decreases network bandwidth for backup copies. The CPU overhead is minimal on modern servers (typically 3-5%). Compression is especially beneficial for large databases and should be enabled unless CPU is severely constrained.\"\n                CurrentValue = @{\n                    BackupCompressionDefault = if ($isEnabled) { \"Enabled\" } else { \"Disabled\" }\n                }\n                RecommendedAction = if ($isEnabled) { \"Backup compression is enabled\" } else { \"Enable backup compression default for reduced backup size and improved performance\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current setting\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name BackupCompressionDefault | Format-Table\n\n# Enable backup compression default\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name BackupCompressionDefault -Value 1\n\n# Verify setting\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name BackupCompressionDefault | Format-Table\n\n# Test with a backup\nBackup-DbaDatabase -SqlInstance '$serverName' -Database 'TestDB' -CompressBackup -Path 'C:\\\\Backup'\n\"@\n                    TSQL = @\"\n-- Check current setting\nEXEC sp_configure 'backup compression default';\nGO\n\n-- Enable backup compression default\nEXEC sp_configure 'backup compression default', 1;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Verify setting\nSELECT name, value_in_use \nFROM sys.configurations \nWHERE name = 'backup compression default';\nGO\n\n-- Manual backup with compression (overrides default)\nBACKUP DATABASE [YourDatabase]\nTO DISK = 'C:\\\\Backup\\\\YourDatabase.bak'\nWITH COMPRESSION;\nGO\n\n-- Check backup compression ratio\nSELECT \n    database_name,\n    backup_finish_date,\n    compressed_backup_size / 1024 / 1024 AS CompressedSizeMB,\n    backup_size / 1024 / 1024 AS UncompressedSizeMB,\n    CAST((backup_size - compressed_backup_size) * 100.0 / backup_size AS DECIMAL(5,2)) AS CompressionPercent\nFROM msdb.dbo.backupset\nWHERE type = 'D'\nORDER BY backup_finish_date DESC;\n\"@\n                    Manual = @\"\n**Enabling Backup Compression:**\n\n1. **Via SSMS:**\n   - Right-click server → Properties → Database Settings\n   - Check \"Compress backup\"\n   - Click OK\n\n2. **Impact Analysis:**\n   - Typical compression: 50-70% size reduction\n   - CPU overhead: 3-5% during backup\n   - I/O reduction: Significant (less data written)\n   - Backup speed: Often faster due to reduced I/O\n\n3. **Considerations:**\n   - Available since SQL Server 2008 Enterprise\n   - Available in all editions since SQL Server 2008 R2 SP1\n   - No impact on restore speed\n   - Compressed backups are same reliability as uncompressed\n\n4. **When NOT to Enable:**\n   - Severely CPU-constrained servers (rare)\n   - If using hardware compression (tape drives)\n   - If already using OS/filesystem compression\n\n5. **Verification:**\n   - Compare backup file sizes before/after\n   - Monitor backup duration\n   - Check CPU usage during backup\n   - Typical savings: $1000s in storage costs annually\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/backup-restore/backup-compression-sql-server\",\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/view-or-configure-the-backup-compression-default-server-configuration-option\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Setting = \"backup compression default\"\n                    ConfigValue = $backupCompression.ConfigValue\n                    CurrentValue = $backupCompression.CurrentValue\n                    Status = if ($isEnabled) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Configuration\"; CheckName = \"Backup Compression\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check backup compression\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 58\n        \n        # ============================================================================\n        # CHECK 59: DATABASE MIRRORING STATUS (High Availability)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 59 -CheckName \"Database Mirroring Status\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [59/$totalChecks] Checking for deprecated database mirroring...\"\n        \n        try {\n            $query = @\"\nSELECT \n    d.name AS DatabaseName,\n    m.mirroring_state_desc AS MirroringState,\n    m.mirroring_role_desc AS Role,\n    m.mirroring_safety_level_desc AS SafetyLevel,\n    m.mirroring_partner_instance AS Partner\nFROM sys.database_mirroring m\nINNER JOIN sys.databases d ON m.database_id = d.database_id\nWHERE m.mirroring_guid IS NOT NULL;\n\"@\n            $mirroring = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $mirrorTable = @()\n            \n            foreach ($db in $mirroring) {\n                $mirrorTable += [PSCustomObject]@{\n                    Database = $db.DatabaseName\n                    MirroringState = $db.MirroringState\n                    Role = $db.Role\n                    SafetyLevel = $db.SafetyLevel\n                    Partner = $db.Partner\n                    Status = \"⚠️ Deprecated\"\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"High Availability\"\n                CheckName = \"Database Mirroring Status\"\n                Status = if ($mirroring.Count -eq 0) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($mirroring.Count -eq 0) { \"Pass\" } else { \"Warning\" }\n                Description = \"Identifies databases using deprecated database mirroring feature\"\n                Impact = \"Database Mirroring has been deprecated since SQL Server 2012 and replaced by Always On Availability Groups. While still functional, it will be removed in a future version of SQL Server. AG offers superior features: multiple replicas, readable secondaries, automatic failover of multiple databases, better monitoring. New implementations should use Always On AG instead. Plan migration from mirroring to AG.\"\n                CurrentValue = @{\n                    MirroredDatabases = $mirroring.Count\n                }\n                RecommendedAction = if ($mirroring.Count -eq 0) { \"No deprecated database mirroring in use\" } else { \"Plan migration from database mirroring to Always On Availability Groups\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check database mirroring status\nGet-DbaDbMirror -SqlInstance '$serverName' | Format-Table\n\n# Migration to Always On AG requires:\n# 1. Enable Always On AG feature (requires restart)\nEnable-DbaAgHadr -SqlInstance '$serverName' -Force\nRestart-DbaService -SqlInstance '$serverName'\n\n# 2. Create AG (example)\nNew-DbaAvailabilityGroup -SqlInstance '$serverName' `\n    -Name 'AG_Name' `\n    -Database 'YourDatabase' `\n    -ClusterType Wsfc `\n    -AvailabilityMode SynchronousCommit `\n    -FailoverMode Automatic\n\n# 3. Remove mirroring (after AG is established)\nRemove-DbaDbMirror -SqlInstance '$serverName' -Database 'YourDatabase'\n\"@\n                    TSQL = @\"\n-- Check database mirroring status\nSELECT \n    DB_NAME(database_id) AS DatabaseName,\n    mirroring_state_desc,\n    mirroring_role_desc,\n    mirroring_partner_instance\nFROM sys.database_mirroring\nWHERE mirroring_guid IS NOT NULL;\n\n-- Remove database mirroring (after AG is configured)\nALTER DATABASE [YourDatabase] \nSET PARTNER OFF;\n\n-- Migration involves:\n-- 1. Enable AlwaysOn_health extended event session\n-- 2. Enable HADR via SQL Server Configuration Manager (requires restart)\n-- 3. Create Windows Cluster or use existing\n-- 4. Create Availability Group\n-- 5. Add databases to AG\n-- 6. Remove mirroring\n-- 7. Test failover\n\"@\n                    Manual = @\"\n**Migrating from Database Mirroring to Always On AG:**\n\n**Prerequisites:**\n1. SQL Server Enterprise Edition (Standard supports basic AG)\n2. Windows Server Failover Cluster\n3. Same SQL Server version on all replicas\n4. All databases in FULL recovery model\n\n**Migration Steps:**\n1. Document existing mirroring configuration\n2. Test AG in non-production\n3. Enable AlwaysOn High Availability in SQL Configuration Manager\n4. Restart SQL Server (required)\n5. Create Availability Group\n6. Add mirrored databases to AG\n7. Configure listener\n8. Update application connection strings\n9. Test AG failover\n10. Remove mirroring after successful validation\n\n**Advantages of Always On AG over Mirroring:**\n- Multiple secondary replicas (not just one mirror)\n- Readable secondary replicas\n- Automatic failover of multiple databases as a group\n- Built-in health monitoring and diagnostics\n- Supports up to 9 replicas\n- Better integration with Azure\n\n**Note:**\n- Database mirroring still works but is deprecated\n- Plan migration within next 1-2 years\n- Migration requires planning and testing\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/database-mirroring/database-mirroring-sql-server\",\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/availability-groups/windows/overview-of-always-on-availability-groups-sql-server\"\n                )\n                RawData = if ($mirrorTable.Count -gt 0) { $mirrorTable } else { @([PSCustomObject]@{ Status = \"✅ Pass\"; Message = \"No database mirroring configured\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"High Availability\"; CheckName = \"Database Mirroring\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check database mirroring\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 59\n        \n        # ============================================================================\n        # CHECK 60: MAX DEGREE OF PARALLELISM (MAXDOP) (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 60 -CheckName \"Max Degree of Parallelism\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [60/$totalChecks] Checking MAXDOP configuration...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue\nFROM sys.configurations\nWHERE name = 'max degree of parallelism';\n\"@\n            $maxdop = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # Get logical processor count\n            $cpuQuery = \"SELECT cpu_count FROM sys.dm_os_sys_info\"\n            $cpuInfo = Invoke-DbaQuery -SqlInstance $conn -Query $cpuQuery\n            $cpuCount = $cpuInfo.cpu_count\n            \n            $currentMaxdop = $maxdop.CurrentValue\n            \n            # Recommended MAXDOP based on CPU count (following Microsoft guidelines)\n            $recommendedMaxdop = if ($cpuCount -le 8) { $cpuCount } elseif ($cpuCount -le 16) { 8 } else { [math]::Floor($cpuCount / 2) }\n            \n            $isOptimal = ($currentMaxdop -gt 0 -and $currentMaxdop -le $recommendedMaxdop) -or ($currentMaxdop -eq $recommendedMaxdop)\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Max Degree of Parallelism (MAXDOP)\"\n                Status = if ($currentMaxdop -eq 0) { \"❌ Error\" } elseif ($isOptimal) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($currentMaxdop -eq 0) { \"Error\" } elseif ($isOptimal) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if MAXDOP is configured optimally for the server's CPU count\"\n                Impact = \"MAXDOP=0 (unlimited parallelism) can cause excessive parallelism, leading to CXPACKET waits, resource contention, and poor performance. Setting MAXDOP appropriately prevents single queries from monopolizing all CPUs. Microsoft recommends: ≤8 CPUs use CPU count, 8-16 CPUs use 8, >16 CPUs use half CPU count. Incorrect MAXDOP is a common cause of performance issues.\"\n                CurrentValue = @{\n                    CurrentMAXDOP = $currentMaxdop\n                    RecommendedMAXDOP = $recommendedMaxdop\n                    LogicalCPUs = $cpuCount\n                }\n                RecommendedAction = if ($currentMaxdop -eq 0) { \"Set MAXDOP to $recommendedMaxdop immediately (currently unlimited)\" } elseif ($isOptimal) { \"MAXDOP is configured optimally\" } else { \"Consider adjusting MAXDOP to $recommendedMaxdop\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current MAXDOP\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name MaxDegreeOfParallelism | Format-Table\n\n# Set MAXDOP to recommended value\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name MaxDegreeOfParallelism -Value $recommendedMaxdop\n\n# Check CPU count\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    cpu_count AS LogicalCPUs,\n    hyperthread_ratio AS HyperthreadRatio,\n    cpu_count / hyperthread_ratio AS PhysicalCPUs\nFROM sys.dm_os_sys_info\n'@ | Format-Table\n\"@\n                    TSQL = @\"\n-- Check current MAXDOP\nEXEC sp_configure 'max degree of parallelism';\nGO\n\n-- Check CPU count\nSELECT \n    cpu_count AS LogicalCPUs,\n    hyperthread_ratio,\n    cpu_count / hyperthread_ratio AS PhysicalCPUs\nFROM sys.dm_os_sys_info;\n\n-- Set MAXDOP (recommended value: $recommendedMaxdop for this server)\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nGO\nEXEC sp_configure 'max degree of parallelism', $recommendedMaxdop;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Microsoft MAXDOP Guidelines:\n-- ≤8 CPUs: MAXDOP = CPU count\n-- 8-16 CPUs: MAXDOP = 8\n-- >16 CPUs: MAXDOP = CPU count / 2\n-- NUMA: Consider setting per-NUMA node\n\"@\n                    Manual = @\"\n**Setting MAXDOP:**\n\n**Microsoft Recommendations:**\n- 8 or fewer CPUs: MAXDOP = number of CPUs\n- 8 to 16 CPUs: MAXDOP = 8\n- More than 16 CPUs: MAXDOP = half the CPU count\n- For NUMA systems: Consider MAXDOP = CPUs per NUMA node\n\n**Your Server:**\n- Logical CPUs: $cpuCount\n- Recommended MAXDOP: $recommendedMaxdop\n- Current MAXDOP: $currentMaxdop\n\n**Implementation:**\n1. Test recommended value in non-production first\n2. Monitor CXPACKET waits after change\n3. Can be overridden per query with OPTION (MAXDOP N)\n4. Database-scoped configuration available in SQL 2016+\n\n**Special Cases:**\n- OLTP workloads: May benefit from lower MAXDOP (2-4)\n- Data warehouse: May use higher MAXDOP\n- Monitor and adjust based on workload\n\n**Immediate vs Advanced Config:**\n- MAXDOP change takes effect immediately\n- No restart required\n- Test during low-activity period\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option\",\n                    \"https://support.microsoft.com/en-us/topic/recommendations-and-guidelines-for-the-max-degree-of-parallelism-configuration-option-in-sql-server-12659f9f-cf68-49b2-fea7-3429729e5c74\"\n                )\n                RawData = @([PSCustomObject]@{\n                    CurrentMAXDOP = $currentMaxdop\n                    RecommendedMAXDOP = $recommendedMaxdop\n                    LogicalCPUs = $cpuCount\n                    Status = if ($isOptimal) { \"✅ Optimal\" } else { \"⚠️ Needs Adjustment\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"MAXDOP\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check MAXDOP\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 60\n        \n        # ============================================================================\n        # CHECK 61: COST THRESHOLD FOR PARALLELISM (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 61 -CheckName \"Cost Threshold for Parallelism\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [61/$totalChecks] Checking cost threshold for parallelism...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue\nFROM sys.configurations\nWHERE name = 'cost threshold for parallelism';\n\"@\n            $costThreshold = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $currentValue = $costThreshold.CurrentValue\n            $recommendedMin = 50  # Microsoft's common recommendation\n            \n            $isOptimal = $currentValue -ge $recommendedMin\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Cost Threshold for Parallelism\"\n                Status = if ($currentValue -eq 5) { \"❌ Error\" } elseif ($isOptimal) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($currentValue -eq 5) { \"Error\" } elseif ($isOptimal) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if cost threshold for parallelism is set appropriately (default of 5 is too low)\"\n                Impact = \"Default value of 5 is extremely low, causing excessive parallelism for trivial queries. This wastes CPU resources, increases CXPACKET waits, and degrades performance. Small queries execute faster in serial. Microsoft commonly recommends 50 as starting point. Higher values (50-100) prevent unnecessary parallelism overhead. This is one of the most important settings to change from default.\"\n                CurrentValue = @{\n                    CurrentValue = $currentValue\n                    RecommendedMinimum = $recommendedMin\n                }\n                RecommendedAction = if ($currentValue -eq 5) { \"Increase cost threshold from default 5 to at least 50 immediately\" } elseif ($isOptimal) { \"Cost threshold is configured appropriately\" } else { \"Consider increasing to at least $recommendedMin\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current value\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name CostThresholdForParallelism | Format-Table\n\n# Set to recommended value (start with 50, adjust based on workload)\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name CostThresholdForParallelism -Value 50\n\n# Verify change\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name CostThresholdForParallelism | Format-Table\n\"@\n                    TSQL = @\"\n-- Check current value\nEXEC sp_configure 'cost threshold for parallelism';\nGO\n\n-- Set cost threshold (common starting point: 50)\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nGO\nEXEC sp_configure 'cost threshold for parallelism', 50;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Verify change\nSELECT name, value_in_use \nFROM sys.configurations \nWHERE name = 'cost threshold for parallelism';\n\"@\n                    Manual = @\"\n**Cost Threshold for Parallelism:**\n\n**The Problem:**\n- Default value: 5 (unchanged since SQL Server 7.0 in 1998!)\n- This default is way too low for modern servers\n- Causes trivial queries to go parallel unnecessarily\n\n**Recommendations:**\n- Start with 50 (common Microsoft recommendation)\n- Some experts recommend 50-100\n- Tune based on your workload\n- Higher values = less parallelism = fewer CXPACKET waits\n\n**Current Value: $currentValue**\n$(if ($currentValue -eq 5) { \"⚠️ CRITICAL: Using default value of 5 - change immediately!\" })\n\n**Implementation:**\n1. Change to 50 initially\n2. Monitor CXPACKET waits after change\n3. If CXPACKET waits persist, increase further\n4. If queries become slower, decrease slightly\n5. Typical sweet spot: 50-75\n\n**Important Notes:**\n- Change takes effect immediately\n- No restart required\n- Works in conjunction with MAXDOP\n- First changed this, then tune MAXDOP\n- Safe to change in production (non-disruptive)\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/configure-the-cost-threshold-for-parallelism-server-configuration-option\",\n                    \"https://www.brentozar.com/archive/2013/08/what-should-i-set-cost-threshold-for-parallelism-to/\"\n                )\n                RawData = @([PSCustomObject]@{\n                    CurrentValue = $currentValue\n                    DefaultValue = 5\n                    RecommendedMinimum = $recommendedMin\n                    Status = if ($currentValue -eq 5) { \"❌ Using Default (Too Low)\" } elseif ($isOptimal) { \"✅ Appropriate\" } else { \"⚠️ Consider Increasing\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Cost Threshold\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check cost threshold\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 61\n        \n        # ============================================================================\n        # CHECK 62: OPTIMIZE FOR AD HOC WORKLOADS (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 62 -CheckName \"Optimize for Ad Hoc Workloads\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [62/$totalChecks] Checking optimize for ad hoc workloads...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue\nFROM sys.configurations\nWHERE name = 'optimize for ad hoc workloads';\n\"@\n            $adHoc = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $isEnabled = $adHoc.CurrentValue -eq 1\n            \n            # Check plan cache for ad hoc queries\n            $planCacheQuery = @\"\nSELECT \n    objtype AS CacheType,\n    COUNT(*) AS PlanCount,\n    SUM(CAST(size_in_bytes AS BIGINT)) / 1024 / 1024 AS SizeMB,\n    AVG(usecounts) AS AvgUseCount\nFROM sys.dm_exec_cached_plans\nGROUP BY objtype\nORDER BY SizeMB DESC;\n\"@\n            $planCache = Invoke-DbaQuery -SqlInstance $conn -Query $planCacheQuery\n            \n            $adHocPlans = $planCache | Where-Object { $_.CacheType -eq 'Adhoc' }\n            $adHocSizeMB = if ($adHocPlans) { [math]::Round($adHocPlans.SizeMB, 2) } else { 0 }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Optimize for Ad Hoc Workloads\"\n                Status = if ($isEnabled) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($isEnabled) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if 'optimize for ad hoc workloads' is enabled to reduce plan cache bloat\"\n                Impact = \"When disabled, SQL Server stores full execution plans for ad-hoc queries on first execution, wasting memory on single-use plans. Enabling this option stores only a small plan stub initially, saving ~50% of plan cache memory for ad-hoc queries. Full plan is cached only on second execution. Highly recommended for OLTP systems with many ad-hoc queries. Helps prevent plan cache bloat and memory pressure.\"\n                CurrentValue = @{\n                    OptimizeForAdHoc = if ($isEnabled) { \"Enabled\" } else { \"Disabled\" }\n                    AdHocPlanCacheSizeMB = $adHocSizeMB\n                }\n                RecommendedAction = if ($isEnabled) { \"Optimize for ad hoc workloads is enabled\" } else { \"Enable optimize for ad hoc workloads to reduce plan cache memory usage\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current setting\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name OptimizeForAdHocWorkloads | Format-Table\n\n# Enable optimize for ad hoc workloads\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name OptimizeForAdHocWorkloads -Value 1\n\n# Check plan cache usage\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    objtype,\n    COUNT(*) AS PlanCount,\n    SUM(CAST(size_in_bytes AS BIGINT)) / 1024 / 1024 AS SizeMB\nFROM sys.dm_exec_cached_plans\nGROUP BY objtype\nORDER BY SizeMB DESC\n'@ | Format-Table\n\"@\n                    TSQL = @\"\n-- Check current setting\nEXEC sp_configure 'optimize for ad hoc workloads';\nGO\n\n-- Enable optimize for ad hoc workloads\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nGO\nEXEC sp_configure 'optimize for ad hoc workloads', 1;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Check plan cache for ad-hoc plans\nSELECT \n    objtype AS PlanType,\n    COUNT(*) AS PlanCount,\n    SUM(CAST(size_in_bytes AS BIGINT)) / 1024 / 1024 AS CacheSizeMB,\n    AVG(usecounts) AS AvgUseCount\nFROM sys.dm_exec_cached_plans\nGROUP BY objtype\nORDER BY CacheSizeMB DESC;\n\n-- Find single-use ad-hoc plans (wasting memory)\nSELECT \n    usecounts,\n    size_in_bytes / 1024 AS SizeKB,\n    CAST(cp.plan_handle AS VARCHAR(MAX)) AS PlanHandle,\n    st.text AS QueryText\nFROM sys.dm_exec_cached_plans cp\nCROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st\nWHERE cp.cacheobjtype = 'Compiled Plan'\nAND cp.objtype = 'Adhoc'\nAND cp.usecounts = 1\nORDER BY cp.size_in_bytes DESC;\n\"@\n                    Manual = @\"\n**Optimize for Ad Hoc Workloads:**\n\n**What It Does:**\n- Stores small plan stub (few KB) on first execution\n- Stores full plan only if query executes again\n- Saves ~50% of plan cache for ad-hoc queries\n- No performance impact on query execution\n\n**When to Enable:**\n- OLTP applications with many unique queries\n- Applications that don't use parameterized queries\n- When plan cache shows high 'Adhoc' memory usage\n- Almost always beneficial (rare downsides)\n\n**Current Status:**\n- Enabled: $(if ($isEnabled) { 'Yes ✅' } else { 'No ❌' })\n- Ad-hoc plan cache size: $adHocSizeMB MB\n\n**Benefits:**\n- Reduces memory pressure\n- More room for frequently-used plans\n- Prevents plan cache bloat\n- No application changes required\n- No query performance impact\n\n**Implementation:**\n1. Enable setting (takes effect immediately)\n2. Monitor plan cache size over days/weeks\n3. Existing plans remain cached\n4. New ad-hoc plans use stub approach\n5. Clear plan cache to see immediate effect (optional, disruptive)\n\n**Note:**\n- Safe to enable in production\n- Immediate effect, no restart needed\n- Recommended by Microsoft for most workloads\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/optimize-for-ad-hoc-workloads-server-configuration-option\",\n                    \"https://www.sqlskills.com/blogs/kimberly/plan-cache-and-optimizing-for-adhoc-workloads/\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Setting = \"optimize for ad hoc workloads\"\n                    CurrentValue = if ($isEnabled) { \"Enabled\" } else { \"Disabled\" }\n                    AdHocPlanCacheMB = $adHocSizeMB\n                    Status = if ($isEnabled) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Ad Hoc Optimization\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check ad hoc optimization\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 62\n        \n        # ============================================================================\n        # CHECK 63: NETWORK PACKET SIZE (Configuration)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 63 -CheckName \"Network Packet Size\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [63/$totalChecks] Checking network packet size...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue\nFROM sys.configurations\nWHERE name = 'network packet size';\n\"@\n            $packetSize = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $currentValue = $packetSize.CurrentValue\n            $defaultValue = 4096\n            \n            $isDefault = $currentValue -eq $defaultValue\n            \n            $serverResults.Checks += @{\n                Category = \"Configuration\"\n                CheckName = \"Network Packet Size\"\n                Status = if ($isDefault) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($isDefault) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if network packet size is set to default (4096 bytes)\"\n                Impact = \"Default packet size of 4096 bytes is optimal for most workloads. Increasing it may improve bulk operations and large result sets but can increase memory usage and network congestion. Decreasing it can cause more network round trips. Microsoft recommends leaving at default unless specific performance testing shows benefit. Changing this setting rarely provides performance improvements and can cause issues. Only change if you have a specific reason and have tested thoroughly.\"\n                CurrentValue = @{\n                    CurrentPacketSize = $currentValue\n                    DefaultPacketSize = $defaultValue\n                }\n                RecommendedAction = if ($isDefault) { \"Network packet size is at recommended default\" } else { \"Consider returning to default 4096 unless specific tuning has proven beneficial\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current setting\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name NetworkPacketSize | Format-Table\n\n# Reset to default if needed\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name NetworkPacketSize -Value 4096\n\n# Verify change\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name NetworkPacketSize | Format-Table\n\"@\n                    TSQL = @\"\n-- Check current value\nEXEC sp_configure 'network packet size';\nGO\n\n-- Reset to default (4096)\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nGO\nEXEC sp_configure 'network packet size', 4096;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Valid range: 512 to 32767 bytes\n-- Default: 4096 bytes\n\"@\n                    Manual = @\"\n**Network Packet Size:**\n\n**Current Value: $currentValue bytes**\n**Default: $defaultValue bytes**\n\n**When to Change:**\n- Rarely beneficial to change\n- May help with bulk operations (8192)\n- May help with large result sets\n- Must test before implementing\n\n**When NOT to Change:**\n- Default works for 99% of workloads\n- Can increase memory pressure\n- Can cause network fragmentation\n- No clear performance issue to solve\n\n**Microsoft Guidance:**\n- Leave at default unless testing proves benefit\n- Application can override via connection string\n- Server setting is just the default\n\n**If Changed:**\n1. Document why it was changed\n2. Verify performance benefit\n3. Monitor for issues:\n   - Increased memory usage\n   - Network errors\n   - Slower small queries\n4. Consider per-application setting instead\n\n**Connection String Override:**\nApplications can specify packet size:\n\"Packet Size=8192\" in connection string\n\nThis is preferred over changing server default.\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/configure-the-network-packet-size-server-configuration-option\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Setting = \"network packet size\"\n                    CurrentValue = $currentValue\n                    DefaultValue = $defaultValue\n                    Status = if ($isDefault) { \"✅ Default\" } else { \"⚠️ Non-Default\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Configuration\"; CheckName = \"Network Packet Size\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check network packet size\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 63\n        \n        # ============================================================================\n        # CHECK 64: REMOTE ADMIN CONNECTIONS (DAC) (Configuration)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 64 -CheckName \"Remote Admin Connections (DAC)\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [64/$totalChecks] Checking remote DAC configuration...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue\nFROM sys.configurations\nWHERE name = 'remote admin connections';\n\"@\n            $dac = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $isEnabled = $dac.CurrentValue -eq 1\n            \n            $serverResults.Checks += @{\n                Category = \"Configuration\"\n                CheckName = \"Remote Admin Connections (DAC)\"\n                Status = if ($isEnabled) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($isEnabled) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if Dedicated Administrator Connection (DAC) is enabled for remote connections\"\n                Impact = \"DAC provides emergency access when SQL Server is unresponsive. By default, DAC only works locally. Enabling remote DAC allows troubleshooting from management workstations when you cannot log into the server console. Essential for remote administration and critical troubleshooting scenarios. Recommended for production servers, especially clustered or Always On environments where physical access may be limited.\"\n                CurrentValue = @{\n                    RemoteDAC = if ($isEnabled) { \"Enabled\" } else { \"Disabled\" }\n                }\n                RecommendedAction = if ($isEnabled) { \"Remote DAC is enabled for emergency access\" } else { \"Consider enabling remote DAC for emergency remote troubleshooting\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current setting\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name RemoteDacConnectionsEnabled | Format-Table\n\n# Enable remote DAC\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name RemoteDacConnectionsEnabled -Value 1\n\n# Verify\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name RemoteDacConnectionsEnabled | Format-Table\n\n# Test DAC connection (from remote machine)\n# sqlcmd -S ADMIN:ServerName -E -Q \"SELECT @@SERVERNAME\"\n\"@\n                    TSQL = @\"\n-- Check current setting\nEXEC sp_configure 'remote admin connections';\nGO\n\n-- Enable remote DAC\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nGO\nEXEC sp_configure 'remote admin connections', 1;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Test DAC (locally)\n-- Connect using: ADMIN:ServerName in SSMS\n\"@\n                    Manual = @\"\n**Dedicated Administrator Connection (DAC):**\n\n**What is DAC:**\n- Special diagnostic connection\n- Always available even when server is unresponsive\n- Limited to one connection at a time\n- Bypasses resource governor\n- Useful for emergency troubleshooting\n\n**Remote DAC:**\n- By default: DAC only works locally (console access)\n- When enabled: Can connect via network\n- Connect using: ADMIN:ServerName prefix\n\n**When to Use DAC:**\n- SQL Server is not responding\n- Need to kill blocking processes\n- Emergency maintenance\n- Investigating performance issues\n- Server at max connections\n\n**Connection Examples:**\n- SSMS: ADMIN:SERVERNAME\\\\INSTANCE\n- sqlcmd: sqlcmd -S ADMIN:SERVERNAME -E\n- Only one DAC connection allowed at a time\n\n**Security:**\n- Only sysadmin can use DAC\n- Connection is logged\n- Should be monitored/audited\n\n**Recommendation:**\n- Enable for production servers\n- Essential for remote administration\n- Document DAC usage procedures\n- Test DAC connectivity periodically\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/diagnostic-connection-for-database-administrators\",\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/remote-admin-connections-server-configuration-option\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Setting = \"remote admin connections\"\n                    CurrentValue = if ($isEnabled) { \"Enabled\" } else { \"Disabled\" }\n                    Status = if ($isEnabled) { \"✅ Enabled\" } else { \"❌ Disabled\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Configuration\"; CheckName = \"Remote DAC\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check DAC\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 64\n        \n        # ============================================================================\n        # CHECK 65: INSTANT FILE INITIALIZATION (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 65 -CheckName \"Instant File Initialization\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [65/$totalChecks] Checking instant file initialization...\"\n        \n        try {\n            # Check if SQL service account has SeManageVolumePrivilege (IFI)\n            $query = \"SELECT SERVERPROPERTY('InstanceName') AS InstanceName, SERVERPROPERTY('Edition') AS Edition\"\n            $instance = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            # IFI status is available in sys.dm_server_services (SQL 2016+) or error log\n            $ifiQuery = @\"\nSELECT \n    instant_file_initialization_enabled AS IFIEnabled\nFROM sys.dm_server_services\nWHERE servicename LIKE 'SQL Server%'\nAND servicename NOT LIKE '%Agent%'\nAND servicename NOT LIKE '%Browser%';\n\"@\n            \n            try {\n                $ifiStatus = Invoke-DbaQuery -SqlInstance $conn -Query $ifiQuery\n                $ifiEnabled = if ($ifiStatus -and $ifiStatus.IFIEnabled -ne $null) { $ifiStatus.IFIEnabled -eq 'Y' } else { $null }\n            } catch {\n                # Fallback for older SQL versions - check via error log\n                $ifiEnabled = $null\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Instant File Initialization (IFI)\"\n                Status = if ($ifiEnabled -eq $true) { \"✅ Pass\" } elseif ($ifiEnabled -eq $false) { \"⚠️ Warning\" } else { \"ℹ️ Info\" }\n                Severity = if ($ifiEnabled -eq $true) { \"Pass\" } elseif ($ifiEnabled -eq $false) { \"Warning\" } else { \"Info\" }\n                Description = \"Checks if Instant File Initialization is enabled for faster database file operations\"\n                Impact = \"IFI dramatically speeds up data file growth and database creation/restore by skipping zero-initialization. Without IFI, SQL Server must write zeros to entire file, which can take hours for large files. With IFI, file operations complete instantly. Essential for large databases. Does NOT apply to log files (always zero-initialized for safety). Minimal security consideration: Previously deleted disk data could be readable (rare concern).\"\n                CurrentValue = @{\n                    IFIEnabled = if ($ifiEnabled -eq $true) { \"Enabled\" } elseif ($ifiEnabled -eq $false) { \"Disabled\" } else { \"Unable to determine (check manually)\" }\n                }\n                RecommendedAction = if ($ifiEnabled -eq $true) { \"IFI is enabled\" } elseif ($ifiEnabled -eq $false) { \"Enable IFI to improve database file operations\" } else { \"Verify IFI status manually\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check IFI status (SQL 2016+)\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT instant_file_initialization_enabled\nFROM sys.dm_server_services\nWHERE servicename LIKE 'SQL Server%'\n'@ | Format-Table\n\n# Enable IFI (requires local admin on server)\n# Option 1: Use Local Security Policy GUI\n# Option 2: Use PowerShell (run on SQL Server as admin):\n`$sqlServiceAccount = (Get-Service 'MSSQLSERVER').StartName  # Adjust service name\nsecedit /export /cfg C:\\\\temp\\\\secpol.cfg\n# Edit secpol.cfg to add SQL service account to SeManageVolumePrivilege\nsecedit /configure /db C:\\\\temp\\\\secpol.sdb /cfg C:\\\\temp\\\\secpol.cfg\n# Then restart SQL Server service\n\"@\n                    TSQL = @\"\n-- Check IFI status (SQL 2016+)\nSELECT \n    servicename,\n    instant_file_initialization_enabled AS IFI_Enabled\nFROM sys.dm_server_services\nWHERE servicename LIKE 'SQL Server%';\n\n-- Verify via error log (look for IFI message at startup)\nEXEC xp_readerrorlog 0, 1, 'Database Instant File Initialization';\n\n-- Note: Enabling IFI requires Windows-level permissions\n-- Cannot be enabled via T-SQL\n\"@\n                    Manual = @\"\n**Enabling Instant File Initialization:**\n\n**Steps:**\n1. Identify SQL Server service account\n   - SQL Configuration Manager → SQL Server Services\n   - Note the \"Log On As\" account\n\n2. Grant SE_MANAGE_VOLUME_NAME privilege:\n   **Option A - Local Security Policy (GUI):**\n   - Run: secpol.msc\n   - Local Policies → User Rights Assignment\n   - \"Perform volume maintenance tasks\"\n   - Add SQL service account\n   \n   **Option B - Command line:**\n   - Run as Administrator\n   - secpol.msc or use GPO\n\n3. Restart SQL Server service (REQUIRED)\n\n4. Verify in error log:\n   - Look for \"Database Instant File Initialization: enabled\"\n\n**Benefits:**\n- Database restore: Hours → Minutes\n- Data file growth: Seconds instead of minutes\n- Database creation: Nearly instant\n- TempDB recreate: Much faster (at startup)\n\n**Security Consideration:**\n- Deleted file contents might be readable\n- Generally not a concern in practice\n- Benefits far outweigh minimal risk\n\n**Important:**\n- Only affects DATA files (.mdf, .ndf)\n- Does NOT affect LOG files (.ldf)\n- Log files always zero-initialized (by design)\n\n**Current Status:**\n$(if ($ifiEnabled -eq $true) { '✅ Enabled' } elseif ($ifiEnabled -eq $false) { '❌ Disabled - Enable immediately!' } else { 'ℹ️ Unknown - Check manually' })\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/database-instant-file-initialization\",\n                    \"https://www.brentozar.com/archive/2021/01/how-to-enable-instant-file-initialization/\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Feature = \"Instant File Initialization\"\n                    Status = if ($ifiEnabled -eq $true) { \"✅ Enabled\" } elseif ($ifiEnabled -eq $false) { \"❌ Disabled\" } else { \"❓ Unknown\" }\n                    Note = if ($ifiEnabled -eq $null) { \"Check sys.dm_server_services or error log manually\" } else { \"\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Instant File Init\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check IFI\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 65\n        \n        # ============================================================================\n        # CHECK 66: TRACE FLAGS (Configuration)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 66 -CheckName \"Trace Flags\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [66/$totalChecks] Checking trace flags...\"\n        \n        try {\n            $query = \"DBCC TRACESTATUS(-1) WITH NO_INFOMSGS\"\n            $traceFlags = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $traceFlagTable = @()\n            \n            foreach ($tf in $traceFlags) {\n                $tfNumber = $tf.TraceFlag\n                $tfStatus = $tf.Status\n                $tfGlobal = $tf.Global\n                $tfSession = $tf.Session\n                \n                # Common/recommended trace flags\n                $description = switch ($tfNumber) {\n                    1117 { \"Grow all files in filegroup equally (deprecated in SQL 2016+, use AUTOGROW_ALL_FILES)\" }\n                    1118 { \"Reduce tempdb contention (deprecated in SQL 2016+, default behavior changed)\" }\n                    1222 { \"Return resources involved in deadlocks in XML format\" }\n                    2528 { \"Disable parallel checking of objects during DBCC CHECKDB\" }\n                    3226 { \"Suppress successful backup messages in error log\" }\n                    4199 { \"Enable query optimizer fixes (use with caution)\" }\n                    7412 { \"Enable lightweight query execution statistics profiling\" }\n                    default { \"Trace flag $tfNumber\" }\n                }\n                \n                $traceFlagTable += [PSCustomObject]@{\n                    TraceFlag = $tfNumber\n                    Status = if ($tfStatus -eq 1) { \"✅ On\" } else { \"❌ Off\" }\n                    Global = $tfGlobal\n                    Description = $description\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Configuration\"\n                CheckName = \"Trace Flags\"\n                Status = if ($traceFlags.Count -eq 0) { \"ℹ️ Info\" } else { \"ℹ️ Info\" }\n                Severity = \"Info\"\n                Description = \"Lists currently enabled trace flags for documentation and review\"\n                Impact = \"Trace flags modify SQL Server behavior. Some are recommended (3226 for suppressing backup messages, 1222 for deadlock info). Others should be used with caution (4199 query optimizer changes). Trace flags 1117/1118 are no longer needed in SQL 2016+ due to default behavior changes. Document all trace flags and their purpose. Remove obsolete flags. Ensure flags are set at startup via -T parameter.\"\n                CurrentValue = @{\n                    TotalTraceFlags = $traceFlags.Count\n                }\n                RecommendedAction = if ($traceFlags.Count -eq 0) { \"No trace flags enabled\" } else { \"Review trace flags for appropriateness and documentation\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current trace flags\nInvoke-DbaQuery -SqlInstance '$serverName' -Query 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS' | Format-Table\n\n# Common recommended trace flags:\n# TF 3226 - Suppress successful backup messages\nInvoke-DbaQuery -SqlInstance '$serverName' -Query 'DBCC TRACEON(3226, -1)'\n\n# TF 1222 - Detailed deadlock information\nInvoke-DbaQuery -SqlInstance '$serverName' -Query 'DBCC TRACEON(1222, -1)'\n\n# Make trace flags permanent (add to startup)\n# SQL Configuration Manager → SQL Server Properties → Startup Parameters\n# Add: -T3226 -T1222\n\"@\n                    TSQL = @\"\n-- Check enabled trace flags\nDBCC TRACESTATUS(-1) WITH NO_INFOMSGS;\n\n-- Enable trace flag (session-level)\nDBCC TRACEON(3226);\n\n-- Enable trace flag (global)\nDBCC TRACEON(3226, -1);\n\n-- Disable trace flag\nDBCC TRACEOFF(3226, -1);\n\n-- Common Trace Flags:\n-- 3226: Suppress successful backup log entries\n-- 1222: Deadlock details in XML format\n-- 1117: Obsolete in SQL 2016+ (use AUTOGROW_ALL_FILES)\n-- 1118: Obsolete in SQL 2016+ (uniform extent allocation default)\n-- 4199: Enable optimizer hotfixes (test first!)\n-- 7412: Lightweight query profiling (SQL 2016+)\n\n-- To make permanent: add -T flag to startup parameters\n\"@\n                    Manual = @\"\n**Common Trace Flags:**\n\n**Recommended:**\n- **TF 3226**: Suppress successful backup messages in error log\n  - Reduces log noise\n  - Safe to enable\n  \n- **TF 1222**: Return detailed deadlock information in XML\n  - Essential for troubleshooting deadlocks\n  - Recommended for production\n\n**Caution:**\n- **TF 4199**: Enable query optimizer fixes\n  - Can change query plans\n  - Test thoroughly before production\n  - Better: Use query hint or database compat level\n\n**Obsolete (SQL 2016+):**\n- **TF 1117**: Even file growth in filegroup\n  - Now default behavior via AUTOGROW_ALL_FILES\n  - Remove if on SQL 2016+\n  \n- **TF 1118**: Uniform extent allocation\n  - Now default for tempdb in SQL 2016+\n  - Can remove for tempdb\n\n**Making Trace Flags Permanent:**\n1. SQL Configuration Manager\n2. SQL Server Services → Right-click → Properties\n3. Startup Parameters\n4. Add: -T#### (e.g., -T3226)\n5. Restart SQL Server (required)\n\n**Current Trace Flags: $($traceFlags.Count)**\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-traceon-transact-sql\",\n                    \"https://learn.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-tracestatus-transact-sql\"\n                )\n                RawData = if ($traceFlagTable.Count -gt 0) { $traceFlagTable } else { @([PSCustomObject]@{ Status = \"No trace flags enabled\"; Message = \"\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Configuration\"; CheckName = \"Trace Flags\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check trace flags\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 66\n        \n        # ============================================================================\n        # CHECK 67: LINKED SERVERS (Configuration/Security)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 67 -CheckName \"Linked Servers\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [67/$totalChecks] Checking linked servers configuration...\"\n        \n        try {\n            $query = @\"\nSELECT \n    s.name AS LinkedServerName,\n    s.product AS Product,\n    s.provider AS Provider,\n    s.data_source AS DataSource,\n    l.remote_name AS RemoteLogin,\n    CASE l.uses_self_credential\n        WHEN 1 THEN 'Self'\n        ELSE 'Mapped'\n    END AS CredentialType\nFROM sys.servers s\nLEFT JOIN sys.linked_logins l ON s.server_id = l.server_id\nWHERE s.is_linked = 1\nORDER BY s.name;\n\"@\n            $linkedServers = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $linkedServerTable = @()\n            \n            foreach ($ls in $linkedServers) {\n                $linkedServerTable += [PSCustomObject]@{\n                    LinkedServer = $ls.LinkedServerName\n                    Product = $ls.Product\n                    Provider = $ls.Provider\n                    DataSource = $ls.DataSource\n                    CredentialType = $ls.CredentialType\n                    Status = \"ℹ️ Review\"\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Configuration\"\n                CheckName = \"Linked Servers\"\n                Status = if ($linkedServers.Count -eq 0) { \"ℹ️ Info\" } else { \"ℹ️ Info\" }\n                Severity = \"Info\"\n                Description = \"Lists configured linked servers for security review and documentation\"\n                Impact = \"Linked servers allow querying remote data sources but introduce security risks: stored credentials, potential SQL injection through dynamic SQL, performance issues with large result sets, and complex troubleshooting. Review all linked servers regularly: verify they're still needed, check credential storage, audit usage, consider alternatives like SSIS or application-layer integration. Orphaned or unused linked servers should be removed.\"\n                CurrentValue = @{\n                    TotalLinkedServers = $linkedServers.Count\n                }\n                RecommendedAction = if ($linkedServers.Count -eq 0) { \"No linked servers configured\" } else { \"Review linked servers for security, usage, and necessity\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List linked servers\nGet-DbaLinkedServer -SqlInstance '$serverName' | Format-Table\n\n# Test linked server connectivity\nTest-DbaLinkedServer -SqlInstance '$serverName' | Format-Table\n\n# Remove linked server (if not needed)\nRemove-DbaLinkedServer -SqlInstance '$serverName' -LinkedServer 'ServerName' -Confirm:`$false\n\"@\n                    TSQL = @\"\n-- List linked servers\nSELECT * FROM sys.servers WHERE is_linked = 1;\n\n-- List linked server logins\nSELECT \n    s.name AS LinkedServer,\n    l.local_principal_id,\n    l.remote_name\nFROM sys.linked_logins l\nINNER JOIN sys.servers s ON l.server_id = s.server_id;\n\n-- Test linked server\nSELECT * FROM [LinkedServerName].master.sys.databases;\n\n-- Drop linked server\nEXEC sp_dropserver @server='LinkedServerName', @droplogins='droplogins';\n\"@\n                    Manual = @\"\n**Linked Server Security Review:**\n\n**Review Checklist:**\n1. Is the linked server still needed?\n2. Can this be replaced with:\n   - SSIS package?\n   - Application-layer integration?\n   - Replication?\n   - API call?\n\n3. Security concerns:\n   - How are credentials stored?\n   - Are sa/admin accounts used?\n   - Is self-credential mapping used?\n   - Can access be restricted?\n\n4. Performance:\n   - Large result sets?\n   - Frequent calls?\n   - Network latency issues?\n\n5. Maintenance:\n   - Is this documented?\n   - Is there an owner?\n   - When was it last used?\n\n**Best Practices:**\n- Use Windows Authentication when possible\n- Least privilege for remote logins\n- Avoid sa or admin accounts\n- Document purpose and owner\n- Regular usage audit\n- Remove unused linked servers\n- Consider alternatives (SSIS, APIs)\n- Monitor for failed connection attempts\n\n**Current Count: $($linkedServers.Count)**\n$(if ($linkedServers.Count -eq 0) { 'No linked servers configured' } else { 'Review each linked server for necessity' })\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/linked-servers/linked-servers-database-engine\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/linked-servers/create-linked-servers-sql-server-database-engine\"\n                )\n                RawData = if ($linkedServerTable.Count -gt 0) { $linkedServerTable } else { @([PSCustomObject]@{ Status = \"No linked servers\"; Message = \"\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Configuration\"; CheckName = \"Linked Servers\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check linked servers\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 67\n        \n        # ============================================================================\n        # CHECK 68: SQL SERVER AGENT STATUS (Operational)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 68 -CheckName \"SQL Server Agent Status\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [68/$totalChecks] Checking SQL Server Agent status...\"\n        \n        try {\n            $query = @\"\nSELECT \n    CASE WHEN EXISTS (SELECT 1 FROM master.dbo.sysprocesses WHERE program_name LIKE 'SQLAgent%')\n        THEN 1\n        ELSE 0\n    END AS AgentRunning;\n\"@\n            $agentStatus = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $isRunning = $agentStatus.AgentRunning -eq 1\n            \n            $serverResults.Checks += @{\n                Category = \"Operational\"\n                CheckName = \"SQL Server Agent Status\"\n                Status = if ($isRunning) { \"✅ Pass\" } else { \"❌ Error\" }\n                Severity = if ($isRunning) { \"Pass\" } else { \"Error\" }\n                Description = \"Checks if SQL Server Agent service is running\"\n                Impact = \"SQL Server Agent is essential for automated tasks: backups, maintenance plans, SSIS packages, replication, alerts, and monitoring. If Agent is stopped, no jobs run, backups fail, and critical alerts don't fire. This can lead to data loss, full transaction logs, and undetected issues. Agent should always be running on production servers and set to automatic startup.\"\n                CurrentValue = @{\n                    AgentStatus = if ($isRunning) { \"Running\" } else { \"Stopped\" }\n                }\n                RecommendedAction = if ($isRunning) { \"SQL Server Agent is running\" } else { \"Start SQL Server Agent immediately and set to automatic startup\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check Agent status\nGet-DbaAgentServer -SqlInstance '$serverName' | Select-Object SqlInstance, IsRunning | Format-Table\n\n# Start SQL Agent\nStart-DbaAgentServer -SqlInstance '$serverName'\n\n# Set SQL Agent to automatic startup\nSet-DbaStartupParameter -SqlInstance '$serverName' -AgentStartup Automatic\n\n# Alternative: Use services\nGet-Service -Name 'SQLSERVERAGENT' | Start-Service\nSet-Service -Name 'SQLSERVERAGENT' -StartupType Automatic\n\"@\n                    TSQL = @\"\n-- Check if Agent is running\nSELECT \n    CASE WHEN EXISTS (\n        SELECT 1 FROM master.dbo.sysprocesses \n        WHERE program_name LIKE 'SQLAgent%'\n    )\n    THEN 'Running'\n    ELSE 'Stopped'\n    END AS AgentStatus;\n\n-- Check via xp_servicecontrol\nEXEC xp_servicecontrol 'QUERYSTATE', 'SQLSERVERAGENT';\n\n-- Note: Starting Agent requires Windows-level access\n-- Use Services.msc or PowerShell\n\"@\n                    Manual = @\"\n**Starting SQL Server Agent:**\n\n**Via Services:**\n1. Run: services.msc\n2. Find: SQL Server Agent (MSSQLSERVER) or (InstanceName)\n3. Right-click → Start\n4. Right-click → Properties\n5. Startup type: Automatic\n6. Click OK\n\n**Via SQL Configuration Manager:**\n1. SQL Server Configuration Manager\n2. SQL Server Services\n3. Right-click SQL Server Agent\n4. Properties → Service tab\n5. Start Mode: Automatic\n6. Start the service\n\n**Common Reasons Agent Stops:**\n- Manual intervention\n- Server restart (if not set to automatic)\n- Service account password change\n- Insufficient permissions\n- Startup stored procedure failure\n\n**Critical Impact if Stopped:**\n- No backups run\n- No maintenance tasks\n- No alerts fire\n- No monitoring\n- Transaction logs fill up\n- Replication stops\n\n**Immediate Actions:**\n1. Start Agent service\n2. Set to automatic startup\n3. Investigate why it stopped\n4. Check error logs\n5. Verify backups ran\n6. Check transaction log space\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/ssms/agent/start-stop-or-pause-the-sql-server-agent-service\",\n                    \"https://learn.microsoft.com/en-us/sql/ssms/agent/sql-server-agent\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Service = \"SQL Server Agent\"\n                    Status = if ($isRunning) { \"✅ Running\" } else { \"❌ Stopped\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Operational\"; CheckName = \"SQL Agent Status\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check Agent status\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 68\n        \n        # ============================================================================\n        # CHECK 69: FAILED SQL AGENT JOBS (Operational)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 69 -CheckName \"Failed SQL Agent Jobs\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [69/$totalChecks] Checking for failed SQL Agent jobs...\"\n        \n        try {\n            $query = @\"\nSELECT TOP 20\n    j.name AS JobName,\n    jh.step_name AS StepName,\n    jh.run_date AS RunDate,\n    jh.run_time AS RunTime,\n    jh.run_duration AS Duration,\n    jh.message AS ErrorMessage\nFROM msdb.dbo.sysjobhistory jh\nINNER JOIN msdb.dbo.sysjobs j ON jh.job_id = j.job_id\nWHERE jh.run_status = 0  -- Failed\nAND jh.run_date >= CONVERT(INT, CONVERT(VARCHAR(8), DATEADD(DAY, -7, GETDATE()), 112))  -- Last 7 days\nORDER BY jh.run_date DESC, jh.run_time DESC;\n\"@\n            $failedJobs = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $failedJobTable = @()\n            \n            foreach ($job in $failedJobs) {\n                # Convert run_date and run_time to readable format\n                $runDateStr = $job.RunDate.ToString()\n                $runTimeStr = $job.RunTime.ToString().PadLeft(6, '0')\n                $runDateTime = \"$($runDateStr.Substring(0,4))-$($runDateStr.Substring(4,2))-$($runDateStr.Substring(6,2)) $($runTimeStr.Substring(0,2)):$($runTimeStr.Substring(2,2)):$($runTimeStr.Substring(4,2))\"\n                \n                $failedJobTable += [PSCustomObject]@{\n                    JobName = $job.JobName\n                    StepName = $job.StepName\n                    RunDateTime = $runDateTime\n                    ErrorMessage = if ($job.ErrorMessage.Length -gt 100) { $job.ErrorMessage.Substring(0, 100) + \"...\" } else { $job.ErrorMessage }\n                    Status = \"❌ Failed\"\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Operational\"\n                CheckName = \"Failed SQL Agent Jobs (Last 7 Days)\"\n                Status = if ($failedJobs.Count -eq 0) { \"✅ Pass\" } elseif ($failedJobs.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($failedJobs.Count -eq 0) { \"Pass\" } elseif ($failedJobs.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies SQL Agent jobs that have failed in the last 7 days\"\n                Impact = \"Failed jobs indicate problems with backups, maintenance, ETL processes, or monitoring. Common causes: insufficient permissions, disk space, network issues, code errors. Failed backup jobs can lead to data loss. Failed maintenance jobs cause performance degradation and index fragmentation. Review and fix all failures promptly. Implement job failure alerts.\"\n                CurrentValue = @{\n                    FailedJobsLast7Days = $failedJobs.Count\n                }\n                RecommendedAction = if ($failedJobs.Count -eq 0) { \"No failed jobs in last 7 days\" } else { \"Investigate and resolve $($failedJobs.Count) failed job execution(s)\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List failed jobs\nGet-DbaAgentJobHistory -SqlInstance '$serverName' -StartDate (Get-Date).AddDays(-7) -ExcludeJobSteps |\n    Where-Object { `$_.Status -eq 'Failed' } |\n    Select-Object JobName, StepName, RunDate, Message |\n    Format-Table\n\n# Get job details\nGet-DbaAgentJob -SqlInstance '$serverName' | \n    Select-Object Name, IsEnabled, LastRunDate, LastRunOutcome |\n    Format-Table\n\n# Run a specific job manually\nStart-DbaAgentJob -SqlInstance '$serverName' -Job 'JobName'\n\n# Enable job failure alerts\n# Configure via SQL Agent → Alerts → New Alert\n\"@\n                    TSQL = @\"\n-- Failed jobs in last 7 days\nSELECT \n    j.name AS JobName,\n    jh.step_name AS StepName,\n    CONVERT(VARCHAR(20), \n        CAST(CAST(jh.run_date AS CHAR(8)) AS DATETIME) + \n        CAST(STUFF(STUFF(RIGHT('000000' + CAST(jh.run_time AS VARCHAR(6)), 6), 5, 0, ':'), 3, 0, ':') AS DATETIME),\n        120) AS RunDateTime,\n    jh.message AS ErrorMessage\nFROM msdb.dbo.sysjobhistory jh\nINNER JOIN msdb.dbo.sysjobs j ON jh.job_id = j.job_id\nWHERE jh.run_status = 0\nAND jh.run_date >= CONVERT(INT, CONVERT(VARCHAR(8), DATEADD(DAY, -7, GETDATE()), 112))\nORDER BY jh.run_date DESC, jh.run_time DESC;\n\n-- Get job configuration\nSELECT \n    name,\n    enabled,\n    description\nFROM msdb.dbo.sysjobs\nORDER BY name;\n\n-- Run job manually\nEXEC msdb.dbo.sp_start_job @job_name = 'JobName';\n\"@\n                    Manual = @\"\n**Investigating Failed Jobs:**\n\n1. **Review Error Message:**\n   - Check job history in SSMS\n   - SQL Server Agent → Jobs → Right-click → View History\n   - Look for specific error codes/messages\n\n2. **Common Failure Causes:**\n   - Insufficient disk space\n   - Permission issues\n   - Network connectivity\n   - Code/query errors\n   - Timeouts\n   - Missing dependencies\n\n3. **Specific Job Types:**\n   **Backup Jobs:**\n   - Check disk space on backup location\n   - Verify backup path exists and is accessible\n   - Check SQL Agent service account permissions\n   \n   **Maintenance Jobs:**\n   - Check for blocking/locks\n   - Verify index maintenance window\n   - Check tempdb space\n   \n   **ETL/SSIS Jobs:**\n   - Verify source/destination connectivity\n   - Check for data quality issues\n   - Review SSIS package logs\n\n4. **Set Up Alerts:**\n   - Configure email notifications\n   - Alert on job failures\n   - Review daily\n\n5. **Retry Failed Jobs:**\n   - After fixing root cause\n   - Test in non-production first\n   - Monitor for success\n\n**Current Failed Jobs: $($failedJobs.Count)**\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/ssms/agent/view-job-activity\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-tables/dbo-sysjobhistory-transact-sql\"\n                )\n                RawData = if ($failedJobTable.Count -gt 0) { $failedJobTable } else { @([PSCustomObject]@{ Status = \"✅ Pass\"; Message = \"No failed jobs in last 7 days\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Operational\"; CheckName = \"Failed Jobs\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check failed jobs\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 69\n        \n        # ============================================================================\n        # CHECK 70: SQL AGENT JOB OWNER (Security/Operational)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 70 -CheckName \"SQL Agent Job Owners\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [70/$totalChecks] Checking SQL Agent job owners...\"\n        \n        try {\n            $query = @\"\nSELECT \n    j.name AS JobName,\n    SUSER_SNAME(j.owner_sid) AS JobOwner,\n    j.enabled AS IsEnabled,\n    CASE \n        WHEN SUSER_SNAME(j.owner_sid) = 'sa' THEN 1\n        WHEN SUSER_SNAME(j.owner_sid) IS NULL THEN 1\n        ELSE 0\n    END AS IsIssue\nFROM msdb.dbo.sysjobs j\nORDER BY IsIssue DESC, j.name;\n\"@\n            $jobs = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $jobOwnerTable = @()\n            $issueJobs = @()\n            \n            foreach ($job in $jobs) {\n                $owner = $job.JobOwner\n                $isIssue = $job.IsIssue -eq 1\n                \n                if ($isIssue) {\n                    $issueJobs += $job.JobName\n                }\n                \n                $jobOwnerTable += [PSCustomObject]@{\n                    JobName = $job.JobName\n                    JobOwner = if ($owner) { $owner } else { \"<orphaned>\" }\n                    IsEnabled = if ($job.IsEnabled) { \"✅ Yes\" } else { \"❌ No\" }\n                    Status = if ($isIssue) { \"⚠️ Issue\" } else { \"✅ OK\" }\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Security\"\n                CheckName = \"SQL Agent Job Owners\"\n                Status = if ($issueJobs.Count -eq 0) { \"✅ Pass\" } elseif ($issueJobs.Count -lt 5) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($issueJobs.Count -eq 0) { \"Pass\" } elseif ($issueJobs.Count -lt 5) { \"Warning\" } else { \"Error\" }\n                Description = \"Checks for SQL Agent jobs owned by 'sa' or orphaned accounts\"\n                Impact = \"Jobs owned by 'sa' are security risk and best practice violation. If sa is disabled, jobs fail. Jobs with orphaned owners (deleted accounts) cannot run. Best practice: create dedicated service account or use ##MS_SQLAgentUser## account for job ownership. Reassign job ownership from sa to proper account. Document job owners and ensure accounts are managed.\"\n                CurrentValue = @{\n                    TotalJobs = $jobs.Count\n                    JobsWithIssues = $issueJobs.Count\n                }\n                RecommendedAction = if ($issueJobs.Count -eq 0) { \"All jobs have appropriate owners\" } else { \"Reassign $($issueJobs.Count) job(s) from sa or orphaned accounts to proper service accounts\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List jobs and their owners\nGet-DbaAgentJob -SqlInstance '$serverName' | \n    Select-Object Name, OwnerLoginName, IsEnabled |\n    Format-Table\n\n# Find jobs owned by sa\nGet-DbaAgentJob -SqlInstance '$serverName' |\n    Where-Object { `$_.OwnerLoginName -eq 'sa' } |\n    Select-Object Name, OwnerLoginName |\n    Format-Table\n\n# Change job owner\nSet-DbaAgentJob -SqlInstance '$serverName' -Job 'JobName' -OwnerLogin 'DOMAIN\\\\ServiceAccount'\n\n# Change all jobs from sa to sysadmin account\nGet-DbaAgentJob -SqlInstance '$serverName' |\n    Where-Object { `$_.OwnerLoginName -eq 'sa' } |\n    Set-DbaAgentJob -OwnerLogin 'DOMAIN\\\\ServiceAccount'\n\"@\n                    TSQL = @\"\n-- List jobs and owners\nSELECT \n    name AS JobName,\n    SUSER_SNAME(owner_sid) AS JobOwner,\n    enabled AS IsEnabled\nFROM msdb.dbo.sysjobs\nORDER BY SUSER_SNAME(owner_sid), name;\n\n-- Find jobs owned by sa\nSELECT name, SUSER_SNAME(owner_sid) AS Owner\nFROM msdb.dbo.sysjobs\nWHERE SUSER_SNAME(owner_sid) = 'sa';\n\n-- Change job owner\nUSE msdb;\nGO\nEXEC sp_update_job \n    @job_name = 'JobName',\n    @owner_login_name = 'DOMAIN\\\\ServiceAccount';\nGO\n\n-- Change all sa-owned jobs to another account\nDECLARE @NewOwner NVARCHAR(128) = 'DOMAIN\\\\ServiceAccount';\n\nDECLARE @JobName NVARCHAR(128);\nDECLARE cur CURSOR FOR\n    SELECT name \n    FROM msdb.dbo.sysjobs \n    WHERE SUSER_SNAME(owner_sid) = 'sa';\n\nOPEN cur;\nFETCH NEXT FROM cur INTO @JobName;\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    EXEC msdb.dbo.sp_update_job \n        @job_name = @JobName,\n        @owner_login_name = @NewOwner;\n    \n    FETCH NEXT FROM cur INTO @JobName;\nEND\n\nCLOSE cur;\nDEALLOCATE cur;\n\"@\n                    Manual = @\"\n**SQL Agent Job Ownership Best Practices:**\n\n**Why Not 'sa':**\n1. Security risk (sa has unlimited power)\n2. If sa is disabled, jobs fail\n3. Best practice violation\n4. Audit/compliance issues\n5. Difficult to track actual job owner\n\n**Recommended Ownership:**\n- Use dedicated service account\n- Domain account (preferred)\n- Account with minimum necessary permissions\n- Document account purpose\n- Monitor account for changes\n\n**Orphaned Job Owners:**\n- Occur when owner account is deleted\n- Jobs cannot run\n- Must reassign to valid account\n\n**Steps to Remediate:**\n1. Identify all jobs owned by sa or orphaned\n2. Create/identify proper service account\n3. Grant necessary permissions to account\n4. Reassign job ownership\n5. Test jobs run successfully\n6. Document new owner\n7. Set policy: no jobs owned by sa\n\n**Permission Requirements:**\n- Job owner needs permissions to:\n  - Execute job steps\n  - Access databases used by job\n  - Write to file system (for backups, exports)\n  - Network access (for remote operations)\n\n**Current Issues: $($issueJobs.Count)**\n$(if ($issueJobs.Count -gt 0) { '⚠️ Jobs owned by sa or orphaned - reassign immediately' } else { '✅ All jobs have proper owners' })\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/ssms/agent/set-job-execution-shutdown-sql-server-management-studio\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-update-job-transact-sql\"\n                )\n                RawData = $jobOwnerTable\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Security\"; CheckName = \"Job Owners\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check job owners\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 70\n        \n        # ============================================================================\n        # CHECK 71: DATABASE FILES ON C: DRIVE (Configuration)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 71 -CheckName \"Database Files on C: Drive\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [71/$totalChecks] Checking for database files on C: drive...\"\n        \n        try {\n            $query = @\"\nSELECT \n    d.name AS DatabaseName,\n    f.name AS FileName,\n    f.type_desc AS FileType,\n    f.physical_name AS FilePath,\n    f.size * 8 / 1024 AS SizeMB\nFROM sys.master_files f\nINNER JOIN sys.databases d ON f.database_id = d.database_id\nWHERE f.physical_name LIKE 'C:%'\nORDER BY d.name, f.type_desc;\n\"@\n            $filesOnC = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $filesTable = @()\n            \n            foreach ($file in $filesOnC) {\n                $filesTable += [PSCustomObject]@{\n                    Database = $file.DatabaseName\n                    FileName = $file.FileName\n                    FileType = $file.FileType\n                    FilePath = $file.FilePath\n                    SizeMB = $file.SizeMB\n                    Status = \"⚠️ On C: Drive\"\n                }\n            }\n            \n            $serverResults.Checks += @{\n                Category = \"Configuration\"\n                CheckName = \"Database Files on C: Drive\"\n                Status = if ($filesOnC.Count -eq 0) { \"✅ Pass\" } elseif ($filesOnC.Count -le 4) { \"⚠️ Warning\" } else { \"❌ Error\" }\n                Severity = if ($filesOnC.Count -eq 0) { \"Pass\" } elseif ($filesOnC.Count -le 4) { \"Warning\" } else { \"Error\" }\n                Description = \"Identifies database files located on the C: (system) drive\"\n                Impact = \"Database files should not be on C: drive (OS drive). Reasons: C: drive fills up causing OS instability, performance issues due to OS I/O contention, difficult to add more space, backup/restore complications. System databases (master, model, msdb) on C: may be acceptable but not ideal. User databases should ALWAYS be on dedicated drives. Risk of filling C: drive can crash server.\"\n                CurrentValue = @{\n                    FilesOnCDrive = $filesOnC.Count\n                }\n                RecommendedAction = if ($filesOnC.Count -eq 0) { \"No database files on C: drive\" } elseif ($filesOnC.Count -le 4) { \"Consider moving system databases off C: drive\" } else { \"Move user databases off C: drive immediately\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# List files on C: drive\nGet-DbaDatabaseFile -SqlInstance '$serverName' |\n    Where-Object { `$_.PhysicalName -like 'C:*' } |\n    Select-Object Database, FileGroupName, LogicalName, PhysicalName, Size |\n    Format-Table\n\n# Move database files (requires downtime)\n# 1. Take database offline\nSet-DbaDbState -SqlInstance '$serverName' -Database 'DatabaseName' -Offline\n\n# 2. Move files at OS level\nMove-Item 'C:\\\\SQLData\\\\Database.mdf' 'D:\\\\SQLData\\\\Database.mdf'\nMove-Item 'C:\\\\SQLData\\\\Database_log.ldf' 'D:\\\\SQLLogs\\\\Database_log.ldf'\n\n# 3. Update SQL Server file locations\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nALTER DATABASE DatabaseName \nMODIFY FILE (NAME = DatabaseName_Data, FILENAME = 'D:\\\\SQLData\\\\Database.mdf');\nALTER DATABASE DatabaseName \nMODIFY FILE (NAME = DatabaseName_Log, FILENAME = 'D:\\\\SQLLogs\\\\Database_log.ldf');\n'@\n\n# 4. Bring database online\nSet-DbaDbState -SqlInstance '$serverName' -Database 'DatabaseName' -Online\n\"@\n                    TSQL = @\"\n-- List files on C: drive\nSELECT \n    d.name AS DatabaseName,\n    f.name AS LogicalName,\n    f.type_desc AS FileType,\n    f.physical_name AS PhysicalPath,\n    f.size * 8 / 1024 AS SizeMB\nFROM sys.master_files f\nINNER JOIN sys.databases d ON f.database_id = d.database_id\nWHERE f.physical_name LIKE 'C:%'\nORDER BY d.name;\n\n-- Move database files (USER DATABASE)\n-- Step 1: Take database offline\nALTER DATABASE [DatabaseName] SET OFFLINE;\nGO\n\n-- Step 2: Physically move files using Windows Explorer or PowerShell\n-- From: C:\\\\SQLData\\\\Database.mdf\n-- To:   D:\\\\SQLData\\\\Database.mdf\n\n-- Step 3: Update file locations in SQL Server\nALTER DATABASE [DatabaseName]\nMODIFY FILE (NAME = 'LogicalFileName', FILENAME = 'D:\\\\SQLData\\\\Database.mdf');\nGO\n\nALTER DATABASE [DatabaseName]\nMODIFY FILE (NAME = 'LogicalLogFileName', FILENAME = 'D:\\\\SQLLogs\\\\Database_log.ldf');\nGO\n\n-- Step 4: Bring database online\nALTER DATABASE [DatabaseName] SET ONLINE;\nGO\n\n-- For SYSTEM DATABASES (master, model, msdb):\n-- Requires SQL Server service restart and startup parameter changes\n-- More complex - see documentation\n\"@\n                    Manual = @\"\n**Moving Database Files Off C: Drive:**\n\n**User Databases:**\n1. Schedule maintenance window\n2. Take database offline\n3. Move physical files:\n   - .mdf (data) to D:\\\\SQLData (or dedicated data drive)\n   - .ldf (log) to E:\\\\SQLLogs (or dedicated log drive)\n4. Update file paths in SQL Server (ALTER DATABASE... MODIFY FILE)\n5. Bring database online\n6. Test application connectivity\n\n**System Databases:**\nMore complex, requires:\n1. Stop SQL Server service\n2. Move files at OS level\n3. Update startup parameters (-d, -l, -e)\n4. Restart SQL Server\n5. Verify success\n\n**Best Practices:**\n- Data files: Dedicated drive (D:, E:, etc.)\n- Log files: Separate dedicated drive for performance\n- TempDB: Separate dedicated drive (ideally SSD)\n- Never mix OS and database files\n- Keep 15-20% free space on data drives\n\n**Why Not C: Drive:**\n- OS needs space\n- Performance: OS and DB I/O conflict\n- Maintenance: Windows updates, patches\n- Growth: C: typically smaller\n- Risk: Filling C: can crash server\n\n**Exceptions (acceptable but not ideal):**\n- System databases on small/test servers\n- Development environments\n- SQL Express with small databases\n\n**Current Files on C:: $($filesOnC.Count)**\n$(if ($filesOnC.Count -gt 0) { '⚠️ Move user databases off C: drive' } else { '✅ No files on C: drive' })\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/move-database-files\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/databases/move-system-databases\"\n                )\n                RawData = if ($filesTable.Count -gt 0) { $filesTable } else { @([PSCustomObject]@{ Status = \"✅ Pass\"; Message = \"No database files on C: drive\" }) }\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Configuration\"; CheckName = \"Files on C: Drive\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check C: drive files\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 71\n        \n        # ============================================================================\n        # CHECK 72: DEFAULT FILL FACTOR (Performance)\n        # ============================================================================\n        \n        if (-not (Should-SkipCheck -CheckNumber 72 -CheckName \"Default Fill Factor\")) {\n        \n        Send-Progress -Value ($serverProgress + ($currentCheck++ * $checkProgress)) -Message \"[$serverName] [72/$totalChecks] Checking default fill factor...\"\n        \n        try {\n            $query = @\"\nSELECT \n    name,\n    value AS ConfigValue,\n    value_in_use AS CurrentValue\nFROM sys.configurations\nWHERE name = 'fill factor (%)';\n\"@\n            $fillFactor = Invoke-DbaQuery -SqlInstance $conn -Query $query\n            \n            $currentValue = $fillFactor.CurrentValue\n            $isDefault = $currentValue -eq 0\n            \n            $serverResults.Checks += @{\n                Category = \"Performance\"\n                CheckName = \"Default Fill Factor\"\n                Status = if ($isDefault) { \"✅ Pass\" } else { \"⚠️ Warning\" }\n                Severity = if ($isDefault) { \"Pass\" } else { \"Warning\" }\n                Description = \"Checks if server-wide default fill factor is set (should be 0/100)\"\n                Impact = \"Server-wide fill factor of 0 (or 100) means indexes are filled completely, which is optimal for most workloads. Non-zero server-wide fill factor (e.g., 80) leaves space in index pages for updates, but applies to ALL indexes, wasting space for read-only tables. Problem: This is a server-wide setting affecting all new indexes. Better approach: leave server setting at 0 (default) and set fill factor per-index only where needed (high-update tables). Non-default server fill factor is usually a mistake.\"\n                CurrentValue = @{\n                    FillFactor = if ($currentValue -eq 0) { \"0 (100% - Default)\" } else { \"$currentValue%\" }\n                }\n                RecommendedAction = if ($isDefault) { \"Fill factor is at recommended default (0)\" } else { \"Consider resetting to default (0) and using index-specific fill factor where needed\" }\n                RemediationSteps = @{\n                    PowerShell = @\"\n# Check current fill factor\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name FillfactorPercentage | Format-Table\n\n# Reset to default (0)\nSet-DbaSpConfigure -SqlInstance '$serverName' -Name FillfactorPercentage -Value 0\n\n# Verify\nGet-DbaSpConfigure -SqlInstance '$serverName' -Name FillfactorPercentage | Format-Table\n\n# Check indexes with custom fill factor\nInvoke-DbaQuery -SqlInstance '$serverName' -Query @'\nSELECT \n    OBJECT_SCHEMA_NAME(object_id) + '.' + OBJECT_NAME(object_id) AS TableName,\n    name AS IndexName,\n    fill_factor\nFROM sys.indexes\nWHERE fill_factor > 0\nAND fill_factor < 100\nORDER BY OBJECT_NAME(object_id), name\n'@ | Format-Table\n\"@\n                    TSQL = @\"\n-- Check server-wide fill factor\nEXEC sp_configure 'fill factor (%)';\nGO\n\n-- Reset to default\nEXEC sp_configure 'show advanced options', 1;\nRECONFIGURE;\nGO\nEXEC sp_configure 'fill factor (%)', 0;\nRECONFIGURE WITH OVERRIDE;\nGO\n\n-- Find indexes with custom fill factor\nSELECT \n    DB_NAME() AS DatabaseName,\n    OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,\n    OBJECT_NAME(i.object_id) AS TableName,\n    i.name AS IndexName,\n    i.fill_factor AS FillFactor\nFROM sys.indexes i\nWHERE i.fill_factor > 0\nAND i.fill_factor < 100\nORDER BY SchemaName, TableName, IndexName;\n\n-- Set fill factor for specific index (proper way)\nCREATE INDEX IX_IndexName\nON SchemaName.TableName (ColumnName)\nWITH (FILLFACTOR = 80);  -- Only where needed!\n\n-- Rebuild index with fill factor\nALTER INDEX IX_IndexName\nON SchemaName.TableName\nREBUILD WITH (FILLFACTOR = 80);\n\"@\n                    Manual = @\"\n**Fill Factor Explained:**\n\n**What is Fill Factor:**\n- Percentage of index page filled with data\n- 0 or 100 = completely full (optimal for most)\n- 80 = 20% empty space left for INSERTs/UPDATEs\n\n**Server-Wide vs. Index-Specific:**\n- **Server-wide (this check)**: Applies to ALL new indexes\n- **Index-specific**: Set per index (recommended)\n\n**When to Use Non-100 Fill Factor:**\n- High-update tables with page splits\n- Indexes on random key values (GUIDs)\n- Specific problematic indexes only\n- **NOT** server-wide!\n\n**Why Server-Wide Fill Factor is Bad:**\n1. Wastes space on read-only tables\n2. Wastes space on clustered indexes (entire table)\n3. Increases storage and memory requirements\n4. Reduces buffer pool efficiency\n5. Usually set by mistake or misunderstanding\n\n**Best Practice:**\n1. Keep server-wide at 0 (default)\n2. Set fill factor on specific indexes only\n3. Monitor page splits\n4. Adjust per-index as needed\n5. Document why custom fill factor was set\n\n**Current Setting: $(if ($isDefault) { '0 (Default) ✅' } else { \"$currentValue% ⚠️ Non-default\" })**\n\n**If Non-Default:**\n1. Research why it was changed\n2. Identify indexes that truly need custom fill factor\n3. Set those indexes specifically\n4. Reset server-wide to 0\n5. Rebuild affected indexes\n\n**Monitoring Page Splits:**\nUse sys.dm_db_index_operational_stats to find:\n- leaf_allocation_count (page splits)\n- Consider fill factor 80-90 if excessive splits\n\"@\n                }\n                Documentation = @(\n                    \"https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/configure-the-fill-factor-server-configuration-option\",\n                    \"https://learn.microsoft.com/en-us/sql/relational-databases/indexes/specify-fill-factor-for-an-index\"\n                )\n                RawData = @([PSCustomObject]@{\n                    Setting = \"fill factor (%)\"\n                    CurrentValue = if ($currentValue -eq 0) { \"0 (100% - Default)\" } else { \"$currentValue%\" }\n                    Status = if ($isDefault) { \"✅ Default\" } else { \"⚠️ Non-Default\" }\n                })\n            }\n        } catch {\n            $serverResults.Checks += @{ Category = \"Performance\"; CheckName = \"Fill Factor\"; Status = \"❌ Error\"; Severity = \"Error\"; Description = \"Could not check fill factor\"; Error = $_.Exception.Message }\n        }\n        }  # End Check 72\n        \n        Write-Host \"[$serverName] Completed all $($serverResults.Checks.Count) checks!\"\n        \n        # Store server results\n        $healthCheckResults.Servers[$serverName] = $serverResults\n        \n        # Update executive summary\n        foreach ($check in $serverResults.Checks) {\n            $healthCheckResults.ExecutiveSummary.TotalChecks++\n            if ($check.Status -like \"*Pass*\" -or $check.Status -like \"*✅*\") {\n                $healthCheckResults.ExecutiveSummary.PassedChecks++\n            }\n            elseif ($check.Status -like \"*Warning*\" -or $check.Status -like \"*⚠️*\") {\n                $healthCheckResults.ExecutiveSummary.WarningChecks++\n            }\n            else {\n                $healthCheckResults.ExecutiveSummary.FailedChecks++\n            }\n        }\n    }\n    \n    # ============================================================================\n    # GENERATE COMPREHENSIVE MARKDOWN REPORT\n    # ============================================================================\n    \n    Send-Progress -Value 0.92 -Message \"Generating comprehensive Markdown report...\"\n    \n    $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n    $reportDate = Get-Date -Format \"yyyyMMdd_HHmmss\"\n    $filename = \"SQLServer_HealthCheck_${reportDate}.md\"\n    \n    # Calculate overall health score\n    $totalChecks = $healthCheckResults.ExecutiveSummary.TotalChecks\n    $passedChecks = $healthCheckResults.ExecutiveSummary.PassedChecks\n    $healthScore = if ($totalChecks -gt 0) { [math]::Round(($passedChecks / $totalChecks) * 100, 1) } else { 0 }\n    \n    # Delete file if exists\n    if (Test-Path $filename) { Remove-Item $filename -Force }\n    \n    # Helper function\n    function Add-ToReport {\n        param([string]$Content)\n        Add-Content -Path $filename -Value $Content -Encoding UTF8\n    }\n    \n    # Header\n    Add-ToReport \"# SQL Server Comprehensive Health Check Report\"\n    Add-ToReport \"\"\n    Add-ToReport \"**Report Date:** $timestamp  \"\n    Add-ToReport \"**Primary Server:** $($healthCheckResults.PrimaryServer)  \"\n    Add-ToReport \"**Servers Analyzed:** $($healthCheckResults.ExecutiveSummary.TotalServers)  \"\n    Add-ToReport \"**AG Environment:** $(if($healthCheckResults.IsAGEnvironment){'Yes'}else{'No'})  \"\n    Add-ToReport \"**Execution Platform:** $($healthCheckResults.RunningOS)  \"\n    Add-ToReport \"**Server Admin Credentials:** $(if($healthCheckResults.ServerAdminCredsProvided){'Provided'}else{'Not Provided'})  \"\n    if ($healthCheckResults.ServerAdminCredsProvided -and $healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin -gt 0) {\n        Add-ToReport \"**Checks Using Server Admin:** $($healthCheckResults.ExecutiveSummary.ChecksUsingServerAdmin)  \"\n    }\n    \n    # Add warning if running on non-Windows\n    if (-not $healthCheckResults.IsWindowsHost) {\n        Add-ToReport \"\"\n        Add-ToReport \"> **Platform Notice:** This health check was executed on $($healthCheckResults.RunningOS). Windows-specific checks (WMI, remote PowerShell) have been disabled or use T-SQL fallback methods. For optimal results including all enhanced checks, run this plugin from a Windows system.\"\n    }\n    \n    Add-ToReport \"\"\n    Add-ToReport \"---\"\n    Add-ToReport \"\"\n    \n    # Executive Dashboard\n    Add-ToReport \"## Executive Dashboard\"\n    Add-ToReport \"\"\n    Add-ToReport \"| Metric                    | Value |\"\n    Add-ToReport \"|---------------------------|-------|\"\n    Add-ToReport \"| **Overall Health Score**  | **${healthScore}%** |\"\n    Add-ToReport \"| Checks Passed             | $($healthCheckResults.ExecutiveSummary.PassedChecks) |\"\n    Add-ToReport \"| Warnings                  | $($healthCheckResults.ExecutiveSummary.WarningChecks) |\"\n    Add-ToReport \"| Failed                    | $($healthCheckResults.ExecutiveSummary.FailedChecks) |\"\n    Add-ToReport \"| Total Checks              | $($healthCheckResults.ExecutiveSummary.TotalChecks) |\"\n    \n    # Add exclusion information if checks were excluded/included\n    if ($healthCheckResults.ExecutiveSummary.ExcludedChecks -gt 0) {\n        Add-ToReport \"| **Excluded Checks**       | **$($healthCheckResults.ExecutiveSummary.ExcludedChecks)** |\"\n        if ($healthCheckResults.ExclusionMode -eq \"Inclusions\") {\n            Add-ToReport \"| Exclusion Mode            | Inclusions (running ONLY selected checks) |\"\n        } else {\n            Add-ToReport \"| Exclusion Mode            | Exclusions (skipping selected checks) |\"\n        }\n    }\n    \n    Add-ToReport \"\"\n    \n    # Show excluded checks list and reason if applicable\n    if ($healthCheckResults.ExecutiveSummary.ExcludedChecks -gt 0) {\n        Add-ToReport \"**Excluded Checks:** $($healthCheckResults.ExcludedChecks -join ', ')  \"\n        if (-not [string]::IsNullOrWhiteSpace($healthCheckResults.ExclusionReason)) {\n            Add-ToReport \"**Exclusion Reason:** $($healthCheckResults.ExclusionReason)  \"\n        }\n        Add-ToReport \"\"\n    }\n    \n    Add-ToReport \"---\"\n    Add-ToReport \"\"\n    \n    # Table of Contents\n    Add-ToReport \"## Table of Contents\"\n    Add-ToReport \"\"\n    Add-ToReport \"- [Executive Dashboard](#executive-dashboard)\"\n    Add-ToReport \"- [Table of Contents](#table-of-contents)\"\n    if ($healthCheckResults.IsAGEnvironment -and $healthCheckResults.AvailabilityGroups.Count -gt 0) {\n        Add-ToReport \"- [Availability Groups Configuration](#availability-groups-configuration)\"\n    }\n    \n    # Add server sections with their checks\n    foreach ($serverName in $healthCheckResults.Servers.Keys | Sort-Object) {\n        $serverData = $healthCheckResults.Servers[$serverName]\n        $anchorName = $serverName -replace '[^a-zA-Z0-9-]', '-' -replace '-+', '-' -replace '^-|-$', ''\n        Add-ToReport \"- [Server: $serverName](#server-$($anchorName.ToLower()))\"\n        \n        # Add check subsections\n        $checkNumber = 0\n        foreach ($check in $serverData.Checks) {\n            $checkNumber++\n            # Create display text and matching anchor - include server name in heading for uniqueness\n            $checkDisplayName = \"[$serverName] Check $checkNumber of $($serverData.Checks.Count): $($check.CheckName)\"\n            # Create anchor to match the actual heading format with server name\n            $checkAnchor = \"$serverName-check-$checkNumber-of-$($serverData.Checks.Count)-$($check.CheckName)\" -replace '[^a-zA-Z0-9-]', '-' -replace '-+', '-' -replace '^-|-$', ''\n            Add-ToReport \"  - [$checkDisplayName](#$($checkAnchor.ToLower()))\"\n        }\n    }\n    \n    Add-ToReport \"\"\n    Add-ToReport \"---\"\n    Add-ToReport \"\"\n    \n    # AG Section\n    Send-Progress -Value 0.93 -Message \"Writing Availability Group information...\"\n    Add-ToReport \"## Availability Groups Configuration\"\n    Add-ToReport \"\"\n    \n    if ($healthCheckResults.IsAGEnvironment -and $healthCheckResults.AvailabilityGroups.Count -gt 0) {\n        foreach ($ag in $healthCheckResults.AvailabilityGroups) {\n            Add-ToReport \"### $($ag.Name)\"\n            Add-ToReport \"\"\n            Add-ToReport \"- **Primary Replica:** $($ag.PrimaryReplica)\"\n            Add-ToReport \"- **Backup Preference:** $($ag.AutomatedBackupPreference)\"\n            Add-ToReport \"- **Replicas:**\"\n            foreach ($replica in $ag.Replicas) {\n                Add-ToReport \"  - **$($replica.Name)**: Role=$($replica.Role), Mode=$($replica.AvailabilityMode), Failover=$($replica.FailoverMode)\"\n            }\n            Add-ToReport \"\"\n        }\n    } else {\n        Add-ToReport \"There are no availability groups configured on the analyzed servers.\"\n        Add-ToReport \"\"\n    }\n    Add-ToReport \"---\"\n    Add-ToReport \"\"\n    \n    # Server sections\n    $serverCount = 0\n    $totalServers = $healthCheckResults.Servers.Keys.Count\n    foreach ($serverName in $healthCheckResults.Servers.Keys) {\n        $serverCount++\n        $serverProgress = 0.93 + (0.04 * ($serverCount / $totalServers))\n        Send-Progress -Value $serverProgress -Message \"Writing server report for $serverName...\"\n        \n        $serverData = $healthCheckResults.Servers[$serverName]\n        $serverInfo = $serverData.ServerInfo\n        \n        Add-ToReport \"## Server: $serverName\"\n        Add-ToReport \"\"\n        Add-ToReport \"**Edition:** $($serverInfo.Edition)  \"\n        Add-ToReport \"**Version:** $($serverInfo.Version)  \"\n        Add-ToReport \"**Build:** $($serverInfo.BuildNumber)  \"\n        Add-ToReport \"**Patch Level:** $($serverInfo.ProductUpdateLevel)  \"\n        Add-ToReport \"**Memory:** $($serverInfo.PhysicalMemoryMB) MB  \"\n        Add-ToReport \"**Processors:** $($serverInfo.Processors)  \"\n        Add-ToReport \"**Collation:** $($serverInfo.Collation)  \"\n        Add-ToReport \"\"\n        Add-ToReport \"---\"\n        Add-ToReport \"\"\n        \n        # Checks\n        $checkNumber = 0\n        $totalServerChecks = $serverData.Checks.Count\n        # Create server anchor for unique check IDs\n        $serverAnchor = $serverName -replace '[^a-zA-Z0-9-]', '-' -replace '-+', '-' -replace '^-|-$', ''\n        foreach ($check in $serverData.Checks) {\n            $checkNumber++\n            \n            Add-ToReport \"\"\n            Add-ToReport \"\"\n            Add-ToReport \"### [$serverName] Check ${checkNumber} of ${totalServerChecks}: $($check.CheckName)\"\n            Add-ToReport \"---\"\n            Add-ToReport \"\"\n            Add-ToReport \"**Status:** $($check.Status)\"\n            Add-ToReport \"**Category:** $($check.Category)\"\n            Add-ToReport \"\"\n            Add-ToReport \"**Description:** $($check.Description)\"\n            Add-ToReport \"\"\n            \n            if ($check.Impact) {\n                $impactClean = $check.Impact -replace \"`n\", \" \" -replace \"`r\", \"\"\n                Add-ToReport \"**Impact:** $impactClean\"\n                Add-ToReport \"\"\n            }\n            \n            if ($check.CurrentValue) {\n                Add-ToReport \"**Current Configuration:**\"\n                foreach ($key in $check.CurrentValue.Keys) {\n                    $value = if ($check.CurrentValue[$key] -ne $null) { $check.CurrentValue[$key] } else { \"(null)\" }\n                    Add-ToReport \"- **${key}:** $value\"\n                }\n                Add-ToReport \"\"\n            }\n            \n            # Display detailed list of problematic items RIGHT AFTER current config\n            if ($check.RawData) {\n                try {\n                    Add-ToReport \"**Affected Items:**\"\n                    Add-ToReport \"\"\n                    \n                    # Convert to array if it's a single object\n                    $dataItems = @($check.RawData)\n                    \n                    if ($dataItems.Count -gt 0 -and $dataItems.Count -le 100) {\n                        # Get properties from first item to create table header\n                        $firstItem = $dataItems[0]\n                        $properties = $firstItem.PSObject.Properties.Name\n                        \n                        # Create markdown table\n                        $headerRow = \"| \" + ($properties -join \" | \") + \" |\"\n                        $separatorRow = \"|\" + (($properties | ForEach-Object { \"---\" }) -join \"|\") + \"|\"\n                        \n                        Add-ToReport $headerRow\n                        Add-ToReport $separatorRow\n                        \n                        # Add data rows\n                        foreach ($item in $dataItems) {\n                            $values = @()\n                            foreach ($prop in $properties) {\n                                $val = $item.$prop\n                                if ($null -eq $val) { $val = \"\" }\n                                $values += $val\n                            }\n                            $dataRow = \"| \" + ($values -join \" | \") + \" |\"\n                            Add-ToReport $dataRow\n                        }\n                    } elseif ($dataItems.Count -gt 100) {\n                        Add-ToReport \"*Too many items to display ($($dataItems.Count) items). Showing first 100:*\"\n                        Add-ToReport \"\"\n                        \n                        # Show first 100 items\n                        $firstItem = $dataItems[0]\n                        $properties = $firstItem.PSObject.Properties.Name\n                        \n                        $headerRow = \"| \" + ($properties -join \" | \") + \" |\"\n                        $separatorRow = \"|\" + (($properties | ForEach-Object { \"---\" }) -join \"|\") + \"|\"\n                        \n                        Add-ToReport $headerRow\n                        Add-ToReport $separatorRow\n                        \n                        foreach ($item in $dataItems[0..99]) {\n                            $values = @()\n                            foreach ($prop in $properties) {\n                                $val = $item.$prop\n                                if ($null -eq $val) { $val = \"\" }\n                                $values += $val\n                            }\n                            $dataRow = \"| \" + ($values -join \" | \") + \" |\"\n                            Add-ToReport $dataRow\n                        }\n                    }\n                    Add-ToReport \"\"\n                } catch {\n                    # If table formatting fails, just skip\n                }\n            }\n            \n            if ($check.RecommendedAction) {\n                Add-ToReport \"**Recommended Action:** $($check.RecommendedAction)\"\n                Add-ToReport \"\"\n            }\n            \n            if ($check.RemediationSteps) {\n                Add-ToReport \"**Remediation Steps:**\"\n                Add-ToReport \"\"\n                \n                if ($check.RemediationSteps.PowerShell) {\n                    Add-ToReport \"**PowerShell:**\"\n                    Add-ToReport '```powershell'\n                    Add-ToReport $check.RemediationSteps.PowerShell\n                    Add-ToReport '```'\n                    Add-ToReport \"\"\n                }\n                if ($check.RemediationSteps.TSQL) {\n                    Add-ToReport \"**T-SQL:**\"\n                    Add-ToReport '```sql'\n                    Add-ToReport $check.RemediationSteps.TSQL\n                    Add-ToReport '```'\n                    Add-ToReport \"\"\n                }\n                if ($check.RemediationSteps.Manual) {\n                    Add-ToReport \"**Manual Steps:**\"\n                    Add-ToReport '```'\n                    Add-ToReport $check.RemediationSteps.Manual\n                    Add-ToReport '```'\n                    Add-ToReport \"\"\n                }\n            }\n            \n            if ($check.Documentation) {\n                Add-ToReport \"**Documentation:**\"\n                foreach ($link in $check.Documentation) {\n                    Add-ToReport \"- $link\"\n                }\n                Add-ToReport \"\"\n            }\n            \n            Add-ToReport \"---\"\n            Add-ToReport \"\"\n        }\n    }\n    \n    # Footer\n    Send-Progress -Value 0.97 -Message \"Finalizing Markdown report...\"\n    Add-ToReport \"\"\n    Add-ToReport \"---\"\n    Add-ToReport \"\"\n    Add-ToReport \"## Report Information\"\n    Add-ToReport \"\"\n    Add-ToReport \"**SQL Server Health Check Report**\"\n    Add-ToReport \"Generated by xyOps MSSQL Health Check Plugin\"\n    Add-ToReport \"Copyright 2026 Tim Alderweireldt\"\n    Add-ToReport \"Report Date: $timestamp\"\n    \n    Write-Host \"\"\n    Write-Host \"Markdown report saved: $filename\"\n    \n    # Export to PDF if requested\n    $pdfFilename = $null\n    $exportToPdf = $exportToPdfRaw -eq $true -or $exportToPdfRaw -eq \"true\" -or $exportToPdfRaw -eq \"True\"\n    \n    if ($exportToPdf) {\n        Send-Progress -Value 0.95 -Message \"Converting Markdown to PDF...\"\n        Write-Host \"PDF export requested - converting Markdown to PDF...\"\n        \n        try {\n            # Check if pandoc is available\n            $pandocAvailable = $null -ne (Get-Command pandoc -ErrorAction SilentlyContinue)\n            \n            if ($pandocAvailable) {\n                # Use pandoc for conversion\n                $pdfFilename = $filename -replace '\\.md$', '.pdf'\n                $pandocArgs = @(\n                    $filename,\n                    '-o', $pdfFilename,\n                    '--pdf-engine=xelatex',\n                    '-V', 'geometry:margin=1in',\n                    '-V', 'fontsize=10pt',\n                    '--toc',\n                    '--toc-depth=3'\n                )\n                \n                Write-Host \"Converting with pandoc...\"\n                & pandoc $pandocArgs 2>&1 | Out-Null\n                \n                if (Test-Path $pdfFilename) {\n                    Write-Host \"PDF report saved: $pdfFilename\"\n                } else {\n                    Write-Host \"Warning: PDF conversion completed but file not found\"\n                    $pdfFilename = $null\n                }\n            } else {\n                # Pandoc not available - try markdown-pdf via npm\n                Write-Host \"Pandoc not found, attempting markdown-pdf...\"\n                $markdownPdfAvailable = $null -ne (Get-Command markdown-pdf -ErrorAction SilentlyContinue)\n                \n                if ($markdownPdfAvailable) {\n                    $pdfFilename = $filename -replace '\\.md$', '.pdf'\n                    & markdown-pdf $filename -o $pdfFilename 2>&1 | Out-Null\n                    \n                    if (Test-Path $pdfFilename) {\n                        Write-Host \"PDF report saved: $pdfFilename\"\n                    } else {\n                        Write-Host \"Warning: PDF conversion completed but file not found\"\n                        $pdfFilename = $null\n                    }\n                } else {\n                    Write-Host \"Warning: PDF export requested but no converter found (pandoc or markdown-pdf)\"\n                    Write-Host \"Install pandoc: https://pandoc.org/installing.html\"\n                    Write-Host \"Or install markdown-pdf: npm install -g markdown-pdf\"\n                    Write-Host \"Markdown report will still be available.\"\n                }\n            }\n        } catch {\n            Write-Host \"Warning: PDF conversion failed: $($_.Exception.Message)\"\n            Write-Host \"Markdown report will still be available.\"\n            $pdfFilename = $null\n        }\n    }\n    \n    # Output file references to xyOps\n    Send-Progress -Value 0.98 -Message \"Finalizing report...\"\n    $filesToExport = @(\n        @{\n            path = $filename\n            name = $filename\n        }\n    )\n    \n    if ($pdfFilename -and (Test-Path $pdfFilename)) {\n        $filesToExport += @{\n            path = $pdfFilename\n            name = $pdfFilename\n        }\n    }\n    \n    Write-Output-JSON @{\n        xy = 1\n        files = $filesToExport\n    }\n    \n    Send-Progress -Value 1.0 -Message \"Health check completed successfully!\"\n    \n    $summary = \"Health check completed successfully:`n\"\n    $summary += \"  * Servers checked: $($healthCheckResults.ExecutiveSummary.TotalServers)`n\"\n    $summary += \"  * Total checks: $($healthCheckResults.ExecutiveSummary.TotalChecks)`n\"\n    $summary += \"  * Health score: $healthScore%`n\"\n    $summary += \"  * Passed: $($healthCheckResults.ExecutiveSummary.PassedChecks)`n\"\n    $summary += \"  * Warnings: $($healthCheckResults.ExecutiveSummary.WarningChecks)`n\"\n    $summary += \"  * Failed: $($healthCheckResults.ExecutiveSummary.FailedChecks)\"\n    \n    Send-Success -Description $summary\n} # End of main try block\ncatch {\n    Send-Error -Code 5 -Description \"Error during health check: $($_.Exception.Message)`n$($_.ScriptStackTrace)\"\n    exit 1\n}",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "server",
						"title": "MSSQL Server",
						"type": "text",
						"caption": "Server hostname or IP",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": true
					},
					{
						"id": "useencryption",
						"title": "Use Encryption",
						"type": "checkbox",
						"caption": "Use connection encryption",
						"locked": false,
						"value": false
					},
					{
						"id": "trustcert",
						"title": "Trust certificate",
						"type": "checkbox",
						"caption": "Trust certificate",
						"locked": false,
						"value": false
					},
					{
						"id": "exclusions",
						"title": "Exclude checks",
						"type": "text",
						"caption": "Exclude checks by reffering to there number in a comma separeted list, eg. 11,45,64 (see documentation for more options)",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "exclusionreason",
						"title": "Reason of exclusion",
						"type": "textarea",
						"caption": "Reason for the excluded items to show in the report",
						"locked": false,
						"value": "",
						"required": false
					},
					{
						"id": "inclusions",
						"title": "Included checks",
						"type": "text",
						"caption": "Select the checks to include separated by a comma, eg 4,37,71 (see documentation for more options)",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": false
					},
					{
						"id": "exporttopdf",
						"title": "Export to PDF",
						"type": "checkbox",
						"caption": "Convert Markdown report to PDF (requires pandoc or markdown-pdf)",
						"locked": false,
						"value": false
					}
				],
				"kill": "parent",
				"runner": false,
				"notes": "",
				"icon": "database-check",
				"uid": "",
				"gid": ""
			}
		}
	]
}
